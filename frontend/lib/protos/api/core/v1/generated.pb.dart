//
//  Generated code. Do not modify.
//  source: api/core/v1/generated.proto
//
// @dart = 2.12

// ignore_for_file: annotate_overrides, camel_case_types, comment_references
// ignore_for_file: constant_identifier_names, library_prefixes
// ignore_for_file: non_constant_identifier_names, prefer_final_fields
// ignore_for_file: unnecessary_import, unnecessary_this, unused_import

import 'dart:core' as $core;

import 'package:fixnum/fixnum.dart' as $fixnum;
import 'package:protobuf/protobuf.dart' as $pb;

import '../../../apimachinery/pkg/api/resource/generated.pb.dart' as $1;
import '../../../apimachinery/pkg/apis/meta/v1/generated.pb.dart' as $0;
import '../../../apimachinery/pkg/runtime/generated.pb.dart' as $3;
import '../../../apimachinery/pkg/util/intstr/generated.pb.dart' as $2;

///  Represents a Persistent Disk resource in AWS.
///
///  An AWS EBS disk must exist before mounting to a container. The disk
///  must also be in the same AWS zone as the kubelet. An AWS EBS disk
///  can only be mounted as read/write once. AWS EBS volumes support
///  ownership management and SELinux relabeling.
class AWSElasticBlockStoreVolumeSource extends $pb.GeneratedMessage {
  factory AWSElasticBlockStoreVolumeSource({
    $core.String? volumeID,
    $core.String? fsType,
    $core.int? partition,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (volumeID != null) {
      $result.volumeID = volumeID;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (partition != null) {
      $result.partition = partition;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  AWSElasticBlockStoreVolumeSource._() : super();
  factory AWSElasticBlockStoreVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AWSElasticBlockStoreVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AWSElasticBlockStoreVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeID', protoName: 'volumeID')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'partition', $pb.PbFieldType.O3)
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AWSElasticBlockStoreVolumeSource clone() => AWSElasticBlockStoreVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AWSElasticBlockStoreVolumeSource copyWith(void Function(AWSElasticBlockStoreVolumeSource) updates) => super.copyWith((message) => updates(message as AWSElasticBlockStoreVolumeSource)) as AWSElasticBlockStoreVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AWSElasticBlockStoreVolumeSource create() => AWSElasticBlockStoreVolumeSource._();
  AWSElasticBlockStoreVolumeSource createEmptyInstance() => create();
  static $pb.PbList<AWSElasticBlockStoreVolumeSource> createRepeated() => $pb.PbList<AWSElasticBlockStoreVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static AWSElasticBlockStoreVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AWSElasticBlockStoreVolumeSource>(create);
  static AWSElasticBlockStoreVolumeSource? _defaultInstance;

  /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  @$pb.TagNumber(1)
  $core.String get volumeID => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeID() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeID() => clearField(1);

  /// fsType is the filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// partition is the partition in the volume that you want to mount.
  /// If omitted, the default is to mount by volume name.
  /// Examples: For volume /dev/sda1, you specify the partition as "1".
  /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  /// +optional
  @$pb.TagNumber(3)
  $core.int get partition => $_getIZ(2);
  @$pb.TagNumber(3)
  set partition($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPartition() => $_has(2);
  @$pb.TagNumber(3)
  void clearPartition() => clearField(3);

  /// readOnly value true will force the readOnly setting in VolumeMounts.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);
}

/// Affinity is a group of affinity scheduling rules.
class Affinity extends $pb.GeneratedMessage {
  factory Affinity({
    NodeAffinity? nodeAffinity,
    PodAffinity? podAffinity,
    PodAntiAffinity? podAntiAffinity,
  }) {
    final $result = create();
    if (nodeAffinity != null) {
      $result.nodeAffinity = nodeAffinity;
    }
    if (podAffinity != null) {
      $result.podAffinity = podAffinity;
    }
    if (podAntiAffinity != null) {
      $result.podAntiAffinity = podAntiAffinity;
    }
    return $result;
  }
  Affinity._() : super();
  factory Affinity.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Affinity.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Affinity', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<NodeAffinity>(1, _omitFieldNames ? '' : 'nodeAffinity', protoName: 'nodeAffinity', subBuilder: NodeAffinity.create)
    ..aOM<PodAffinity>(2, _omitFieldNames ? '' : 'podAffinity', protoName: 'podAffinity', subBuilder: PodAffinity.create)
    ..aOM<PodAntiAffinity>(3, _omitFieldNames ? '' : 'podAntiAffinity', protoName: 'podAntiAffinity', subBuilder: PodAntiAffinity.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Affinity clone() => Affinity()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Affinity copyWith(void Function(Affinity) updates) => super.copyWith((message) => updates(message as Affinity)) as Affinity;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Affinity create() => Affinity._();
  Affinity createEmptyInstance() => create();
  static $pb.PbList<Affinity> createRepeated() => $pb.PbList<Affinity>();
  @$core.pragma('dart2js:noInline')
  static Affinity getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Affinity>(create);
  static Affinity? _defaultInstance;

  /// Describes node affinity scheduling rules for the pod.
  /// +optional
  @$pb.TagNumber(1)
  NodeAffinity get nodeAffinity => $_getN(0);
  @$pb.TagNumber(1)
  set nodeAffinity(NodeAffinity v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasNodeAffinity() => $_has(0);
  @$pb.TagNumber(1)
  void clearNodeAffinity() => clearField(1);
  @$pb.TagNumber(1)
  NodeAffinity ensureNodeAffinity() => $_ensure(0);

  /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  /// +optional
  @$pb.TagNumber(2)
  PodAffinity get podAffinity => $_getN(1);
  @$pb.TagNumber(2)
  set podAffinity(PodAffinity v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPodAffinity() => $_has(1);
  @$pb.TagNumber(2)
  void clearPodAffinity() => clearField(2);
  @$pb.TagNumber(2)
  PodAffinity ensurePodAffinity() => $_ensure(1);

  /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  /// +optional
  @$pb.TagNumber(3)
  PodAntiAffinity get podAntiAffinity => $_getN(2);
  @$pb.TagNumber(3)
  set podAntiAffinity(PodAntiAffinity v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasPodAntiAffinity() => $_has(2);
  @$pb.TagNumber(3)
  void clearPodAntiAffinity() => clearField(3);
  @$pb.TagNumber(3)
  PodAntiAffinity ensurePodAntiAffinity() => $_ensure(2);
}

/// AppArmorProfile defines a pod or container's AppArmor settings.
/// +union
class AppArmorProfile extends $pb.GeneratedMessage {
  factory AppArmorProfile({
    $core.String? type,
    $core.String? localhostProfile,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (localhostProfile != null) {
      $result.localhostProfile = localhostProfile;
    }
    return $result;
  }
  AppArmorProfile._() : super();
  factory AppArmorProfile.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AppArmorProfile.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AppArmorProfile', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'localhostProfile', protoName: 'localhostProfile')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AppArmorProfile clone() => AppArmorProfile()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AppArmorProfile copyWith(void Function(AppArmorProfile) updates) => super.copyWith((message) => updates(message as AppArmorProfile)) as AppArmorProfile;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AppArmorProfile create() => AppArmorProfile._();
  AppArmorProfile createEmptyInstance() => create();
  static $pb.PbList<AppArmorProfile> createRepeated() => $pb.PbList<AppArmorProfile>();
  @$core.pragma('dart2js:noInline')
  static AppArmorProfile getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AppArmorProfile>(create);
  static AppArmorProfile? _defaultInstance;

  /// type indicates which kind of AppArmor profile will be applied.
  /// Valid options are:
  ///   Localhost - a profile pre-loaded on the node.
  ///   RuntimeDefault - the container runtime's default profile.
  ///   Unconfined - no AppArmor enforcement.
  /// +unionDiscriminator
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// localhostProfile indicates a profile loaded on the node that should be used.
  /// The profile must be preconfigured on the node to work.
  /// Must match the loaded name of the profile.
  /// Must be set if and only if type is "Localhost".
  /// +optional
  @$pb.TagNumber(2)
  $core.String get localhostProfile => $_getSZ(1);
  @$pb.TagNumber(2)
  set localhostProfile($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasLocalhostProfile() => $_has(1);
  @$pb.TagNumber(2)
  void clearLocalhostProfile() => clearField(2);
}

/// AttachedVolume describes a volume attached to a node
class AttachedVolume extends $pb.GeneratedMessage {
  factory AttachedVolume({
    $core.String? name,
    $core.String? devicePath,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (devicePath != null) {
      $result.devicePath = devicePath;
    }
    return $result;
  }
  AttachedVolume._() : super();
  factory AttachedVolume.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AttachedVolume.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AttachedVolume', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'devicePath', protoName: 'devicePath')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AttachedVolume clone() => AttachedVolume()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AttachedVolume copyWith(void Function(AttachedVolume) updates) => super.copyWith((message) => updates(message as AttachedVolume)) as AttachedVolume;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AttachedVolume create() => AttachedVolume._();
  AttachedVolume createEmptyInstance() => create();
  static $pb.PbList<AttachedVolume> createRepeated() => $pb.PbList<AttachedVolume>();
  @$core.pragma('dart2js:noInline')
  static AttachedVolume getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AttachedVolume>(create);
  static AttachedVolume? _defaultInstance;

  /// Name of the attached volume
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// DevicePath represents the device path where the volume should be available
  @$pb.TagNumber(2)
  $core.String get devicePath => $_getSZ(1);
  @$pb.TagNumber(2)
  set devicePath($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDevicePath() => $_has(1);
  @$pb.TagNumber(2)
  void clearDevicePath() => clearField(2);
}

/// AvoidPods describes pods that should avoid this node. This is the value for a
/// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
/// will eventually become a field of NodeStatus.
class AvoidPods extends $pb.GeneratedMessage {
  factory AvoidPods({
    $core.Iterable<PreferAvoidPodsEntry>? preferAvoidPods,
  }) {
    final $result = create();
    if (preferAvoidPods != null) {
      $result.preferAvoidPods.addAll(preferAvoidPods);
    }
    return $result;
  }
  AvoidPods._() : super();
  factory AvoidPods.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AvoidPods.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AvoidPods', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<PreferAvoidPodsEntry>(1, _omitFieldNames ? '' : 'preferAvoidPods', $pb.PbFieldType.PM, protoName: 'preferAvoidPods', subBuilder: PreferAvoidPodsEntry.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AvoidPods clone() => AvoidPods()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AvoidPods copyWith(void Function(AvoidPods) updates) => super.copyWith((message) => updates(message as AvoidPods)) as AvoidPods;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AvoidPods create() => AvoidPods._();
  AvoidPods createEmptyInstance() => create();
  static $pb.PbList<AvoidPods> createRepeated() => $pb.PbList<AvoidPods>();
  @$core.pragma('dart2js:noInline')
  static AvoidPods getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AvoidPods>(create);
  static AvoidPods? _defaultInstance;

  /// Bounded-sized list of signatures of pods that should avoid this node, sorted
  /// in timestamp order from oldest to newest. Size of the slice is unspecified.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<PreferAvoidPodsEntry> get preferAvoidPods => $_getList(0);
}

/// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
class AzureDiskVolumeSource extends $pb.GeneratedMessage {
  factory AzureDiskVolumeSource({
    $core.String? diskName,
    $core.String? diskURI,
    $core.String? cachingMode,
    $core.String? fsType,
    $core.bool? readOnly,
    $core.String? kind,
  }) {
    final $result = create();
    if (diskName != null) {
      $result.diskName = diskName;
    }
    if (diskURI != null) {
      $result.diskURI = diskURI;
    }
    if (cachingMode != null) {
      $result.cachingMode = cachingMode;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (kind != null) {
      $result.kind = kind;
    }
    return $result;
  }
  AzureDiskVolumeSource._() : super();
  factory AzureDiskVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AzureDiskVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AzureDiskVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'diskName', protoName: 'diskName')
    ..aOS(2, _omitFieldNames ? '' : 'diskURI', protoName: 'diskURI')
    ..aOS(3, _omitFieldNames ? '' : 'cachingMode', protoName: 'cachingMode')
    ..aOS(4, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(5, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(6, _omitFieldNames ? '' : 'kind')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AzureDiskVolumeSource clone() => AzureDiskVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AzureDiskVolumeSource copyWith(void Function(AzureDiskVolumeSource) updates) => super.copyWith((message) => updates(message as AzureDiskVolumeSource)) as AzureDiskVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AzureDiskVolumeSource create() => AzureDiskVolumeSource._();
  AzureDiskVolumeSource createEmptyInstance() => create();
  static $pb.PbList<AzureDiskVolumeSource> createRepeated() => $pb.PbList<AzureDiskVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static AzureDiskVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AzureDiskVolumeSource>(create);
  static AzureDiskVolumeSource? _defaultInstance;

  /// diskName is the Name of the data disk in the blob storage
  @$pb.TagNumber(1)
  $core.String get diskName => $_getSZ(0);
  @$pb.TagNumber(1)
  set diskName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDiskName() => $_has(0);
  @$pb.TagNumber(1)
  void clearDiskName() => clearField(1);

  /// diskURI is the URI of data disk in the blob storage
  @$pb.TagNumber(2)
  $core.String get diskURI => $_getSZ(1);
  @$pb.TagNumber(2)
  set diskURI($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDiskURI() => $_has(1);
  @$pb.TagNumber(2)
  void clearDiskURI() => clearField(2);

  /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get cachingMode => $_getSZ(2);
  @$pb.TagNumber(3)
  set cachingMode($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasCachingMode() => $_has(2);
  @$pb.TagNumber(3)
  void clearCachingMode() => clearField(3);

  /// fsType is Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get fsType => $_getSZ(3);
  @$pb.TagNumber(4)
  set fsType($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasFsType() => $_has(3);
  @$pb.TagNumber(4)
  void clearFsType() => clearField(4);

  /// readOnly Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(5)
  $core.bool get readOnly => $_getBF(4);
  @$pb.TagNumber(5)
  set readOnly($core.bool v) { $_setBool(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasReadOnly() => $_has(4);
  @$pb.TagNumber(5)
  void clearReadOnly() => clearField(5);

  /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  @$pb.TagNumber(6)
  $core.String get kind => $_getSZ(5);
  @$pb.TagNumber(6)
  set kind($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasKind() => $_has(5);
  @$pb.TagNumber(6)
  void clearKind() => clearField(6);
}

/// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
class AzureFilePersistentVolumeSource extends $pb.GeneratedMessage {
  factory AzureFilePersistentVolumeSource({
    $core.String? secretName,
    $core.String? shareName,
    $core.bool? readOnly,
    $core.String? secretNamespace,
  }) {
    final $result = create();
    if (secretName != null) {
      $result.secretName = secretName;
    }
    if (shareName != null) {
      $result.shareName = shareName;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (secretNamespace != null) {
      $result.secretNamespace = secretNamespace;
    }
    return $result;
  }
  AzureFilePersistentVolumeSource._() : super();
  factory AzureFilePersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AzureFilePersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AzureFilePersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'secretName', protoName: 'secretName')
    ..aOS(2, _omitFieldNames ? '' : 'shareName', protoName: 'shareName')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(4, _omitFieldNames ? '' : 'secretNamespace', protoName: 'secretNamespace')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AzureFilePersistentVolumeSource clone() => AzureFilePersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AzureFilePersistentVolumeSource copyWith(void Function(AzureFilePersistentVolumeSource) updates) => super.copyWith((message) => updates(message as AzureFilePersistentVolumeSource)) as AzureFilePersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AzureFilePersistentVolumeSource create() => AzureFilePersistentVolumeSource._();
  AzureFilePersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<AzureFilePersistentVolumeSource> createRepeated() => $pb.PbList<AzureFilePersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static AzureFilePersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AzureFilePersistentVolumeSource>(create);
  static AzureFilePersistentVolumeSource? _defaultInstance;

  /// secretName is the name of secret that contains Azure Storage Account Name and Key
  @$pb.TagNumber(1)
  $core.String get secretName => $_getSZ(0);
  @$pb.TagNumber(1)
  set secretName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasSecretName() => $_has(0);
  @$pb.TagNumber(1)
  void clearSecretName() => clearField(1);

  /// shareName is the azure Share Name
  @$pb.TagNumber(2)
  $core.String get shareName => $_getSZ(1);
  @$pb.TagNumber(2)
  set shareName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasShareName() => $_has(1);
  @$pb.TagNumber(2)
  void clearShareName() => clearField(2);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// secretNamespace is the namespace of the secret that contains Azure Storage Account Name and Key
  /// default is the same as the Pod
  /// +optional
  @$pb.TagNumber(4)
  $core.String get secretNamespace => $_getSZ(3);
  @$pb.TagNumber(4)
  set secretNamespace($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretNamespace() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretNamespace() => clearField(4);
}

/// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
class AzureFileVolumeSource extends $pb.GeneratedMessage {
  factory AzureFileVolumeSource({
    $core.String? secretName,
    $core.String? shareName,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (secretName != null) {
      $result.secretName = secretName;
    }
    if (shareName != null) {
      $result.shareName = shareName;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  AzureFileVolumeSource._() : super();
  factory AzureFileVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory AzureFileVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'AzureFileVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'secretName', protoName: 'secretName')
    ..aOS(2, _omitFieldNames ? '' : 'shareName', protoName: 'shareName')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  AzureFileVolumeSource clone() => AzureFileVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  AzureFileVolumeSource copyWith(void Function(AzureFileVolumeSource) updates) => super.copyWith((message) => updates(message as AzureFileVolumeSource)) as AzureFileVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static AzureFileVolumeSource create() => AzureFileVolumeSource._();
  AzureFileVolumeSource createEmptyInstance() => create();
  static $pb.PbList<AzureFileVolumeSource> createRepeated() => $pb.PbList<AzureFileVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static AzureFileVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<AzureFileVolumeSource>(create);
  static AzureFileVolumeSource? _defaultInstance;

  /// secretName is the  name of secret that contains Azure Storage Account Name and Key
  @$pb.TagNumber(1)
  $core.String get secretName => $_getSZ(0);
  @$pb.TagNumber(1)
  set secretName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasSecretName() => $_has(0);
  @$pb.TagNumber(1)
  void clearSecretName() => clearField(1);

  /// shareName is the azure share Name
  @$pb.TagNumber(2)
  $core.String get shareName => $_getSZ(1);
  @$pb.TagNumber(2)
  set shareName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasShareName() => $_has(1);
  @$pb.TagNumber(2)
  void clearShareName() => clearField(2);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);
}

/// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
/// Deprecated in 1.7, please use the bindings subresource of pods instead.
class Binding extends $pb.GeneratedMessage {
  factory Binding({
    $0.ObjectMeta? metadata,
    ObjectReference? target,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (target != null) {
      $result.target = target;
    }
    return $result;
  }
  Binding._() : super();
  factory Binding.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Binding.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Binding', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<ObjectReference>(2, _omitFieldNames ? '' : 'target', subBuilder: ObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Binding clone() => Binding()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Binding copyWith(void Function(Binding) updates) => super.copyWith((message) => updates(message as Binding)) as Binding;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Binding create() => Binding._();
  Binding createEmptyInstance() => create();
  static $pb.PbList<Binding> createRepeated() => $pb.PbList<Binding>();
  @$core.pragma('dart2js:noInline')
  static Binding getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Binding>(create);
  static Binding? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// The target object that you want to bind to the standard object.
  @$pb.TagNumber(2)
  ObjectReference get target => $_getN(1);
  @$pb.TagNumber(2)
  set target(ObjectReference v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasTarget() => $_has(1);
  @$pb.TagNumber(2)
  void clearTarget() => clearField(2);
  @$pb.TagNumber(2)
  ObjectReference ensureTarget() => $_ensure(1);
}

/// Represents storage that is managed by an external CSI volume driver (Beta feature)
class CSIPersistentVolumeSource extends $pb.GeneratedMessage {
  factory CSIPersistentVolumeSource({
    $core.String? driver,
    $core.String? volumeHandle,
    $core.bool? readOnly,
    $core.String? fsType,
    $core.Map<$core.String, $core.String>? volumeAttributes,
    SecretReference? controllerPublishSecretRef,
    SecretReference? nodeStageSecretRef,
    SecretReference? nodePublishSecretRef,
    SecretReference? controllerExpandSecretRef,
    SecretReference? nodeExpandSecretRef,
  }) {
    final $result = create();
    if (driver != null) {
      $result.driver = driver;
    }
    if (volumeHandle != null) {
      $result.volumeHandle = volumeHandle;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (volumeAttributes != null) {
      $result.volumeAttributes.addAll(volumeAttributes);
    }
    if (controllerPublishSecretRef != null) {
      $result.controllerPublishSecretRef = controllerPublishSecretRef;
    }
    if (nodeStageSecretRef != null) {
      $result.nodeStageSecretRef = nodeStageSecretRef;
    }
    if (nodePublishSecretRef != null) {
      $result.nodePublishSecretRef = nodePublishSecretRef;
    }
    if (controllerExpandSecretRef != null) {
      $result.controllerExpandSecretRef = controllerExpandSecretRef;
    }
    if (nodeExpandSecretRef != null) {
      $result.nodeExpandSecretRef = nodeExpandSecretRef;
    }
    return $result;
  }
  CSIPersistentVolumeSource._() : super();
  factory CSIPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CSIPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CSIPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'driver')
    ..aOS(2, _omitFieldNames ? '' : 'volumeHandle', protoName: 'volumeHandle')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(4, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..m<$core.String, $core.String>(5, _omitFieldNames ? '' : 'volumeAttributes', protoName: 'volumeAttributes', entryClassName: 'CSIPersistentVolumeSource.VolumeAttributesEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOM<SecretReference>(6, _omitFieldNames ? '' : 'controllerPublishSecretRef', protoName: 'controllerPublishSecretRef', subBuilder: SecretReference.create)
    ..aOM<SecretReference>(7, _omitFieldNames ? '' : 'nodeStageSecretRef', protoName: 'nodeStageSecretRef', subBuilder: SecretReference.create)
    ..aOM<SecretReference>(8, _omitFieldNames ? '' : 'nodePublishSecretRef', protoName: 'nodePublishSecretRef', subBuilder: SecretReference.create)
    ..aOM<SecretReference>(9, _omitFieldNames ? '' : 'controllerExpandSecretRef', protoName: 'controllerExpandSecretRef', subBuilder: SecretReference.create)
    ..aOM<SecretReference>(10, _omitFieldNames ? '' : 'nodeExpandSecretRef', protoName: 'nodeExpandSecretRef', subBuilder: SecretReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CSIPersistentVolumeSource clone() => CSIPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CSIPersistentVolumeSource copyWith(void Function(CSIPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as CSIPersistentVolumeSource)) as CSIPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CSIPersistentVolumeSource create() => CSIPersistentVolumeSource._();
  CSIPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CSIPersistentVolumeSource> createRepeated() => $pb.PbList<CSIPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CSIPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CSIPersistentVolumeSource>(create);
  static CSIPersistentVolumeSource? _defaultInstance;

  /// driver is the name of the driver to use for this volume.
  /// Required.
  @$pb.TagNumber(1)
  $core.String get driver => $_getSZ(0);
  @$pb.TagNumber(1)
  set driver($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDriver() => $_has(0);
  @$pb.TagNumber(1)
  void clearDriver() => clearField(1);

  /// volumeHandle is the unique volume name returned by the CSI volume
  /// plugin’s CreateVolume to refer to the volume on all subsequent calls.
  /// Required.
  @$pb.TagNumber(2)
  $core.String get volumeHandle => $_getSZ(1);
  @$pb.TagNumber(2)
  set volumeHandle($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasVolumeHandle() => $_has(1);
  @$pb.TagNumber(2)
  void clearVolumeHandle() => clearField(2);

  /// readOnly value to pass to ControllerPublishVolumeRequest.
  /// Defaults to false (read/write).
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// fsType to mount. Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// +optional
  @$pb.TagNumber(4)
  $core.String get fsType => $_getSZ(3);
  @$pb.TagNumber(4)
  set fsType($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasFsType() => $_has(3);
  @$pb.TagNumber(4)
  void clearFsType() => clearField(4);

  /// volumeAttributes of the volume to publish.
  /// +optional
  @$pb.TagNumber(5)
  $core.Map<$core.String, $core.String> get volumeAttributes => $_getMap(4);

  /// controllerPublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// ControllerPublishVolume and ControllerUnpublishVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  @$pb.TagNumber(6)
  SecretReference get controllerPublishSecretRef => $_getN(5);
  @$pb.TagNumber(6)
  set controllerPublishSecretRef(SecretReference v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasControllerPublishSecretRef() => $_has(5);
  @$pb.TagNumber(6)
  void clearControllerPublishSecretRef() => clearField(6);
  @$pb.TagNumber(6)
  SecretReference ensureControllerPublishSecretRef() => $_ensure(5);

  /// nodeStageSecretRef is a reference to the secret object containing sensitive
  /// information to pass to the CSI driver to complete the CSI NodeStageVolume
  /// and NodeStageVolume and NodeUnstageVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  @$pb.TagNumber(7)
  SecretReference get nodeStageSecretRef => $_getN(6);
  @$pb.TagNumber(7)
  set nodeStageSecretRef(SecretReference v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasNodeStageSecretRef() => $_has(6);
  @$pb.TagNumber(7)
  void clearNodeStageSecretRef() => clearField(7);
  @$pb.TagNumber(7)
  SecretReference ensureNodeStageSecretRef() => $_ensure(6);

  /// nodePublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// NodePublishVolume and NodeUnpublishVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  @$pb.TagNumber(8)
  SecretReference get nodePublishSecretRef => $_getN(7);
  @$pb.TagNumber(8)
  set nodePublishSecretRef(SecretReference v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasNodePublishSecretRef() => $_has(7);
  @$pb.TagNumber(8)
  void clearNodePublishSecretRef() => clearField(8);
  @$pb.TagNumber(8)
  SecretReference ensureNodePublishSecretRef() => $_ensure(7);

  /// controllerExpandSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// ControllerExpandVolume call.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  @$pb.TagNumber(9)
  SecretReference get controllerExpandSecretRef => $_getN(8);
  @$pb.TagNumber(9)
  set controllerExpandSecretRef(SecretReference v) { setField(9, v); }
  @$pb.TagNumber(9)
  $core.bool hasControllerExpandSecretRef() => $_has(8);
  @$pb.TagNumber(9)
  void clearControllerExpandSecretRef() => clearField(9);
  @$pb.TagNumber(9)
  SecretReference ensureControllerExpandSecretRef() => $_ensure(8);

  /// nodeExpandSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// NodeExpandVolume call.
  /// This field is optional, may be omitted if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  @$pb.TagNumber(10)
  SecretReference get nodeExpandSecretRef => $_getN(9);
  @$pb.TagNumber(10)
  set nodeExpandSecretRef(SecretReference v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasNodeExpandSecretRef() => $_has(9);
  @$pb.TagNumber(10)
  void clearNodeExpandSecretRef() => clearField(10);
  @$pb.TagNumber(10)
  SecretReference ensureNodeExpandSecretRef() => $_ensure(9);
}

/// Represents a source location of a volume to mount, managed by an external CSI driver
class CSIVolumeSource extends $pb.GeneratedMessage {
  factory CSIVolumeSource({
    $core.String? driver,
    $core.bool? readOnly,
    $core.String? fsType,
    $core.Map<$core.String, $core.String>? volumeAttributes,
    LocalObjectReference? nodePublishSecretRef,
  }) {
    final $result = create();
    if (driver != null) {
      $result.driver = driver;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (volumeAttributes != null) {
      $result.volumeAttributes.addAll(volumeAttributes);
    }
    if (nodePublishSecretRef != null) {
      $result.nodePublishSecretRef = nodePublishSecretRef;
    }
    return $result;
  }
  CSIVolumeSource._() : super();
  factory CSIVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CSIVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CSIVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'driver')
    ..aOB(2, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..m<$core.String, $core.String>(4, _omitFieldNames ? '' : 'volumeAttributes', protoName: 'volumeAttributes', entryClassName: 'CSIVolumeSource.VolumeAttributesEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOM<LocalObjectReference>(5, _omitFieldNames ? '' : 'nodePublishSecretRef', protoName: 'nodePublishSecretRef', subBuilder: LocalObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CSIVolumeSource clone() => CSIVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CSIVolumeSource copyWith(void Function(CSIVolumeSource) updates) => super.copyWith((message) => updates(message as CSIVolumeSource)) as CSIVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CSIVolumeSource create() => CSIVolumeSource._();
  CSIVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CSIVolumeSource> createRepeated() => $pb.PbList<CSIVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CSIVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CSIVolumeSource>(create);
  static CSIVolumeSource? _defaultInstance;

  /// driver is the name of the CSI driver that handles this volume.
  /// Consult with your admin for the correct name as registered in the cluster.
  @$pb.TagNumber(1)
  $core.String get driver => $_getSZ(0);
  @$pb.TagNumber(1)
  set driver($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDriver() => $_has(0);
  @$pb.TagNumber(1)
  void clearDriver() => clearField(1);

  /// readOnly specifies a read-only configuration for the volume.
  /// Defaults to false (read/write).
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get readOnly => $_getBF(1);
  @$pb.TagNumber(2)
  set readOnly($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasReadOnly() => $_has(1);
  @$pb.TagNumber(2)
  void clearReadOnly() => clearField(2);

  /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
  /// If not provided, the empty value is passed to the associated CSI driver
  /// which will determine the default filesystem to apply.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// volumeAttributes stores driver-specific properties that are passed to the CSI
  /// driver. Consult your driver's documentation for supported values.
  /// +optional
  @$pb.TagNumber(4)
  $core.Map<$core.String, $core.String> get volumeAttributes => $_getMap(3);

  /// nodePublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// NodePublishVolume and NodeUnpublishVolume calls.
  /// This field is optional, and  may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secret references are passed.
  /// +optional
  @$pb.TagNumber(5)
  LocalObjectReference get nodePublishSecretRef => $_getN(4);
  @$pb.TagNumber(5)
  set nodePublishSecretRef(LocalObjectReference v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasNodePublishSecretRef() => $_has(4);
  @$pb.TagNumber(5)
  void clearNodePublishSecretRef() => clearField(5);
  @$pb.TagNumber(5)
  LocalObjectReference ensureNodePublishSecretRef() => $_ensure(4);
}

/// Adds and removes POSIX capabilities from running containers.
class Capabilities extends $pb.GeneratedMessage {
  factory Capabilities({
    $core.Iterable<$core.String>? add,
    $core.Iterable<$core.String>? drop,
  }) {
    final $result = create();
    if (add != null) {
      $result.add.addAll(add);
    }
    if (drop != null) {
      $result.drop.addAll(drop);
    }
    return $result;
  }
  Capabilities._() : super();
  factory Capabilities.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Capabilities.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Capabilities', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'add')
    ..pPS(2, _omitFieldNames ? '' : 'drop')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Capabilities clone() => Capabilities()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Capabilities copyWith(void Function(Capabilities) updates) => super.copyWith((message) => updates(message as Capabilities)) as Capabilities;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Capabilities create() => Capabilities._();
  Capabilities createEmptyInstance() => create();
  static $pb.PbList<Capabilities> createRepeated() => $pb.PbList<Capabilities>();
  @$core.pragma('dart2js:noInline')
  static Capabilities getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Capabilities>(create);
  static Capabilities? _defaultInstance;

  /// Added capabilities
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get add => $_getList(0);

  /// Removed capabilities
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get drop => $_getList(1);
}

/// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
/// Cephfs volumes do not support ownership management or SELinux relabeling.
class CephFSPersistentVolumeSource extends $pb.GeneratedMessage {
  factory CephFSPersistentVolumeSource({
    $core.Iterable<$core.String>? monitors,
    $core.String? path,
    $core.String? user,
    $core.String? secretFile,
    SecretReference? secretRef,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (monitors != null) {
      $result.monitors.addAll(monitors);
    }
    if (path != null) {
      $result.path = path;
    }
    if (user != null) {
      $result.user = user;
    }
    if (secretFile != null) {
      $result.secretFile = secretFile;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  CephFSPersistentVolumeSource._() : super();
  factory CephFSPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CephFSPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CephFSPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'monitors')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..aOS(3, _omitFieldNames ? '' : 'user')
    ..aOS(4, _omitFieldNames ? '' : 'secretFile', protoName: 'secretFile')
    ..aOM<SecretReference>(5, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..aOB(6, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CephFSPersistentVolumeSource clone() => CephFSPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CephFSPersistentVolumeSource copyWith(void Function(CephFSPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as CephFSPersistentVolumeSource)) as CephFSPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CephFSPersistentVolumeSource create() => CephFSPersistentVolumeSource._();
  CephFSPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CephFSPersistentVolumeSource> createRepeated() => $pb.PbList<CephFSPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CephFSPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CephFSPersistentVolumeSource>(create);
  static CephFSPersistentVolumeSource? _defaultInstance;

  /// monitors is Required: Monitors is a collection of Ceph monitors
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get monitors => $_getList(0);

  /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  /// +optional
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// user is Optional: User is the rados user name, default is admin
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(3)
  $core.String get user => $_getSZ(2);
  @$pb.TagNumber(3)
  set user($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasUser() => $_has(2);
  @$pb.TagNumber(3)
  void clearUser() => clearField(3);

  /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(4)
  $core.String get secretFile => $_getSZ(3);
  @$pb.TagNumber(4)
  set secretFile($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretFile() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretFile() => clearField(4);

  /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(5)
  SecretReference get secretRef => $_getN(4);
  @$pb.TagNumber(5)
  set secretRef(SecretReference v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSecretRef() => $_has(4);
  @$pb.TagNumber(5)
  void clearSecretRef() => clearField(5);
  @$pb.TagNumber(5)
  SecretReference ensureSecretRef() => $_ensure(4);

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get readOnly => $_getBF(5);
  @$pb.TagNumber(6)
  set readOnly($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasReadOnly() => $_has(5);
  @$pb.TagNumber(6)
  void clearReadOnly() => clearField(6);
}

/// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
/// Cephfs volumes do not support ownership management or SELinux relabeling.
class CephFSVolumeSource extends $pb.GeneratedMessage {
  factory CephFSVolumeSource({
    $core.Iterable<$core.String>? monitors,
    $core.String? path,
    $core.String? user,
    $core.String? secretFile,
    LocalObjectReference? secretRef,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (monitors != null) {
      $result.monitors.addAll(monitors);
    }
    if (path != null) {
      $result.path = path;
    }
    if (user != null) {
      $result.user = user;
    }
    if (secretFile != null) {
      $result.secretFile = secretFile;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  CephFSVolumeSource._() : super();
  factory CephFSVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CephFSVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CephFSVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'monitors')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..aOS(3, _omitFieldNames ? '' : 'user')
    ..aOS(4, _omitFieldNames ? '' : 'secretFile', protoName: 'secretFile')
    ..aOM<LocalObjectReference>(5, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..aOB(6, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CephFSVolumeSource clone() => CephFSVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CephFSVolumeSource copyWith(void Function(CephFSVolumeSource) updates) => super.copyWith((message) => updates(message as CephFSVolumeSource)) as CephFSVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CephFSVolumeSource create() => CephFSVolumeSource._();
  CephFSVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CephFSVolumeSource> createRepeated() => $pb.PbList<CephFSVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CephFSVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CephFSVolumeSource>(create);
  static CephFSVolumeSource? _defaultInstance;

  /// monitors is Required: Monitors is a collection of Ceph monitors
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get monitors => $_getList(0);

  /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  /// +optional
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// user is optional: User is the rados user name, default is admin
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(3)
  $core.String get user => $_getSZ(2);
  @$pb.TagNumber(3)
  set user($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasUser() => $_has(2);
  @$pb.TagNumber(3)
  void clearUser() => clearField(3);

  /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(4)
  $core.String get secretFile => $_getSZ(3);
  @$pb.TagNumber(4)
  set secretFile($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretFile() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretFile() => clearField(4);

  /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(5)
  LocalObjectReference get secretRef => $_getN(4);
  @$pb.TagNumber(5)
  set secretRef(LocalObjectReference v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSecretRef() => $_has(4);
  @$pb.TagNumber(5)
  void clearSecretRef() => clearField(5);
  @$pb.TagNumber(5)
  LocalObjectReference ensureSecretRef() => $_ensure(4);

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get readOnly => $_getBF(5);
  @$pb.TagNumber(6)
  set readOnly($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasReadOnly() => $_has(5);
  @$pb.TagNumber(6)
  void clearReadOnly() => clearField(6);
}

/// Represents a cinder volume resource in Openstack.
/// A Cinder volume must exist before mounting to a container.
/// The volume must also be in the same region as the kubelet.
/// Cinder volumes support ownership management and SELinux relabeling.
class CinderPersistentVolumeSource extends $pb.GeneratedMessage {
  factory CinderPersistentVolumeSource({
    $core.String? volumeID,
    $core.String? fsType,
    $core.bool? readOnly,
    SecretReference? secretRef,
  }) {
    final $result = create();
    if (volumeID != null) {
      $result.volumeID = volumeID;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    return $result;
  }
  CinderPersistentVolumeSource._() : super();
  factory CinderPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CinderPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CinderPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeID', protoName: 'volumeID')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOM<SecretReference>(4, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CinderPersistentVolumeSource clone() => CinderPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CinderPersistentVolumeSource copyWith(void Function(CinderPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as CinderPersistentVolumeSource)) as CinderPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CinderPersistentVolumeSource create() => CinderPersistentVolumeSource._();
  CinderPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CinderPersistentVolumeSource> createRepeated() => $pb.PbList<CinderPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CinderPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CinderPersistentVolumeSource>(create);
  static CinderPersistentVolumeSource? _defaultInstance;

  /// volumeID used to identify the volume in cinder.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  @$pb.TagNumber(1)
  $core.String get volumeID => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeID() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeID() => clearField(1);

  /// fsType Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// secretRef is Optional: points to a secret object containing parameters used to connect
  /// to OpenStack.
  /// +optional
  @$pb.TagNumber(4)
  SecretReference get secretRef => $_getN(3);
  @$pb.TagNumber(4)
  set secretRef(SecretReference v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretRef() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretRef() => clearField(4);
  @$pb.TagNumber(4)
  SecretReference ensureSecretRef() => $_ensure(3);
}

/// Represents a cinder volume resource in Openstack.
/// A Cinder volume must exist before mounting to a container.
/// The volume must also be in the same region as the kubelet.
/// Cinder volumes support ownership management and SELinux relabeling.
class CinderVolumeSource extends $pb.GeneratedMessage {
  factory CinderVolumeSource({
    $core.String? volumeID,
    $core.String? fsType,
    $core.bool? readOnly,
    LocalObjectReference? secretRef,
  }) {
    final $result = create();
    if (volumeID != null) {
      $result.volumeID = volumeID;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    return $result;
  }
  CinderVolumeSource._() : super();
  factory CinderVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory CinderVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'CinderVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeID', protoName: 'volumeID')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOM<LocalObjectReference>(4, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  CinderVolumeSource clone() => CinderVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  CinderVolumeSource copyWith(void Function(CinderVolumeSource) updates) => super.copyWith((message) => updates(message as CinderVolumeSource)) as CinderVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static CinderVolumeSource create() => CinderVolumeSource._();
  CinderVolumeSource createEmptyInstance() => create();
  static $pb.PbList<CinderVolumeSource> createRepeated() => $pb.PbList<CinderVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static CinderVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<CinderVolumeSource>(create);
  static CinderVolumeSource? _defaultInstance;

  /// volumeID used to identify the volume in cinder.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  @$pb.TagNumber(1)
  $core.String get volumeID => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeID() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeID() => clearField(1);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// secretRef is optional: points to a secret object containing parameters used to connect
  /// to OpenStack.
  /// +optional
  @$pb.TagNumber(4)
  LocalObjectReference get secretRef => $_getN(3);
  @$pb.TagNumber(4)
  set secretRef(LocalObjectReference v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretRef() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretRef() => clearField(4);
  @$pb.TagNumber(4)
  LocalObjectReference ensureSecretRef() => $_ensure(3);
}

///  ClaimSource describes a reference to a ResourceClaim.
///
///  Exactly one of these fields should be set.  Consumers of this type must
///  treat an empty object as if it has an unknown value.
class ClaimSource extends $pb.GeneratedMessage {
  factory ClaimSource({
    $core.String? resourceClaimName,
    $core.String? resourceClaimTemplateName,
  }) {
    final $result = create();
    if (resourceClaimName != null) {
      $result.resourceClaimName = resourceClaimName;
    }
    if (resourceClaimTemplateName != null) {
      $result.resourceClaimTemplateName = resourceClaimTemplateName;
    }
    return $result;
  }
  ClaimSource._() : super();
  factory ClaimSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ClaimSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ClaimSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'resourceClaimName', protoName: 'resourceClaimName')
    ..aOS(2, _omitFieldNames ? '' : 'resourceClaimTemplateName', protoName: 'resourceClaimTemplateName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ClaimSource clone() => ClaimSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ClaimSource copyWith(void Function(ClaimSource) updates) => super.copyWith((message) => updates(message as ClaimSource)) as ClaimSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ClaimSource create() => ClaimSource._();
  ClaimSource createEmptyInstance() => create();
  static $pb.PbList<ClaimSource> createRepeated() => $pb.PbList<ClaimSource>();
  @$core.pragma('dart2js:noInline')
  static ClaimSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ClaimSource>(create);
  static ClaimSource? _defaultInstance;

  /// ResourceClaimName is the name of a ResourceClaim object in the same
  /// namespace as this pod.
  @$pb.TagNumber(1)
  $core.String get resourceClaimName => $_getSZ(0);
  @$pb.TagNumber(1)
  set resourceClaimName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasResourceClaimName() => $_has(0);
  @$pb.TagNumber(1)
  void clearResourceClaimName() => clearField(1);

  ///  ResourceClaimTemplateName is the name of a ResourceClaimTemplate
  ///  object in the same namespace as this pod.
  ///
  ///  The template will be used to create a new ResourceClaim, which will
  ///  be bound to this pod. When this pod is deleted, the ResourceClaim
  ///  will also be deleted. The pod name and resource name, along with a
  ///  generated component, will be used to form a unique name for the
  ///  ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
  ///
  ///  This field is immutable and no changes will be made to the
  ///  corresponding ResourceClaim by the control plane after creating the
  ///  ResourceClaim.
  @$pb.TagNumber(2)
  $core.String get resourceClaimTemplateName => $_getSZ(1);
  @$pb.TagNumber(2)
  set resourceClaimTemplateName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasResourceClaimTemplateName() => $_has(1);
  @$pb.TagNumber(2)
  void clearResourceClaimTemplateName() => clearField(2);
}

/// ClientIPConfig represents the configurations of Client IP based session affinity.
class ClientIPConfig extends $pb.GeneratedMessage {
  factory ClientIPConfig({
    $core.int? timeoutSeconds,
  }) {
    final $result = create();
    if (timeoutSeconds != null) {
      $result.timeoutSeconds = timeoutSeconds;
    }
    return $result;
  }
  ClientIPConfig._() : super();
  factory ClientIPConfig.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ClientIPConfig.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ClientIPConfig', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'timeoutSeconds', $pb.PbFieldType.O3, protoName: 'timeoutSeconds')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ClientIPConfig clone() => ClientIPConfig()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ClientIPConfig copyWith(void Function(ClientIPConfig) updates) => super.copyWith((message) => updates(message as ClientIPConfig)) as ClientIPConfig;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ClientIPConfig create() => ClientIPConfig._();
  ClientIPConfig createEmptyInstance() => create();
  static $pb.PbList<ClientIPConfig> createRepeated() => $pb.PbList<ClientIPConfig>();
  @$core.pragma('dart2js:noInline')
  static ClientIPConfig getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ClientIPConfig>(create);
  static ClientIPConfig? _defaultInstance;

  /// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
  /// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
  /// Default value is 10800(for 3 hours).
  /// +optional
  @$pb.TagNumber(1)
  $core.int get timeoutSeconds => $_getIZ(0);
  @$pb.TagNumber(1)
  set timeoutSeconds($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasTimeoutSeconds() => $_has(0);
  @$pb.TagNumber(1)
  void clearTimeoutSeconds() => clearField(1);
}

/// ClusterTrustBundleProjection describes how to select a set of
/// ClusterTrustBundle objects and project their contents into the pod
/// filesystem.
class ClusterTrustBundleProjection extends $pb.GeneratedMessage {
  factory ClusterTrustBundleProjection({
    $core.String? name,
    $core.String? signerName,
    $0.LabelSelector? labelSelector,
    $core.String? path,
    $core.bool? optional,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (signerName != null) {
      $result.signerName = signerName;
    }
    if (labelSelector != null) {
      $result.labelSelector = labelSelector;
    }
    if (path != null) {
      $result.path = path;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  ClusterTrustBundleProjection._() : super();
  factory ClusterTrustBundleProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ClusterTrustBundleProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ClusterTrustBundleProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'signerName', protoName: 'signerName')
    ..aOM<$0.LabelSelector>(3, _omitFieldNames ? '' : 'labelSelector', protoName: 'labelSelector', subBuilder: $0.LabelSelector.create)
    ..aOS(4, _omitFieldNames ? '' : 'path')
    ..aOB(5, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ClusterTrustBundleProjection clone() => ClusterTrustBundleProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ClusterTrustBundleProjection copyWith(void Function(ClusterTrustBundleProjection) updates) => super.copyWith((message) => updates(message as ClusterTrustBundleProjection)) as ClusterTrustBundleProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ClusterTrustBundleProjection create() => ClusterTrustBundleProjection._();
  ClusterTrustBundleProjection createEmptyInstance() => create();
  static $pb.PbList<ClusterTrustBundleProjection> createRepeated() => $pb.PbList<ClusterTrustBundleProjection>();
  @$core.pragma('dart2js:noInline')
  static ClusterTrustBundleProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ClusterTrustBundleProjection>(create);
  static ClusterTrustBundleProjection? _defaultInstance;

  /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
  /// with signerName and labelSelector.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Select all ClusterTrustBundles that match this signer name.
  /// Mutually-exclusive with name.  The contents of all selected
  /// ClusterTrustBundles will be unified and deduplicated.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get signerName => $_getSZ(1);
  @$pb.TagNumber(2)
  set signerName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSignerName() => $_has(1);
  @$pb.TagNumber(2)
  void clearSignerName() => clearField(2);

  /// Select all ClusterTrustBundles that match this label selector.  Only has
  /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
  /// interpreted as "match nothing".  If set but empty, interpreted as "match
  /// everything".
  /// +optional
  @$pb.TagNumber(3)
  $0.LabelSelector get labelSelector => $_getN(2);
  @$pb.TagNumber(3)
  set labelSelector($0.LabelSelector v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLabelSelector() => $_has(2);
  @$pb.TagNumber(3)
  void clearLabelSelector() => clearField(3);
  @$pb.TagNumber(3)
  $0.LabelSelector ensureLabelSelector() => $_ensure(2);

  /// Relative path from the volume root to write the bundle.
  @$pb.TagNumber(4)
  $core.String get path => $_getSZ(3);
  @$pb.TagNumber(4)
  set path($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasPath() => $_has(3);
  @$pb.TagNumber(4)
  void clearPath() => clearField(4);

  /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
  /// aren't available.  If using name, then the named ClusterTrustBundle is
  /// allowed not to exist.  If using signerName, then the combination of
  /// signerName and labelSelector is allowed to match zero
  /// ClusterTrustBundles.
  /// +optional
  @$pb.TagNumber(5)
  $core.bool get optional => $_getBF(4);
  @$pb.TagNumber(5)
  set optional($core.bool v) { $_setBool(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasOptional() => $_has(4);
  @$pb.TagNumber(5)
  void clearOptional() => clearField(5);
}

/// Information about the condition of a component.
class ComponentCondition extends $pb.GeneratedMessage {
  factory ComponentCondition({
    $core.String? type,
    $core.String? status,
    $core.String? message,
    $core.String? error,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (message != null) {
      $result.message = message;
    }
    if (error != null) {
      $result.error = error;
    }
    return $result;
  }
  ComponentCondition._() : super();
  factory ComponentCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ComponentCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ComponentCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOS(3, _omitFieldNames ? '' : 'message')
    ..aOS(4, _omitFieldNames ? '' : 'error')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ComponentCondition clone() => ComponentCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ComponentCondition copyWith(void Function(ComponentCondition) updates) => super.copyWith((message) => updates(message as ComponentCondition)) as ComponentCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ComponentCondition create() => ComponentCondition._();
  ComponentCondition createEmptyInstance() => create();
  static $pb.PbList<ComponentCondition> createRepeated() => $pb.PbList<ComponentCondition>();
  @$core.pragma('dart2js:noInline')
  static ComponentCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ComponentCondition>(create);
  static ComponentCondition? _defaultInstance;

  /// Type of condition for a component.
  /// Valid value: "Healthy"
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Status of the condition for a component.
  /// Valid values for "Healthy": "True", "False", or "Unknown".
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// Message about the condition for a component.
  /// For example, information about a health check.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get message => $_getSZ(2);
  @$pb.TagNumber(3)
  set message($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasMessage() => $_has(2);
  @$pb.TagNumber(3)
  void clearMessage() => clearField(3);

  /// Condition error code for a component.
  /// For example, a health check error code.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get error => $_getSZ(3);
  @$pb.TagNumber(4)
  set error($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasError() => $_has(3);
  @$pb.TagNumber(4)
  void clearError() => clearField(4);
}

/// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
/// Deprecated: This API is deprecated in v1.19+
class ComponentStatus extends $pb.GeneratedMessage {
  factory ComponentStatus({
    $0.ObjectMeta? metadata,
    $core.Iterable<ComponentCondition>? conditions,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    return $result;
  }
  ComponentStatus._() : super();
  factory ComponentStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ComponentStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ComponentStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..pc<ComponentCondition>(2, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: ComponentCondition.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ComponentStatus clone() => ComponentStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ComponentStatus copyWith(void Function(ComponentStatus) updates) => super.copyWith((message) => updates(message as ComponentStatus)) as ComponentStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ComponentStatus create() => ComponentStatus._();
  ComponentStatus createEmptyInstance() => create();
  static $pb.PbList<ComponentStatus> createRepeated() => $pb.PbList<ComponentStatus>();
  @$core.pragma('dart2js:noInline')
  static ComponentStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ComponentStatus>(create);
  static ComponentStatus? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// List of component conditions observed
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(2)
  $core.List<ComponentCondition> get conditions => $_getList(1);
}

/// Status of all the conditions for the component as a list of ComponentStatus objects.
/// Deprecated: This API is deprecated in v1.19+
class ComponentStatusList extends $pb.GeneratedMessage {
  factory ComponentStatusList({
    $0.ListMeta? metadata,
    $core.Iterable<ComponentStatus>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ComponentStatusList._() : super();
  factory ComponentStatusList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ComponentStatusList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ComponentStatusList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<ComponentStatus>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: ComponentStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ComponentStatusList clone() => ComponentStatusList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ComponentStatusList copyWith(void Function(ComponentStatusList) updates) => super.copyWith((message) => updates(message as ComponentStatusList)) as ComponentStatusList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ComponentStatusList create() => ComponentStatusList._();
  ComponentStatusList createEmptyInstance() => create();
  static $pb.PbList<ComponentStatusList> createRepeated() => $pb.PbList<ComponentStatusList>();
  @$core.pragma('dart2js:noInline')
  static ComponentStatusList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ComponentStatusList>(create);
  static ComponentStatusList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of ComponentStatus objects.
  @$pb.TagNumber(2)
  $core.List<ComponentStatus> get items => $_getList(1);
}

/// ConfigMap holds configuration data for pods to consume.
class ConfigMap extends $pb.GeneratedMessage {
  factory ConfigMap({
    $0.ObjectMeta? metadata,
    $core.Map<$core.String, $core.String>? data,
    $core.Map<$core.String, $core.List<$core.int>>? binaryData,
    $core.bool? immutable,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (data != null) {
      $result.data.addAll(data);
    }
    if (binaryData != null) {
      $result.binaryData.addAll(binaryData);
    }
    if (immutable != null) {
      $result.immutable = immutable;
    }
    return $result;
  }
  ConfigMap._() : super();
  factory ConfigMap.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMap.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMap', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..m<$core.String, $core.String>(2, _omitFieldNames ? '' : 'data', entryClassName: 'ConfigMap.DataEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $core.List<$core.int>>(3, _omitFieldNames ? '' : 'binaryData', protoName: 'binaryData', entryClassName: 'ConfigMap.BinaryDataEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OY, packageName: const $pb.PackageName('api.core.v1'))
    ..aOB(4, _omitFieldNames ? '' : 'immutable')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMap clone() => ConfigMap()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMap copyWith(void Function(ConfigMap) updates) => super.copyWith((message) => updates(message as ConfigMap)) as ConfigMap;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMap create() => ConfigMap._();
  ConfigMap createEmptyInstance() => create();
  static $pb.PbList<ConfigMap> createRepeated() => $pb.PbList<ConfigMap>();
  @$core.pragma('dart2js:noInline')
  static ConfigMap getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMap>(create);
  static ConfigMap? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Data contains the configuration data.
  /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
  /// Values with non-UTF-8 byte sequences must use the BinaryData field.
  /// The keys stored in Data must not overlap with the keys in
  /// the BinaryData field, this is enforced during validation process.
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $core.String> get data => $_getMap(1);

  /// BinaryData contains the binary data.
  /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
  /// BinaryData can contain byte sequences that are not in the UTF-8 range.
  /// The keys stored in BinaryData must not overlap with the ones in
  /// the Data field, this is enforced during validation process.
  /// Using this field will require 1.10+ apiserver and
  /// kubelet.
  /// +optional
  @$pb.TagNumber(3)
  $core.Map<$core.String, $core.List<$core.int>> get binaryData => $_getMap(2);

  /// Immutable, if set to true, ensures that data stored in the ConfigMap cannot
  /// be updated (only object metadata can be modified).
  /// If not set to true, the field can be modified at any time.
  /// Defaulted to nil.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get immutable => $_getBF(3);
  @$pb.TagNumber(4)
  set immutable($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasImmutable() => $_has(3);
  @$pb.TagNumber(4)
  void clearImmutable() => clearField(4);
}

///  ConfigMapEnvSource selects a ConfigMap to populate the environment
///  variables with.
///
///  The contents of the target ConfigMap's Data field will represent the
///  key-value pairs as environment variables.
class ConfigMapEnvSource extends $pb.GeneratedMessage {
  factory ConfigMapEnvSource({
    LocalObjectReference? localObjectReference,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  ConfigMapEnvSource._() : super();
  factory ConfigMapEnvSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapEnvSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapEnvSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..aOB(2, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapEnvSource clone() => ConfigMapEnvSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapEnvSource copyWith(void Function(ConfigMapEnvSource) updates) => super.copyWith((message) => updates(message as ConfigMapEnvSource)) as ConfigMapEnvSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapEnvSource create() => ConfigMapEnvSource._();
  ConfigMapEnvSource createEmptyInstance() => create();
  static $pb.PbList<ConfigMapEnvSource> createRepeated() => $pb.PbList<ConfigMapEnvSource>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapEnvSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapEnvSource>(create);
  static ConfigMapEnvSource? _defaultInstance;

  /// The ConfigMap to select from.
  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// Specify whether the ConfigMap must be defined
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get optional => $_getBF(1);
  @$pb.TagNumber(2)
  set optional($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasOptional() => $_has(1);
  @$pb.TagNumber(2)
  void clearOptional() => clearField(2);
}

/// Selects a key from a ConfigMap.
/// +structType=atomic
class ConfigMapKeySelector extends $pb.GeneratedMessage {
  factory ConfigMapKeySelector({
    LocalObjectReference? localObjectReference,
    $core.String? key,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (key != null) {
      $result.key = key;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  ConfigMapKeySelector._() : super();
  factory ConfigMapKeySelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapKeySelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapKeySelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..aOS(2, _omitFieldNames ? '' : 'key')
    ..aOB(3, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapKeySelector clone() => ConfigMapKeySelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapKeySelector copyWith(void Function(ConfigMapKeySelector) updates) => super.copyWith((message) => updates(message as ConfigMapKeySelector)) as ConfigMapKeySelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapKeySelector create() => ConfigMapKeySelector._();
  ConfigMapKeySelector createEmptyInstance() => create();
  static $pb.PbList<ConfigMapKeySelector> createRepeated() => $pb.PbList<ConfigMapKeySelector>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapKeySelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapKeySelector>(create);
  static ConfigMapKeySelector? _defaultInstance;

  /// The ConfigMap to select from.
  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// The key to select.
  @$pb.TagNumber(2)
  $core.String get key => $_getSZ(1);
  @$pb.TagNumber(2)
  set key($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasKey() => $_has(1);
  @$pb.TagNumber(2)
  void clearKey() => clearField(2);

  /// Specify whether the ConfigMap or its key must be defined
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get optional => $_getBF(2);
  @$pb.TagNumber(3)
  set optional($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasOptional() => $_has(2);
  @$pb.TagNumber(3)
  void clearOptional() => clearField(3);
}

/// ConfigMapList is a resource containing a list of ConfigMap objects.
class ConfigMapList extends $pb.GeneratedMessage {
  factory ConfigMapList({
    $0.ListMeta? metadata,
    $core.Iterable<ConfigMap>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ConfigMapList._() : super();
  factory ConfigMapList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<ConfigMap>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: ConfigMap.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapList clone() => ConfigMapList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapList copyWith(void Function(ConfigMapList) updates) => super.copyWith((message) => updates(message as ConfigMapList)) as ConfigMapList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapList create() => ConfigMapList._();
  ConfigMapList createEmptyInstance() => create();
  static $pb.PbList<ConfigMapList> createRepeated() => $pb.PbList<ConfigMapList>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapList>(create);
  static ConfigMapList? _defaultInstance;

  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// Items is the list of ConfigMaps.
  @$pb.TagNumber(2)
  $core.List<ConfigMap> get items => $_getList(1);
}

/// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
/// This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration
class ConfigMapNodeConfigSource extends $pb.GeneratedMessage {
  factory ConfigMapNodeConfigSource({
    $core.String? namespace,
    $core.String? name,
    $core.String? uid,
    $core.String? resourceVersion,
    $core.String? kubeletConfigKey,
  }) {
    final $result = create();
    if (namespace != null) {
      $result.namespace = namespace;
    }
    if (name != null) {
      $result.name = name;
    }
    if (uid != null) {
      $result.uid = uid;
    }
    if (resourceVersion != null) {
      $result.resourceVersion = resourceVersion;
    }
    if (kubeletConfigKey != null) {
      $result.kubeletConfigKey = kubeletConfigKey;
    }
    return $result;
  }
  ConfigMapNodeConfigSource._() : super();
  factory ConfigMapNodeConfigSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapNodeConfigSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapNodeConfigSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'namespace')
    ..aOS(2, _omitFieldNames ? '' : 'name')
    ..aOS(3, _omitFieldNames ? '' : 'uid')
    ..aOS(4, _omitFieldNames ? '' : 'resourceVersion', protoName: 'resourceVersion')
    ..aOS(5, _omitFieldNames ? '' : 'kubeletConfigKey', protoName: 'kubeletConfigKey')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapNodeConfigSource clone() => ConfigMapNodeConfigSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapNodeConfigSource copyWith(void Function(ConfigMapNodeConfigSource) updates) => super.copyWith((message) => updates(message as ConfigMapNodeConfigSource)) as ConfigMapNodeConfigSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapNodeConfigSource create() => ConfigMapNodeConfigSource._();
  ConfigMapNodeConfigSource createEmptyInstance() => create();
  static $pb.PbList<ConfigMapNodeConfigSource> createRepeated() => $pb.PbList<ConfigMapNodeConfigSource>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapNodeConfigSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapNodeConfigSource>(create);
  static ConfigMapNodeConfigSource? _defaultInstance;

  /// Namespace is the metadata.namespace of the referenced ConfigMap.
  /// This field is required in all cases.
  @$pb.TagNumber(1)
  $core.String get namespace => $_getSZ(0);
  @$pb.TagNumber(1)
  set namespace($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasNamespace() => $_has(0);
  @$pb.TagNumber(1)
  void clearNamespace() => clearField(1);

  /// Name is the metadata.name of the referenced ConfigMap.
  /// This field is required in all cases.
  @$pb.TagNumber(2)
  $core.String get name => $_getSZ(1);
  @$pb.TagNumber(2)
  set name($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasName() => $_has(1);
  @$pb.TagNumber(2)
  void clearName() => clearField(2);

  /// UID is the metadata.UID of the referenced ConfigMap.
  /// This field is forbidden in Node.Spec, and required in Node.Status.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get uid => $_getSZ(2);
  @$pb.TagNumber(3)
  set uid($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasUid() => $_has(2);
  @$pb.TagNumber(3)
  void clearUid() => clearField(3);

  /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
  /// This field is forbidden in Node.Spec, and required in Node.Status.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get resourceVersion => $_getSZ(3);
  @$pb.TagNumber(4)
  set resourceVersion($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasResourceVersion() => $_has(3);
  @$pb.TagNumber(4)
  void clearResourceVersion() => clearField(4);

  /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
  /// This field is required in all cases.
  @$pb.TagNumber(5)
  $core.String get kubeletConfigKey => $_getSZ(4);
  @$pb.TagNumber(5)
  set kubeletConfigKey($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasKubeletConfigKey() => $_has(4);
  @$pb.TagNumber(5)
  void clearKubeletConfigKey() => clearField(5);
}

///  Adapts a ConfigMap into a projected volume.
///
///  The contents of the target ConfigMap's Data field will be presented in a
///  projected volume as files using the keys in the Data field as the file names,
///  unless the items element is populated with specific mappings of keys to paths.
///  Note that this is identical to a configmap volume source without the default
///  mode.
class ConfigMapProjection extends $pb.GeneratedMessage {
  factory ConfigMapProjection({
    LocalObjectReference? localObjectReference,
    $core.Iterable<KeyToPath>? items,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  ConfigMapProjection._() : super();
  factory ConfigMapProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..pc<KeyToPath>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: KeyToPath.create)
    ..aOB(4, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapProjection clone() => ConfigMapProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapProjection copyWith(void Function(ConfigMapProjection) updates) => super.copyWith((message) => updates(message as ConfigMapProjection)) as ConfigMapProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapProjection create() => ConfigMapProjection._();
  ConfigMapProjection createEmptyInstance() => create();
  static $pb.PbList<ConfigMapProjection> createRepeated() => $pb.PbList<ConfigMapProjection>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapProjection>(create);
  static ConfigMapProjection? _defaultInstance;

  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// items if unspecified, each key-value pair in the Data field of the referenced
  /// ConfigMap will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the ConfigMap,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<KeyToPath> get items => $_getList(1);

  /// optional specify whether the ConfigMap or its keys must be defined
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get optional => $_getBF(2);
  @$pb.TagNumber(4)
  set optional($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(4)
  $core.bool hasOptional() => $_has(2);
  @$pb.TagNumber(4)
  void clearOptional() => clearField(4);
}

///  Adapts a ConfigMap into a volume.
///
///  The contents of the target ConfigMap's Data field will be presented in a
///  volume as files using the keys in the Data field as the file names, unless
///  the items element is populated with specific mappings of keys to paths.
///  ConfigMap volumes support ownership management and SELinux relabeling.
class ConfigMapVolumeSource extends $pb.GeneratedMessage {
  factory ConfigMapVolumeSource({
    LocalObjectReference? localObjectReference,
    $core.Iterable<KeyToPath>? items,
    $core.int? defaultMode,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    if (defaultMode != null) {
      $result.defaultMode = defaultMode;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  ConfigMapVolumeSource._() : super();
  factory ConfigMapVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ConfigMapVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ConfigMapVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..pc<KeyToPath>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: KeyToPath.create)
    ..a<$core.int>(3, _omitFieldNames ? '' : 'defaultMode', $pb.PbFieldType.O3, protoName: 'defaultMode')
    ..aOB(4, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ConfigMapVolumeSource clone() => ConfigMapVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ConfigMapVolumeSource copyWith(void Function(ConfigMapVolumeSource) updates) => super.copyWith((message) => updates(message as ConfigMapVolumeSource)) as ConfigMapVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ConfigMapVolumeSource create() => ConfigMapVolumeSource._();
  ConfigMapVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ConfigMapVolumeSource> createRepeated() => $pb.PbList<ConfigMapVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ConfigMapVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ConfigMapVolumeSource>(create);
  static ConfigMapVolumeSource? _defaultInstance;

  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// items if unspecified, each key-value pair in the Data field of the referenced
  /// ConfigMap will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the ConfigMap,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<KeyToPath> get items => $_getList(1);

  /// defaultMode is optional: mode bits used to set permissions on created files by default.
  /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  /// Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(3)
  $core.int get defaultMode => $_getIZ(2);
  @$pb.TagNumber(3)
  set defaultMode($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasDefaultMode() => $_has(2);
  @$pb.TagNumber(3)
  void clearDefaultMode() => clearField(3);

  /// optional specify whether the ConfigMap or its keys must be defined
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get optional => $_getBF(3);
  @$pb.TagNumber(4)
  set optional($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasOptional() => $_has(3);
  @$pb.TagNumber(4)
  void clearOptional() => clearField(4);
}

/// A single application container that you want to run within a pod.
class Container extends $pb.GeneratedMessage {
  factory Container({
    $core.String? name,
    $core.String? image,
    $core.Iterable<$core.String>? command,
    $core.Iterable<$core.String>? args,
    $core.String? workingDir,
    $core.Iterable<ContainerPort>? ports,
    $core.Iterable<EnvVar>? env,
    ResourceRequirements? resources,
    $core.Iterable<VolumeMount>? volumeMounts,
    Probe? livenessProbe,
    Probe? readinessProbe,
    Lifecycle? lifecycle,
    $core.String? terminationMessagePath,
    $core.String? imagePullPolicy,
    SecurityContext? securityContext,
    $core.bool? stdin,
    $core.bool? stdinOnce,
    $core.bool? tty,
    $core.Iterable<EnvFromSource>? envFrom,
    $core.String? terminationMessagePolicy,
    $core.Iterable<VolumeDevice>? volumeDevices,
    Probe? startupProbe,
    $core.Iterable<ContainerResizePolicy>? resizePolicy,
    $core.String? restartPolicy,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (image != null) {
      $result.image = image;
    }
    if (command != null) {
      $result.command.addAll(command);
    }
    if (args != null) {
      $result.args.addAll(args);
    }
    if (workingDir != null) {
      $result.workingDir = workingDir;
    }
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    if (env != null) {
      $result.env.addAll(env);
    }
    if (resources != null) {
      $result.resources = resources;
    }
    if (volumeMounts != null) {
      $result.volumeMounts.addAll(volumeMounts);
    }
    if (livenessProbe != null) {
      $result.livenessProbe = livenessProbe;
    }
    if (readinessProbe != null) {
      $result.readinessProbe = readinessProbe;
    }
    if (lifecycle != null) {
      $result.lifecycle = lifecycle;
    }
    if (terminationMessagePath != null) {
      $result.terminationMessagePath = terminationMessagePath;
    }
    if (imagePullPolicy != null) {
      $result.imagePullPolicy = imagePullPolicy;
    }
    if (securityContext != null) {
      $result.securityContext = securityContext;
    }
    if (stdin != null) {
      $result.stdin = stdin;
    }
    if (stdinOnce != null) {
      $result.stdinOnce = stdinOnce;
    }
    if (tty != null) {
      $result.tty = tty;
    }
    if (envFrom != null) {
      $result.envFrom.addAll(envFrom);
    }
    if (terminationMessagePolicy != null) {
      $result.terminationMessagePolicy = terminationMessagePolicy;
    }
    if (volumeDevices != null) {
      $result.volumeDevices.addAll(volumeDevices);
    }
    if (startupProbe != null) {
      $result.startupProbe = startupProbe;
    }
    if (resizePolicy != null) {
      $result.resizePolicy.addAll(resizePolicy);
    }
    if (restartPolicy != null) {
      $result.restartPolicy = restartPolicy;
    }
    return $result;
  }
  Container._() : super();
  factory Container.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Container.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Container', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'image')
    ..pPS(3, _omitFieldNames ? '' : 'command')
    ..pPS(4, _omitFieldNames ? '' : 'args')
    ..aOS(5, _omitFieldNames ? '' : 'workingDir', protoName: 'workingDir')
    ..pc<ContainerPort>(6, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.PM, subBuilder: ContainerPort.create)
    ..pc<EnvVar>(7, _omitFieldNames ? '' : 'env', $pb.PbFieldType.PM, subBuilder: EnvVar.create)
    ..aOM<ResourceRequirements>(8, _omitFieldNames ? '' : 'resources', subBuilder: ResourceRequirements.create)
    ..pc<VolumeMount>(9, _omitFieldNames ? '' : 'volumeMounts', $pb.PbFieldType.PM, protoName: 'volumeMounts', subBuilder: VolumeMount.create)
    ..aOM<Probe>(10, _omitFieldNames ? '' : 'livenessProbe', protoName: 'livenessProbe', subBuilder: Probe.create)
    ..aOM<Probe>(11, _omitFieldNames ? '' : 'readinessProbe', protoName: 'readinessProbe', subBuilder: Probe.create)
    ..aOM<Lifecycle>(12, _omitFieldNames ? '' : 'lifecycle', subBuilder: Lifecycle.create)
    ..aOS(13, _omitFieldNames ? '' : 'terminationMessagePath', protoName: 'terminationMessagePath')
    ..aOS(14, _omitFieldNames ? '' : 'imagePullPolicy', protoName: 'imagePullPolicy')
    ..aOM<SecurityContext>(15, _omitFieldNames ? '' : 'securityContext', protoName: 'securityContext', subBuilder: SecurityContext.create)
    ..aOB(16, _omitFieldNames ? '' : 'stdin')
    ..aOB(17, _omitFieldNames ? '' : 'stdinOnce', protoName: 'stdinOnce')
    ..aOB(18, _omitFieldNames ? '' : 'tty')
    ..pc<EnvFromSource>(19, _omitFieldNames ? '' : 'envFrom', $pb.PbFieldType.PM, protoName: 'envFrom', subBuilder: EnvFromSource.create)
    ..aOS(20, _omitFieldNames ? '' : 'terminationMessagePolicy', protoName: 'terminationMessagePolicy')
    ..pc<VolumeDevice>(21, _omitFieldNames ? '' : 'volumeDevices', $pb.PbFieldType.PM, protoName: 'volumeDevices', subBuilder: VolumeDevice.create)
    ..aOM<Probe>(22, _omitFieldNames ? '' : 'startupProbe', protoName: 'startupProbe', subBuilder: Probe.create)
    ..pc<ContainerResizePolicy>(23, _omitFieldNames ? '' : 'resizePolicy', $pb.PbFieldType.PM, protoName: 'resizePolicy', subBuilder: ContainerResizePolicy.create)
    ..aOS(24, _omitFieldNames ? '' : 'restartPolicy', protoName: 'restartPolicy')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Container clone() => Container()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Container copyWith(void Function(Container) updates) => super.copyWith((message) => updates(message as Container)) as Container;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Container create() => Container._();
  Container createEmptyInstance() => create();
  static $pb.PbList<Container> createRepeated() => $pb.PbList<Container>();
  @$core.pragma('dart2js:noInline')
  static Container getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Container>(create);
  static Container? _defaultInstance;

  /// Name of the container specified as a DNS_LABEL.
  /// Each container in a pod must have a unique name (DNS_LABEL).
  /// Cannot be updated.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Container image name.
  /// More info: https://kubernetes.io/docs/concepts/containers/images
  /// This field is optional to allow higher level config management to default or override
  /// container images in workload controllers like Deployments and StatefulSets.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get image => $_getSZ(1);
  @$pb.TagNumber(2)
  set image($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasImage() => $_has(1);
  @$pb.TagNumber(2)
  void clearImage() => clearField(2);

  /// Entrypoint array. Not executed within a shell.
  /// The container image's ENTRYPOINT is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  /// of whether the variable exists or not. Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<$core.String> get command => $_getList(2);

  /// Arguments to the entrypoint.
  /// The container image's CMD is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  /// of whether the variable exists or not. Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(4)
  $core.List<$core.String> get args => $_getList(3);

  /// Container's working directory.
  /// If not specified, the container runtime's default will be used, which
  /// might be configured in the container image.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get workingDir => $_getSZ(4);
  @$pb.TagNumber(5)
  set workingDir($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasWorkingDir() => $_has(4);
  @$pb.TagNumber(5)
  void clearWorkingDir() => clearField(5);

  /// List of ports to expose from the container. Not specifying a port here
  /// DOES NOT prevent that port from being exposed. Any port which is
  /// listening on the default "0.0.0.0" address inside a container will be
  /// accessible from the network.
  /// Modifying this array with strategic merge patch may corrupt the data.
  /// For more information See https://github.com/kubernetes/kubernetes/issues/108255.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=containerPort
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=containerPort
  /// +listMapKey=protocol
  @$pb.TagNumber(6)
  $core.List<ContainerPort> get ports => $_getList(5);

  /// List of environment variables to set in the container.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(7)
  $core.List<EnvVar> get env => $_getList(6);

  /// Compute Resources required by this container.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  /// +optional
  @$pb.TagNumber(8)
  ResourceRequirements get resources => $_getN(7);
  @$pb.TagNumber(8)
  set resources(ResourceRequirements v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasResources() => $_has(7);
  @$pb.TagNumber(8)
  void clearResources() => clearField(8);
  @$pb.TagNumber(8)
  ResourceRequirements ensureResources() => $_ensure(7);

  /// Pod volumes to mount into the container's filesystem.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=mountPath
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=mountPath
  @$pb.TagNumber(9)
  $core.List<VolumeMount> get volumeMounts => $_getList(8);

  /// Periodic probe of container liveness.
  /// Container will be restarted if the probe fails.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  @$pb.TagNumber(10)
  Probe get livenessProbe => $_getN(9);
  @$pb.TagNumber(10)
  set livenessProbe(Probe v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasLivenessProbe() => $_has(9);
  @$pb.TagNumber(10)
  void clearLivenessProbe() => clearField(10);
  @$pb.TagNumber(10)
  Probe ensureLivenessProbe() => $_ensure(9);

  /// Periodic probe of container service readiness.
  /// Container will be removed from service endpoints if the probe fails.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  @$pb.TagNumber(11)
  Probe get readinessProbe => $_getN(10);
  @$pb.TagNumber(11)
  set readinessProbe(Probe v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasReadinessProbe() => $_has(10);
  @$pb.TagNumber(11)
  void clearReadinessProbe() => clearField(11);
  @$pb.TagNumber(11)
  Probe ensureReadinessProbe() => $_ensure(10);

  /// Actions that the management system should take in response to container lifecycle events.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(12)
  Lifecycle get lifecycle => $_getN(11);
  @$pb.TagNumber(12)
  set lifecycle(Lifecycle v) { setField(12, v); }
  @$pb.TagNumber(12)
  $core.bool hasLifecycle() => $_has(11);
  @$pb.TagNumber(12)
  void clearLifecycle() => clearField(12);
  @$pb.TagNumber(12)
  Lifecycle ensureLifecycle() => $_ensure(11);

  /// Optional: Path at which the file to which the container's termination message
  /// will be written is mounted into the container's filesystem.
  /// Message written is intended to be brief final status, such as an assertion failure message.
  /// Will be truncated by the node if greater than 4096 bytes. The total message length across
  /// all containers will be limited to 12kb.
  /// Defaults to /dev/termination-log.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(13)
  $core.String get terminationMessagePath => $_getSZ(12);
  @$pb.TagNumber(13)
  set terminationMessagePath($core.String v) { $_setString(12, v); }
  @$pb.TagNumber(13)
  $core.bool hasTerminationMessagePath() => $_has(12);
  @$pb.TagNumber(13)
  void clearTerminationMessagePath() => clearField(13);

  /// Image pull policy.
  /// One of Always, Never, IfNotPresent.
  /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  /// +optional
  @$pb.TagNumber(14)
  $core.String get imagePullPolicy => $_getSZ(13);
  @$pb.TagNumber(14)
  set imagePullPolicy($core.String v) { $_setString(13, v); }
  @$pb.TagNumber(14)
  $core.bool hasImagePullPolicy() => $_has(13);
  @$pb.TagNumber(14)
  void clearImagePullPolicy() => clearField(14);

  /// SecurityContext defines the security options the container should be run with.
  /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  /// +optional
  @$pb.TagNumber(15)
  SecurityContext get securityContext => $_getN(14);
  @$pb.TagNumber(15)
  set securityContext(SecurityContext v) { setField(15, v); }
  @$pb.TagNumber(15)
  $core.bool hasSecurityContext() => $_has(14);
  @$pb.TagNumber(15)
  void clearSecurityContext() => clearField(15);
  @$pb.TagNumber(15)
  SecurityContext ensureSecurityContext() => $_ensure(14);

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this
  /// is not set, reads from stdin in the container will always result in EOF.
  /// Default is false.
  /// +optional
  @$pb.TagNumber(16)
  $core.bool get stdin => $_getBF(15);
  @$pb.TagNumber(16)
  set stdin($core.bool v) { $_setBool(15, v); }
  @$pb.TagNumber(16)
  $core.bool hasStdin() => $_has(15);
  @$pb.TagNumber(16)
  void clearStdin() => clearField(16);

  /// Whether the container runtime should close the stdin channel after it has been opened by
  /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
  /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  /// at which time stdin is closed and remains closed until the container is restarted. If this
  /// flag is false, a container processes that reads from stdin will never receive an EOF.
  /// Default is false
  /// +optional
  @$pb.TagNumber(17)
  $core.bool get stdinOnce => $_getBF(16);
  @$pb.TagNumber(17)
  set stdinOnce($core.bool v) { $_setBool(16, v); }
  @$pb.TagNumber(17)
  $core.bool hasStdinOnce() => $_has(16);
  @$pb.TagNumber(17)
  void clearStdinOnce() => clearField(17);

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  /// Default is false.
  /// +optional
  @$pb.TagNumber(18)
  $core.bool get tty => $_getBF(17);
  @$pb.TagNumber(18)
  set tty($core.bool v) { $_setBool(17, v); }
  @$pb.TagNumber(18)
  $core.bool hasTty() => $_has(17);
  @$pb.TagNumber(18)
  void clearTty() => clearField(18);

  /// List of sources to populate environment variables in the container.
  /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  /// will be reported as an event when the container is starting. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence.
  /// Values defined by an Env with a duplicate key will take precedence.
  /// Cannot be updated.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(19)
  $core.List<EnvFromSource> get envFrom => $_getList(18);

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination
  /// message file is empty and the container exited with an error.
  /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  /// Defaults to File.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(20)
  $core.String get terminationMessagePolicy => $_getSZ(19);
  @$pb.TagNumber(20)
  set terminationMessagePolicy($core.String v) { $_setString(19, v); }
  @$pb.TagNumber(20)
  $core.bool hasTerminationMessagePolicy() => $_has(19);
  @$pb.TagNumber(20)
  void clearTerminationMessagePolicy() => clearField(20);

  /// volumeDevices is the list of block devices to be used by the container.
  /// +patchMergeKey=devicePath
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=devicePath
  /// +optional
  @$pb.TagNumber(21)
  $core.List<VolumeDevice> get volumeDevices => $_getList(20);

  /// StartupProbe indicates that the Pod has successfully initialized.
  /// If specified, no other probes are executed until this completes successfully.
  /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
  /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
  /// when it might take a long time to load data or warm a cache, than during steady-state operation.
  /// This cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  @$pb.TagNumber(22)
  Probe get startupProbe => $_getN(21);
  @$pb.TagNumber(22)
  set startupProbe(Probe v) { setField(22, v); }
  @$pb.TagNumber(22)
  $core.bool hasStartupProbe() => $_has(21);
  @$pb.TagNumber(22)
  void clearStartupProbe() => clearField(22);
  @$pb.TagNumber(22)
  Probe ensureStartupProbe() => $_ensure(21);

  /// Resources resize policy for the container.
  /// +featureGate=InPlacePodVerticalScaling
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(23)
  $core.List<ContainerResizePolicy> get resizePolicy => $_getList(22);

  /// RestartPolicy defines the restart behavior of individual containers in a pod.
  /// This field may only be set for init containers, and the only allowed value is "Always".
  /// For non-init containers or when this field is not specified,
  /// the restart behavior is defined by the Pod's restart policy and the container type.
  /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
  /// this init container will be continually restarted on
  /// exit until all regular containers have terminated. Once all regular
  /// containers have completed, all init containers with restartPolicy "Always"
  /// will be shut down. This lifecycle differs from normal init containers and
  /// is often referred to as a "sidecar" container. Although this init
  /// container still starts in the init container sequence, it does not wait
  /// for the container to complete before proceeding to the next init
  /// container. Instead, the next init container starts immediately after this
  /// init container is started, or after any startupProbe has successfully
  /// completed.
  /// +featureGate=SidecarContainers
  /// +optional
  @$pb.TagNumber(24)
  $core.String get restartPolicy => $_getSZ(23);
  @$pb.TagNumber(24)
  set restartPolicy($core.String v) { $_setString(23, v); }
  @$pb.TagNumber(24)
  $core.bool hasRestartPolicy() => $_has(23);
  @$pb.TagNumber(24)
  void clearRestartPolicy() => clearField(24);
}

/// Describe a container image
class ContainerImage extends $pb.GeneratedMessage {
  factory ContainerImage({
    $core.Iterable<$core.String>? names,
    $fixnum.Int64? sizeBytes,
  }) {
    final $result = create();
    if (names != null) {
      $result.names.addAll(names);
    }
    if (sizeBytes != null) {
      $result.sizeBytes = sizeBytes;
    }
    return $result;
  }
  ContainerImage._() : super();
  factory ContainerImage.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerImage.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerImage', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'names')
    ..aInt64(2, _omitFieldNames ? '' : 'sizeBytes', protoName: 'sizeBytes')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerImage clone() => ContainerImage()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerImage copyWith(void Function(ContainerImage) updates) => super.copyWith((message) => updates(message as ContainerImage)) as ContainerImage;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerImage create() => ContainerImage._();
  ContainerImage createEmptyInstance() => create();
  static $pb.PbList<ContainerImage> createRepeated() => $pb.PbList<ContainerImage>();
  @$core.pragma('dart2js:noInline')
  static ContainerImage getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerImage>(create);
  static ContainerImage? _defaultInstance;

  /// Names by which this image is known.
  /// e.g. ["kubernetes.example/hyperkube:v1.0.7", "cloud-vendor.registry.example/cloud-vendor/hyperkube:v1.0.7"]
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get names => $_getList(0);

  /// The size of the image in bytes.
  /// +optional
  @$pb.TagNumber(2)
  $fixnum.Int64 get sizeBytes => $_getI64(1);
  @$pb.TagNumber(2)
  set sizeBytes($fixnum.Int64 v) { $_setInt64(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSizeBytes() => $_has(1);
  @$pb.TagNumber(2)
  void clearSizeBytes() => clearField(2);
}

/// ContainerPort represents a network port in a single container.
class ContainerPort extends $pb.GeneratedMessage {
  factory ContainerPort({
    $core.String? name,
    $core.int? hostPort,
    $core.int? containerPort,
    $core.String? protocol,
    $core.String? hostIP,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (hostPort != null) {
      $result.hostPort = hostPort;
    }
    if (containerPort != null) {
      $result.containerPort = containerPort;
    }
    if (protocol != null) {
      $result.protocol = protocol;
    }
    if (hostIP != null) {
      $result.hostIP = hostIP;
    }
    return $result;
  }
  ContainerPort._() : super();
  factory ContainerPort.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerPort.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerPort', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..a<$core.int>(2, _omitFieldNames ? '' : 'hostPort', $pb.PbFieldType.O3, protoName: 'hostPort')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'containerPort', $pb.PbFieldType.O3, protoName: 'containerPort')
    ..aOS(4, _omitFieldNames ? '' : 'protocol')
    ..aOS(5, _omitFieldNames ? '' : 'hostIP', protoName: 'hostIP')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerPort clone() => ContainerPort()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerPort copyWith(void Function(ContainerPort) updates) => super.copyWith((message) => updates(message as ContainerPort)) as ContainerPort;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerPort create() => ContainerPort._();
  ContainerPort createEmptyInstance() => create();
  static $pb.PbList<ContainerPort> createRepeated() => $pb.PbList<ContainerPort>();
  @$core.pragma('dart2js:noInline')
  static ContainerPort getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerPort>(create);
  static ContainerPort? _defaultInstance;

  /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  /// named port in a pod must have a unique name. Name for the port that can be
  /// referred to by services.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Number of port to expose on the host.
  /// If specified, this must be a valid port number, 0 < x < 65536.
  /// If HostNetwork is specified, this must match ContainerPort.
  /// Most containers do not need this.
  /// +optional
  @$pb.TagNumber(2)
  $core.int get hostPort => $_getIZ(1);
  @$pb.TagNumber(2)
  set hostPort($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasHostPort() => $_has(1);
  @$pb.TagNumber(2)
  void clearHostPort() => clearField(2);

  /// Number of port to expose on the pod's IP address.
  /// This must be a valid port number, 0 < x < 65536.
  @$pb.TagNumber(3)
  $core.int get containerPort => $_getIZ(2);
  @$pb.TagNumber(3)
  set containerPort($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasContainerPort() => $_has(2);
  @$pb.TagNumber(3)
  void clearContainerPort() => clearField(3);

  /// Protocol for port. Must be UDP, TCP, or SCTP.
  /// Defaults to "TCP".
  /// +optional
  /// +default="TCP"
  @$pb.TagNumber(4)
  $core.String get protocol => $_getSZ(3);
  @$pb.TagNumber(4)
  set protocol($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasProtocol() => $_has(3);
  @$pb.TagNumber(4)
  void clearProtocol() => clearField(4);

  /// What host IP to bind the external port to.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get hostIP => $_getSZ(4);
  @$pb.TagNumber(5)
  set hostIP($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasHostIP() => $_has(4);
  @$pb.TagNumber(5)
  void clearHostIP() => clearField(5);
}

/// ContainerResizePolicy represents resource resize policy for the container.
class ContainerResizePolicy extends $pb.GeneratedMessage {
  factory ContainerResizePolicy({
    $core.String? resourceName,
    $core.String? restartPolicy,
  }) {
    final $result = create();
    if (resourceName != null) {
      $result.resourceName = resourceName;
    }
    if (restartPolicy != null) {
      $result.restartPolicy = restartPolicy;
    }
    return $result;
  }
  ContainerResizePolicy._() : super();
  factory ContainerResizePolicy.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerResizePolicy.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerResizePolicy', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'resourceName', protoName: 'resourceName')
    ..aOS(2, _omitFieldNames ? '' : 'restartPolicy', protoName: 'restartPolicy')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerResizePolicy clone() => ContainerResizePolicy()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerResizePolicy copyWith(void Function(ContainerResizePolicy) updates) => super.copyWith((message) => updates(message as ContainerResizePolicy)) as ContainerResizePolicy;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerResizePolicy create() => ContainerResizePolicy._();
  ContainerResizePolicy createEmptyInstance() => create();
  static $pb.PbList<ContainerResizePolicy> createRepeated() => $pb.PbList<ContainerResizePolicy>();
  @$core.pragma('dart2js:noInline')
  static ContainerResizePolicy getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerResizePolicy>(create);
  static ContainerResizePolicy? _defaultInstance;

  /// Name of the resource to which this resource resize policy applies.
  /// Supported values: cpu, memory.
  @$pb.TagNumber(1)
  $core.String get resourceName => $_getSZ(0);
  @$pb.TagNumber(1)
  set resourceName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasResourceName() => $_has(0);
  @$pb.TagNumber(1)
  void clearResourceName() => clearField(1);

  /// Restart policy to apply when specified resource is resized.
  /// If not specified, it defaults to NotRequired.
  @$pb.TagNumber(2)
  $core.String get restartPolicy => $_getSZ(1);
  @$pb.TagNumber(2)
  set restartPolicy($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasRestartPolicy() => $_has(1);
  @$pb.TagNumber(2)
  void clearRestartPolicy() => clearField(2);
}

/// ContainerState holds a possible state of container.
/// Only one of its members may be specified.
/// If none of them is specified, the default one is ContainerStateWaiting.
class ContainerState extends $pb.GeneratedMessage {
  factory ContainerState({
    ContainerStateWaiting? waiting,
    ContainerStateRunning? running,
    ContainerStateTerminated? terminated,
  }) {
    final $result = create();
    if (waiting != null) {
      $result.waiting = waiting;
    }
    if (running != null) {
      $result.running = running;
    }
    if (terminated != null) {
      $result.terminated = terminated;
    }
    return $result;
  }
  ContainerState._() : super();
  factory ContainerState.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerState.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerState', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ContainerStateWaiting>(1, _omitFieldNames ? '' : 'waiting', subBuilder: ContainerStateWaiting.create)
    ..aOM<ContainerStateRunning>(2, _omitFieldNames ? '' : 'running', subBuilder: ContainerStateRunning.create)
    ..aOM<ContainerStateTerminated>(3, _omitFieldNames ? '' : 'terminated', subBuilder: ContainerStateTerminated.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerState clone() => ContainerState()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerState copyWith(void Function(ContainerState) updates) => super.copyWith((message) => updates(message as ContainerState)) as ContainerState;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerState create() => ContainerState._();
  ContainerState createEmptyInstance() => create();
  static $pb.PbList<ContainerState> createRepeated() => $pb.PbList<ContainerState>();
  @$core.pragma('dart2js:noInline')
  static ContainerState getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerState>(create);
  static ContainerState? _defaultInstance;

  /// Details about a waiting container
  /// +optional
  @$pb.TagNumber(1)
  ContainerStateWaiting get waiting => $_getN(0);
  @$pb.TagNumber(1)
  set waiting(ContainerStateWaiting v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasWaiting() => $_has(0);
  @$pb.TagNumber(1)
  void clearWaiting() => clearField(1);
  @$pb.TagNumber(1)
  ContainerStateWaiting ensureWaiting() => $_ensure(0);

  /// Details about a running container
  /// +optional
  @$pb.TagNumber(2)
  ContainerStateRunning get running => $_getN(1);
  @$pb.TagNumber(2)
  set running(ContainerStateRunning v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasRunning() => $_has(1);
  @$pb.TagNumber(2)
  void clearRunning() => clearField(2);
  @$pb.TagNumber(2)
  ContainerStateRunning ensureRunning() => $_ensure(1);

  /// Details about a terminated container
  /// +optional
  @$pb.TagNumber(3)
  ContainerStateTerminated get terminated => $_getN(2);
  @$pb.TagNumber(3)
  set terminated(ContainerStateTerminated v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasTerminated() => $_has(2);
  @$pb.TagNumber(3)
  void clearTerminated() => clearField(3);
  @$pb.TagNumber(3)
  ContainerStateTerminated ensureTerminated() => $_ensure(2);
}

/// ContainerStateRunning is a running state of a container.
class ContainerStateRunning extends $pb.GeneratedMessage {
  factory ContainerStateRunning({
    $0.Time? startedAt,
  }) {
    final $result = create();
    if (startedAt != null) {
      $result.startedAt = startedAt;
    }
    return $result;
  }
  ContainerStateRunning._() : super();
  factory ContainerStateRunning.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerStateRunning.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerStateRunning', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.Time>(1, _omitFieldNames ? '' : 'startedAt', protoName: 'startedAt', subBuilder: $0.Time.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerStateRunning clone() => ContainerStateRunning()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerStateRunning copyWith(void Function(ContainerStateRunning) updates) => super.copyWith((message) => updates(message as ContainerStateRunning)) as ContainerStateRunning;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerStateRunning create() => ContainerStateRunning._();
  ContainerStateRunning createEmptyInstance() => create();
  static $pb.PbList<ContainerStateRunning> createRepeated() => $pb.PbList<ContainerStateRunning>();
  @$core.pragma('dart2js:noInline')
  static ContainerStateRunning getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerStateRunning>(create);
  static ContainerStateRunning? _defaultInstance;

  /// Time at which the container was last (re-)started
  /// +optional
  @$pb.TagNumber(1)
  $0.Time get startedAt => $_getN(0);
  @$pb.TagNumber(1)
  set startedAt($0.Time v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasStartedAt() => $_has(0);
  @$pb.TagNumber(1)
  void clearStartedAt() => clearField(1);
  @$pb.TagNumber(1)
  $0.Time ensureStartedAt() => $_ensure(0);
}

/// ContainerStateTerminated is a terminated state of a container.
class ContainerStateTerminated extends $pb.GeneratedMessage {
  factory ContainerStateTerminated({
    $core.int? exitCode,
    $core.int? signal,
    $core.String? reason,
    $core.String? message,
    $0.Time? startedAt,
    $0.Time? finishedAt,
    $core.String? containerID,
  }) {
    final $result = create();
    if (exitCode != null) {
      $result.exitCode = exitCode;
    }
    if (signal != null) {
      $result.signal = signal;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    if (startedAt != null) {
      $result.startedAt = startedAt;
    }
    if (finishedAt != null) {
      $result.finishedAt = finishedAt;
    }
    if (containerID != null) {
      $result.containerID = containerID;
    }
    return $result;
  }
  ContainerStateTerminated._() : super();
  factory ContainerStateTerminated.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerStateTerminated.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerStateTerminated', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'exitCode', $pb.PbFieldType.O3, protoName: 'exitCode')
    ..a<$core.int>(2, _omitFieldNames ? '' : 'signal', $pb.PbFieldType.O3)
    ..aOS(3, _omitFieldNames ? '' : 'reason')
    ..aOS(4, _omitFieldNames ? '' : 'message')
    ..aOM<$0.Time>(5, _omitFieldNames ? '' : 'startedAt', protoName: 'startedAt', subBuilder: $0.Time.create)
    ..aOM<$0.Time>(6, _omitFieldNames ? '' : 'finishedAt', protoName: 'finishedAt', subBuilder: $0.Time.create)
    ..aOS(7, _omitFieldNames ? '' : 'containerID', protoName: 'containerID')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerStateTerminated clone() => ContainerStateTerminated()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerStateTerminated copyWith(void Function(ContainerStateTerminated) updates) => super.copyWith((message) => updates(message as ContainerStateTerminated)) as ContainerStateTerminated;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerStateTerminated create() => ContainerStateTerminated._();
  ContainerStateTerminated createEmptyInstance() => create();
  static $pb.PbList<ContainerStateTerminated> createRepeated() => $pb.PbList<ContainerStateTerminated>();
  @$core.pragma('dart2js:noInline')
  static ContainerStateTerminated getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerStateTerminated>(create);
  static ContainerStateTerminated? _defaultInstance;

  /// Exit status from the last termination of the container
  @$pb.TagNumber(1)
  $core.int get exitCode => $_getIZ(0);
  @$pb.TagNumber(1)
  set exitCode($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasExitCode() => $_has(0);
  @$pb.TagNumber(1)
  void clearExitCode() => clearField(1);

  /// Signal from the last termination of the container
  /// +optional
  @$pb.TagNumber(2)
  $core.int get signal => $_getIZ(1);
  @$pb.TagNumber(2)
  set signal($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSignal() => $_has(1);
  @$pb.TagNumber(2)
  void clearSignal() => clearField(2);

  /// (brief) reason from the last termination of the container
  /// +optional
  @$pb.TagNumber(3)
  $core.String get reason => $_getSZ(2);
  @$pb.TagNumber(3)
  set reason($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReason() => $_has(2);
  @$pb.TagNumber(3)
  void clearReason() => clearField(3);

  /// Message regarding the last termination of the container
  /// +optional
  @$pb.TagNumber(4)
  $core.String get message => $_getSZ(3);
  @$pb.TagNumber(4)
  set message($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasMessage() => $_has(3);
  @$pb.TagNumber(4)
  void clearMessage() => clearField(4);

  /// Time at which previous execution of the container started
  /// +optional
  @$pb.TagNumber(5)
  $0.Time get startedAt => $_getN(4);
  @$pb.TagNumber(5)
  set startedAt($0.Time v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasStartedAt() => $_has(4);
  @$pb.TagNumber(5)
  void clearStartedAt() => clearField(5);
  @$pb.TagNumber(5)
  $0.Time ensureStartedAt() => $_ensure(4);

  /// Time at which the container last terminated
  /// +optional
  @$pb.TagNumber(6)
  $0.Time get finishedAt => $_getN(5);
  @$pb.TagNumber(6)
  set finishedAt($0.Time v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasFinishedAt() => $_has(5);
  @$pb.TagNumber(6)
  void clearFinishedAt() => clearField(6);
  @$pb.TagNumber(6)
  $0.Time ensureFinishedAt() => $_ensure(5);

  /// Container's ID in the format '<type>://<container_id>'
  /// +optional
  @$pb.TagNumber(7)
  $core.String get containerID => $_getSZ(6);
  @$pb.TagNumber(7)
  set containerID($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasContainerID() => $_has(6);
  @$pb.TagNumber(7)
  void clearContainerID() => clearField(7);
}

/// ContainerStateWaiting is a waiting state of a container.
class ContainerStateWaiting extends $pb.GeneratedMessage {
  factory ContainerStateWaiting({
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  ContainerStateWaiting._() : super();
  factory ContainerStateWaiting.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerStateWaiting.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerStateWaiting', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'reason')
    ..aOS(2, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerStateWaiting clone() => ContainerStateWaiting()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerStateWaiting copyWith(void Function(ContainerStateWaiting) updates) => super.copyWith((message) => updates(message as ContainerStateWaiting)) as ContainerStateWaiting;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerStateWaiting create() => ContainerStateWaiting._();
  ContainerStateWaiting createEmptyInstance() => create();
  static $pb.PbList<ContainerStateWaiting> createRepeated() => $pb.PbList<ContainerStateWaiting>();
  @$core.pragma('dart2js:noInline')
  static ContainerStateWaiting getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerStateWaiting>(create);
  static ContainerStateWaiting? _defaultInstance;

  /// (brief) reason the container is not yet running.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get reason => $_getSZ(0);
  @$pb.TagNumber(1)
  set reason($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasReason() => $_has(0);
  @$pb.TagNumber(1)
  void clearReason() => clearField(1);

  /// Message regarding why the container is not yet running.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get message => $_getSZ(1);
  @$pb.TagNumber(2)
  set message($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasMessage() => $_has(1);
  @$pb.TagNumber(2)
  void clearMessage() => clearField(2);
}

/// ContainerStatus contains details for the current status of this container.
class ContainerStatus extends $pb.GeneratedMessage {
  factory ContainerStatus({
    $core.String? name,
    ContainerState? state,
    ContainerState? lastState,
    $core.bool? ready,
    $core.int? restartCount,
    $core.String? image,
    $core.String? imageID,
    $core.String? containerID,
    $core.bool? started,
    $core.Map<$core.String, $1.Quantity>? allocatedResources,
    ResourceRequirements? resources,
    $core.Iterable<VolumeMountStatus>? volumeMounts,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (state != null) {
      $result.state = state;
    }
    if (lastState != null) {
      $result.lastState = lastState;
    }
    if (ready != null) {
      $result.ready = ready;
    }
    if (restartCount != null) {
      $result.restartCount = restartCount;
    }
    if (image != null) {
      $result.image = image;
    }
    if (imageID != null) {
      $result.imageID = imageID;
    }
    if (containerID != null) {
      $result.containerID = containerID;
    }
    if (started != null) {
      $result.started = started;
    }
    if (allocatedResources != null) {
      $result.allocatedResources.addAll(allocatedResources);
    }
    if (resources != null) {
      $result.resources = resources;
    }
    if (volumeMounts != null) {
      $result.volumeMounts.addAll(volumeMounts);
    }
    return $result;
  }
  ContainerStatus._() : super();
  factory ContainerStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ContainerStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ContainerStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOM<ContainerState>(2, _omitFieldNames ? '' : 'state', subBuilder: ContainerState.create)
    ..aOM<ContainerState>(3, _omitFieldNames ? '' : 'lastState', protoName: 'lastState', subBuilder: ContainerState.create)
    ..aOB(4, _omitFieldNames ? '' : 'ready')
    ..a<$core.int>(5, _omitFieldNames ? '' : 'restartCount', $pb.PbFieldType.O3, protoName: 'restartCount')
    ..aOS(6, _omitFieldNames ? '' : 'image')
    ..aOS(7, _omitFieldNames ? '' : 'imageID', protoName: 'imageID')
    ..aOS(8, _omitFieldNames ? '' : 'containerID', protoName: 'containerID')
    ..aOB(9, _omitFieldNames ? '' : 'started')
    ..m<$core.String, $1.Quantity>(10, _omitFieldNames ? '' : 'allocatedResources', protoName: 'allocatedResources', entryClassName: 'ContainerStatus.AllocatedResourcesEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..aOM<ResourceRequirements>(11, _omitFieldNames ? '' : 'resources', subBuilder: ResourceRequirements.create)
    ..pc<VolumeMountStatus>(12, _omitFieldNames ? '' : 'volumeMounts', $pb.PbFieldType.PM, protoName: 'volumeMounts', subBuilder: VolumeMountStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ContainerStatus clone() => ContainerStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ContainerStatus copyWith(void Function(ContainerStatus) updates) => super.copyWith((message) => updates(message as ContainerStatus)) as ContainerStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ContainerStatus create() => ContainerStatus._();
  ContainerStatus createEmptyInstance() => create();
  static $pb.PbList<ContainerStatus> createRepeated() => $pb.PbList<ContainerStatus>();
  @$core.pragma('dart2js:noInline')
  static ContainerStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ContainerStatus>(create);
  static ContainerStatus? _defaultInstance;

  /// Name is a DNS_LABEL representing the unique name of the container.
  /// Each container in a pod must have a unique name across all container types.
  /// Cannot be updated.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// State holds details about the container's current condition.
  /// +optional
  @$pb.TagNumber(2)
  ContainerState get state => $_getN(1);
  @$pb.TagNumber(2)
  set state(ContainerState v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasState() => $_has(1);
  @$pb.TagNumber(2)
  void clearState() => clearField(2);
  @$pb.TagNumber(2)
  ContainerState ensureState() => $_ensure(1);

  /// LastTerminationState holds the last termination state of the container to
  /// help debug container crashes and restarts. This field is not
  /// populated if the container is still running and RestartCount is 0.
  /// +optional
  @$pb.TagNumber(3)
  ContainerState get lastState => $_getN(2);
  @$pb.TagNumber(3)
  set lastState(ContainerState v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastState() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastState() => clearField(3);
  @$pb.TagNumber(3)
  ContainerState ensureLastState() => $_ensure(2);

  ///  Ready specifies whether the container is currently passing its readiness check.
  ///  The value will change as readiness probes keep executing. If no readiness
  ///  probes are specified, this field defaults to true once the container is
  ///  fully started (see Started field).
  ///
  ///  The value is typically used to determine whether a container is ready to
  ///  accept traffic.
  @$pb.TagNumber(4)
  $core.bool get ready => $_getBF(3);
  @$pb.TagNumber(4)
  set ready($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReady() => $_has(3);
  @$pb.TagNumber(4)
  void clearReady() => clearField(4);

  /// RestartCount holds the number of times the container has been restarted.
  /// Kubelet makes an effort to always increment the value, but there
  /// are cases when the state may be lost due to node restarts and then the value
  /// may be reset to 0. The value is never negative.
  @$pb.TagNumber(5)
  $core.int get restartCount => $_getIZ(4);
  @$pb.TagNumber(5)
  set restartCount($core.int v) { $_setSignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasRestartCount() => $_has(4);
  @$pb.TagNumber(5)
  void clearRestartCount() => clearField(5);

  /// Image is the name of container image that the container is running.
  /// The container image may not match the image used in the PodSpec,
  /// as it may have been resolved by the runtime.
  /// More info: https://kubernetes.io/docs/concepts/containers/images.
  @$pb.TagNumber(6)
  $core.String get image => $_getSZ(5);
  @$pb.TagNumber(6)
  set image($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasImage() => $_has(5);
  @$pb.TagNumber(6)
  void clearImage() => clearField(6);

  /// ImageID is the image ID of the container's image. The image ID may not
  /// match the image ID of the image used in the PodSpec, as it may have been
  /// resolved by the runtime.
  @$pb.TagNumber(7)
  $core.String get imageID => $_getSZ(6);
  @$pb.TagNumber(7)
  set imageID($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasImageID() => $_has(6);
  @$pb.TagNumber(7)
  void clearImageID() => clearField(7);

  /// ContainerID is the ID of the container in the format '<type>://<container_id>'.
  /// Where type is a container runtime identifier, returned from Version call of CRI API
  /// (for example "containerd").
  /// +optional
  @$pb.TagNumber(8)
  $core.String get containerID => $_getSZ(7);
  @$pb.TagNumber(8)
  set containerID($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasContainerID() => $_has(7);
  @$pb.TagNumber(8)
  void clearContainerID() => clearField(8);

  /// Started indicates whether the container has finished its postStart lifecycle hook
  /// and passed its startup probe.
  /// Initialized as false, becomes true after startupProbe is considered
  /// successful. Resets to false when the container is restarted, or if kubelet
  /// loses state temporarily. In both cases, startup probes will run again.
  /// Is always true when no startupProbe is defined and container is running and
  /// has passed the postStart lifecycle hook. The null value must be treated the
  /// same as false.
  /// +optional
  @$pb.TagNumber(9)
  $core.bool get started => $_getBF(8);
  @$pb.TagNumber(9)
  set started($core.bool v) { $_setBool(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasStarted() => $_has(8);
  @$pb.TagNumber(9)
  void clearStarted() => clearField(9);

  /// AllocatedResources represents the compute resources allocated for this container by the
  /// node. Kubelet sets this value to Container.Resources.Requests upon successful pod admission
  /// and after successfully admitting desired pod resize.
  /// +featureGate=InPlacePodVerticalScaling
  /// +optional
  @$pb.TagNumber(10)
  $core.Map<$core.String, $1.Quantity> get allocatedResources => $_getMap(9);

  /// Resources represents the compute resource requests and limits that have been successfully
  /// enacted on the running container after it has been started or has been successfully resized.
  /// +featureGate=InPlacePodVerticalScaling
  /// +optional
  @$pb.TagNumber(11)
  ResourceRequirements get resources => $_getN(10);
  @$pb.TagNumber(11)
  set resources(ResourceRequirements v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasResources() => $_has(10);
  @$pb.TagNumber(11)
  void clearResources() => clearField(11);
  @$pb.TagNumber(11)
  ResourceRequirements ensureResources() => $_ensure(10);

  /// Status of volume mounts.
  /// +optional
  /// +patchMergeKey=mountPath
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=mountPath
  /// +featureGate=RecursiveReadOnlyMounts
  @$pb.TagNumber(12)
  $core.List<VolumeMountStatus> get volumeMounts => $_getList(11);
}

/// DaemonEndpoint contains information about a single Daemon endpoint.
class DaemonEndpoint extends $pb.GeneratedMessage {
  factory DaemonEndpoint({
    $core.int? port,
  }) {
    final $result = create();
    if (port != null) {
      $result.port = port;
    }
    return $result;
  }
  DaemonEndpoint._() : super();
  factory DaemonEndpoint.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory DaemonEndpoint.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'DaemonEndpoint', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'Port', $pb.PbFieldType.O3, protoName: 'Port')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  DaemonEndpoint clone() => DaemonEndpoint()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  DaemonEndpoint copyWith(void Function(DaemonEndpoint) updates) => super.copyWith((message) => updates(message as DaemonEndpoint)) as DaemonEndpoint;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static DaemonEndpoint create() => DaemonEndpoint._();
  DaemonEndpoint createEmptyInstance() => create();
  static $pb.PbList<DaemonEndpoint> createRepeated() => $pb.PbList<DaemonEndpoint>();
  @$core.pragma('dart2js:noInline')
  static DaemonEndpoint getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<DaemonEndpoint>(create);
  static DaemonEndpoint? _defaultInstance;

  /// Port number of the given endpoint.
  @$pb.TagNumber(1)
  $core.int get port => $_getIZ(0);
  @$pb.TagNumber(1)
  set port($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPort() => $_has(0);
  @$pb.TagNumber(1)
  void clearPort() => clearField(1);
}

/// Represents downward API info for projecting into a projected volume.
/// Note that this is identical to a downwardAPI volume source without the default
/// mode.
class DownwardAPIProjection extends $pb.GeneratedMessage {
  factory DownwardAPIProjection({
    $core.Iterable<DownwardAPIVolumeFile>? items,
  }) {
    final $result = create();
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  DownwardAPIProjection._() : super();
  factory DownwardAPIProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory DownwardAPIProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'DownwardAPIProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<DownwardAPIVolumeFile>(1, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: DownwardAPIVolumeFile.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  DownwardAPIProjection clone() => DownwardAPIProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  DownwardAPIProjection copyWith(void Function(DownwardAPIProjection) updates) => super.copyWith((message) => updates(message as DownwardAPIProjection)) as DownwardAPIProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static DownwardAPIProjection create() => DownwardAPIProjection._();
  DownwardAPIProjection createEmptyInstance() => create();
  static $pb.PbList<DownwardAPIProjection> createRepeated() => $pb.PbList<DownwardAPIProjection>();
  @$core.pragma('dart2js:noInline')
  static DownwardAPIProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<DownwardAPIProjection>(create);
  static DownwardAPIProjection? _defaultInstance;

  /// Items is a list of DownwardAPIVolume file
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<DownwardAPIVolumeFile> get items => $_getList(0);
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
class DownwardAPIVolumeFile extends $pb.GeneratedMessage {
  factory DownwardAPIVolumeFile({
    $core.String? path,
    ObjectFieldSelector? fieldRef,
    ResourceFieldSelector? resourceFieldRef,
    $core.int? mode,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    if (fieldRef != null) {
      $result.fieldRef = fieldRef;
    }
    if (resourceFieldRef != null) {
      $result.resourceFieldRef = resourceFieldRef;
    }
    if (mode != null) {
      $result.mode = mode;
    }
    return $result;
  }
  DownwardAPIVolumeFile._() : super();
  factory DownwardAPIVolumeFile.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory DownwardAPIVolumeFile.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'DownwardAPIVolumeFile', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..aOM<ObjectFieldSelector>(2, _omitFieldNames ? '' : 'fieldRef', protoName: 'fieldRef', subBuilder: ObjectFieldSelector.create)
    ..aOM<ResourceFieldSelector>(3, _omitFieldNames ? '' : 'resourceFieldRef', protoName: 'resourceFieldRef', subBuilder: ResourceFieldSelector.create)
    ..a<$core.int>(4, _omitFieldNames ? '' : 'mode', $pb.PbFieldType.O3)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  DownwardAPIVolumeFile clone() => DownwardAPIVolumeFile()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  DownwardAPIVolumeFile copyWith(void Function(DownwardAPIVolumeFile) updates) => super.copyWith((message) => updates(message as DownwardAPIVolumeFile)) as DownwardAPIVolumeFile;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static DownwardAPIVolumeFile create() => DownwardAPIVolumeFile._();
  DownwardAPIVolumeFile createEmptyInstance() => create();
  static $pb.PbList<DownwardAPIVolumeFile> createRepeated() => $pb.PbList<DownwardAPIVolumeFile>();
  @$core.pragma('dart2js:noInline')
  static DownwardAPIVolumeFile getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<DownwardAPIVolumeFile>(create);
  static DownwardAPIVolumeFile? _defaultInstance;

  /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);

  /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
  /// +optional
  @$pb.TagNumber(2)
  ObjectFieldSelector get fieldRef => $_getN(1);
  @$pb.TagNumber(2)
  set fieldRef(ObjectFieldSelector v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasFieldRef() => $_has(1);
  @$pb.TagNumber(2)
  void clearFieldRef() => clearField(2);
  @$pb.TagNumber(2)
  ObjectFieldSelector ensureFieldRef() => $_ensure(1);

  /// Selects a resource of the container: only resources limits and requests
  /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  /// +optional
  @$pb.TagNumber(3)
  ResourceFieldSelector get resourceFieldRef => $_getN(2);
  @$pb.TagNumber(3)
  set resourceFieldRef(ResourceFieldSelector v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasResourceFieldRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearResourceFieldRef() => clearField(3);
  @$pb.TagNumber(3)
  ResourceFieldSelector ensureResourceFieldRef() => $_ensure(2);

  /// Optional: mode bits used to set permissions on this file, must be an octal value
  /// between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  /// If not specified, the volume defaultMode will be used.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(4)
  $core.int get mode => $_getIZ(3);
  @$pb.TagNumber(4)
  set mode($core.int v) { $_setSignedInt32(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasMode() => $_has(3);
  @$pb.TagNumber(4)
  void clearMode() => clearField(4);
}

/// DownwardAPIVolumeSource represents a volume containing downward API info.
/// Downward API volumes support ownership management and SELinux relabeling.
class DownwardAPIVolumeSource extends $pb.GeneratedMessage {
  factory DownwardAPIVolumeSource({
    $core.Iterable<DownwardAPIVolumeFile>? items,
    $core.int? defaultMode,
  }) {
    final $result = create();
    if (items != null) {
      $result.items.addAll(items);
    }
    if (defaultMode != null) {
      $result.defaultMode = defaultMode;
    }
    return $result;
  }
  DownwardAPIVolumeSource._() : super();
  factory DownwardAPIVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory DownwardAPIVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'DownwardAPIVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<DownwardAPIVolumeFile>(1, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: DownwardAPIVolumeFile.create)
    ..a<$core.int>(2, _omitFieldNames ? '' : 'defaultMode', $pb.PbFieldType.O3, protoName: 'defaultMode')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  DownwardAPIVolumeSource clone() => DownwardAPIVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  DownwardAPIVolumeSource copyWith(void Function(DownwardAPIVolumeSource) updates) => super.copyWith((message) => updates(message as DownwardAPIVolumeSource)) as DownwardAPIVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static DownwardAPIVolumeSource create() => DownwardAPIVolumeSource._();
  DownwardAPIVolumeSource createEmptyInstance() => create();
  static $pb.PbList<DownwardAPIVolumeSource> createRepeated() => $pb.PbList<DownwardAPIVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static DownwardAPIVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<DownwardAPIVolumeSource>(create);
  static DownwardAPIVolumeSource? _defaultInstance;

  /// Items is a list of downward API volume file
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<DownwardAPIVolumeFile> get items => $_getList(0);

  /// Optional: mode bits to use on created files by default. Must be a
  /// Optional: mode bits used to set permissions on created files by default.
  /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  /// Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(2)
  $core.int get defaultMode => $_getIZ(1);
  @$pb.TagNumber(2)
  set defaultMode($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDefaultMode() => $_has(1);
  @$pb.TagNumber(2)
  void clearDefaultMode() => clearField(2);
}

/// Represents an empty directory for a pod.
/// Empty directory volumes support ownership management and SELinux relabeling.
class EmptyDirVolumeSource extends $pb.GeneratedMessage {
  factory EmptyDirVolumeSource({
    $core.String? medium,
    $1.Quantity? sizeLimit,
  }) {
    final $result = create();
    if (medium != null) {
      $result.medium = medium;
    }
    if (sizeLimit != null) {
      $result.sizeLimit = sizeLimit;
    }
    return $result;
  }
  EmptyDirVolumeSource._() : super();
  factory EmptyDirVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EmptyDirVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EmptyDirVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'medium')
    ..aOM<$1.Quantity>(2, _omitFieldNames ? '' : 'sizeLimit', protoName: 'sizeLimit', subBuilder: $1.Quantity.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EmptyDirVolumeSource clone() => EmptyDirVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EmptyDirVolumeSource copyWith(void Function(EmptyDirVolumeSource) updates) => super.copyWith((message) => updates(message as EmptyDirVolumeSource)) as EmptyDirVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EmptyDirVolumeSource create() => EmptyDirVolumeSource._();
  EmptyDirVolumeSource createEmptyInstance() => create();
  static $pb.PbList<EmptyDirVolumeSource> createRepeated() => $pb.PbList<EmptyDirVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static EmptyDirVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EmptyDirVolumeSource>(create);
  static EmptyDirVolumeSource? _defaultInstance;

  /// medium represents what type of storage medium should back this directory.
  /// The default is "" which means to use the node's default medium.
  /// Must be an empty string (default) or Memory.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  /// +optional
  @$pb.TagNumber(1)
  $core.String get medium => $_getSZ(0);
  @$pb.TagNumber(1)
  set medium($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasMedium() => $_has(0);
  @$pb.TagNumber(1)
  void clearMedium() => clearField(1);

  /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
  /// The size limit is also applicable for memory medium.
  /// The maximum usage on memory medium EmptyDir would be the minimum value between
  /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  /// The default is nil which means that the limit is undefined.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  /// +optional
  @$pb.TagNumber(2)
  $1.Quantity get sizeLimit => $_getN(1);
  @$pb.TagNumber(2)
  set sizeLimit($1.Quantity v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSizeLimit() => $_has(1);
  @$pb.TagNumber(2)
  void clearSizeLimit() => clearField(2);
  @$pb.TagNumber(2)
  $1.Quantity ensureSizeLimit() => $_ensure(1);
}

/// EndpointAddress is a tuple that describes single IP address.
/// +structType=atomic
class EndpointAddress extends $pb.GeneratedMessage {
  factory EndpointAddress({
    $core.String? ip,
    ObjectReference? targetRef,
    $core.String? hostname,
    $core.String? nodeName,
  }) {
    final $result = create();
    if (ip != null) {
      $result.ip = ip;
    }
    if (targetRef != null) {
      $result.targetRef = targetRef;
    }
    if (hostname != null) {
      $result.hostname = hostname;
    }
    if (nodeName != null) {
      $result.nodeName = nodeName;
    }
    return $result;
  }
  EndpointAddress._() : super();
  factory EndpointAddress.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EndpointAddress.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EndpointAddress', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'ip')
    ..aOM<ObjectReference>(2, _omitFieldNames ? '' : 'targetRef', protoName: 'targetRef', subBuilder: ObjectReference.create)
    ..aOS(3, _omitFieldNames ? '' : 'hostname')
    ..aOS(4, _omitFieldNames ? '' : 'nodeName', protoName: 'nodeName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EndpointAddress clone() => EndpointAddress()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EndpointAddress copyWith(void Function(EndpointAddress) updates) => super.copyWith((message) => updates(message as EndpointAddress)) as EndpointAddress;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EndpointAddress create() => EndpointAddress._();
  EndpointAddress createEmptyInstance() => create();
  static $pb.PbList<EndpointAddress> createRepeated() => $pb.PbList<EndpointAddress>();
  @$core.pragma('dart2js:noInline')
  static EndpointAddress getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EndpointAddress>(create);
  static EndpointAddress? _defaultInstance;

  /// The IP of this endpoint.
  /// May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10),
  /// or link-local multicast (224.0.0.0/24 or ff02::/16).
  @$pb.TagNumber(1)
  $core.String get ip => $_getSZ(0);
  @$pb.TagNumber(1)
  set ip($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIp() => $_has(0);
  @$pb.TagNumber(1)
  void clearIp() => clearField(1);

  /// Reference to object providing the endpoint.
  /// +optional
  @$pb.TagNumber(2)
  ObjectReference get targetRef => $_getN(1);
  @$pb.TagNumber(2)
  set targetRef(ObjectReference v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasTargetRef() => $_has(1);
  @$pb.TagNumber(2)
  void clearTargetRef() => clearField(2);
  @$pb.TagNumber(2)
  ObjectReference ensureTargetRef() => $_ensure(1);

  /// The Hostname of this endpoint
  /// +optional
  @$pb.TagNumber(3)
  $core.String get hostname => $_getSZ(2);
  @$pb.TagNumber(3)
  set hostname($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasHostname() => $_has(2);
  @$pb.TagNumber(3)
  void clearHostname() => clearField(3);

  /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get nodeName => $_getSZ(3);
  @$pb.TagNumber(4)
  set nodeName($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasNodeName() => $_has(3);
  @$pb.TagNumber(4)
  void clearNodeName() => clearField(4);
}

/// EndpointPort is a tuple that describes a single port.
/// +structType=atomic
class EndpointPort extends $pb.GeneratedMessage {
  factory EndpointPort({
    $core.String? name,
    $core.int? port,
    $core.String? protocol,
    $core.String? appProtocol,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (port != null) {
      $result.port = port;
    }
    if (protocol != null) {
      $result.protocol = protocol;
    }
    if (appProtocol != null) {
      $result.appProtocol = appProtocol;
    }
    return $result;
  }
  EndpointPort._() : super();
  factory EndpointPort.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EndpointPort.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EndpointPort', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..a<$core.int>(2, _omitFieldNames ? '' : 'port', $pb.PbFieldType.O3)
    ..aOS(3, _omitFieldNames ? '' : 'protocol')
    ..aOS(4, _omitFieldNames ? '' : 'appProtocol', protoName: 'appProtocol')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EndpointPort clone() => EndpointPort()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EndpointPort copyWith(void Function(EndpointPort) updates) => super.copyWith((message) => updates(message as EndpointPort)) as EndpointPort;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EndpointPort create() => EndpointPort._();
  EndpointPort createEmptyInstance() => create();
  static $pb.PbList<EndpointPort> createRepeated() => $pb.PbList<EndpointPort>();
  @$core.pragma('dart2js:noInline')
  static EndpointPort getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EndpointPort>(create);
  static EndpointPort? _defaultInstance;

  /// The name of this port.  This must match the 'name' field in the
  /// corresponding ServicePort.
  /// Must be a DNS_LABEL.
  /// Optional only if one port is defined.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// The port number of the endpoint.
  @$pb.TagNumber(2)
  $core.int get port => $_getIZ(1);
  @$pb.TagNumber(2)
  set port($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPort() => $_has(1);
  @$pb.TagNumber(2)
  void clearPort() => clearField(2);

  /// The IP protocol for this port.
  /// Must be UDP, TCP, or SCTP.
  /// Default is TCP.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get protocol => $_getSZ(2);
  @$pb.TagNumber(3)
  set protocol($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasProtocol() => $_has(2);
  @$pb.TagNumber(3)
  void clearProtocol() => clearField(3);

  ///  The application protocol for this port.
  ///  This is used as a hint for implementations to offer richer behavior for protocols that they understand.
  ///  This field follows standard Kubernetes label syntax.
  ///  Valid values are either:
  ///
  ///  * Un-prefixed protocol names - reserved for IANA standard service names (as per
  ///  RFC-6335 and https://www.iana.org/assignments/service-names).
  ///
  ///  * Kubernetes-defined prefixed names:
  ///    * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
  ///    * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
  ///    * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
  ///
  ///  * Other protocols should use implementation-defined prefixed names such as
  ///  mycompany.com/my-custom-protocol.
  ///  +optional
  @$pb.TagNumber(4)
  $core.String get appProtocol => $_getSZ(3);
  @$pb.TagNumber(4)
  set appProtocol($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasAppProtocol() => $_has(3);
  @$pb.TagNumber(4)
  void clearAppProtocol() => clearField(4);
}

///  EndpointSubset is a group of addresses with a common set of ports. The
///  expanded set of endpoints is the Cartesian product of Addresses x Ports.
///  For example, given:
///
///  	{
///  	  Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
///  	  Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
///  	}
///
///  The resulting set of endpoints can be viewed as:
///
///  	a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
///  	b: [ 10.10.1.1:309, 10.10.2.2:309 ]
class EndpointSubset extends $pb.GeneratedMessage {
  factory EndpointSubset({
    $core.Iterable<EndpointAddress>? addresses,
    $core.Iterable<EndpointAddress>? notReadyAddresses,
    $core.Iterable<EndpointPort>? ports,
  }) {
    final $result = create();
    if (addresses != null) {
      $result.addresses.addAll(addresses);
    }
    if (notReadyAddresses != null) {
      $result.notReadyAddresses.addAll(notReadyAddresses);
    }
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    return $result;
  }
  EndpointSubset._() : super();
  factory EndpointSubset.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EndpointSubset.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EndpointSubset', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<EndpointAddress>(1, _omitFieldNames ? '' : 'addresses', $pb.PbFieldType.PM, subBuilder: EndpointAddress.create)
    ..pc<EndpointAddress>(2, _omitFieldNames ? '' : 'notReadyAddresses', $pb.PbFieldType.PM, protoName: 'notReadyAddresses', subBuilder: EndpointAddress.create)
    ..pc<EndpointPort>(3, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.PM, subBuilder: EndpointPort.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EndpointSubset clone() => EndpointSubset()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EndpointSubset copyWith(void Function(EndpointSubset) updates) => super.copyWith((message) => updates(message as EndpointSubset)) as EndpointSubset;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EndpointSubset create() => EndpointSubset._();
  EndpointSubset createEmptyInstance() => create();
  static $pb.PbList<EndpointSubset> createRepeated() => $pb.PbList<EndpointSubset>();
  @$core.pragma('dart2js:noInline')
  static EndpointSubset getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EndpointSubset>(create);
  static EndpointSubset? _defaultInstance;

  /// IP addresses which offer the related ports that are marked as ready. These endpoints
  /// should be considered safe for load balancers and clients to utilize.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<EndpointAddress> get addresses => $_getList(0);

  /// IP addresses which offer the related ports but are not currently marked as ready
  /// because they have not yet finished starting, have recently failed a readiness check,
  /// or have recently failed a liveness check.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<EndpointAddress> get notReadyAddresses => $_getList(1);

  /// Port numbers available on the related IP addresses.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<EndpointPort> get ports => $_getList(2);
}

///  Endpoints is a collection of endpoints that implement the actual service. Example:
///
///  	 Name: "mysvc",
///  	 Subsets: [
///  	   {
///  	     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
///  	     Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
///  	   },
///  	   {
///  	     Addresses: [{"ip": "10.10.3.3"}],
///  	     Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
///  	   },
///  	]
class Endpoints extends $pb.GeneratedMessage {
  factory Endpoints({
    $0.ObjectMeta? metadata,
    $core.Iterable<EndpointSubset>? subsets,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (subsets != null) {
      $result.subsets.addAll(subsets);
    }
    return $result;
  }
  Endpoints._() : super();
  factory Endpoints.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Endpoints.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Endpoints', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..pc<EndpointSubset>(2, _omitFieldNames ? '' : 'subsets', $pb.PbFieldType.PM, subBuilder: EndpointSubset.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Endpoints clone() => Endpoints()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Endpoints copyWith(void Function(Endpoints) updates) => super.copyWith((message) => updates(message as Endpoints)) as Endpoints;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Endpoints create() => Endpoints._();
  Endpoints createEmptyInstance() => create();
  static $pb.PbList<Endpoints> createRepeated() => $pb.PbList<Endpoints>();
  @$core.pragma('dart2js:noInline')
  static Endpoints getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Endpoints>(create);
  static Endpoints? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// The set of all endpoints is the union of all subsets. Addresses are placed into
  /// subsets according to the IPs they share. A single address with multiple ports,
  /// some of which are ready and some of which are not (because they come from
  /// different containers) will result in the address being displayed in different
  /// subsets for the different ports. No address will appear in both Addresses and
  /// NotReadyAddresses in the same subset.
  /// Sets of addresses and ports that comprise a service.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<EndpointSubset> get subsets => $_getList(1);
}

/// EndpointsList is a list of endpoints.
class EndpointsList extends $pb.GeneratedMessage {
  factory EndpointsList({
    $0.ListMeta? metadata,
    $core.Iterable<Endpoints>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  EndpointsList._() : super();
  factory EndpointsList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EndpointsList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EndpointsList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Endpoints>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Endpoints.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EndpointsList clone() => EndpointsList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EndpointsList copyWith(void Function(EndpointsList) updates) => super.copyWith((message) => updates(message as EndpointsList)) as EndpointsList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EndpointsList create() => EndpointsList._();
  EndpointsList createEmptyInstance() => create();
  static $pb.PbList<EndpointsList> createRepeated() => $pb.PbList<EndpointsList>();
  @$core.pragma('dart2js:noInline')
  static EndpointsList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EndpointsList>(create);
  static EndpointsList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of endpoints.
  @$pb.TagNumber(2)
  $core.List<Endpoints> get items => $_getList(1);
}

/// EnvFromSource represents the source of a set of ConfigMaps
class EnvFromSource extends $pb.GeneratedMessage {
  factory EnvFromSource({
    $core.String? prefix,
    ConfigMapEnvSource? configMapRef,
    SecretEnvSource? secretRef,
  }) {
    final $result = create();
    if (prefix != null) {
      $result.prefix = prefix;
    }
    if (configMapRef != null) {
      $result.configMapRef = configMapRef;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    return $result;
  }
  EnvFromSource._() : super();
  factory EnvFromSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EnvFromSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EnvFromSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'prefix')
    ..aOM<ConfigMapEnvSource>(2, _omitFieldNames ? '' : 'configMapRef', protoName: 'configMapRef', subBuilder: ConfigMapEnvSource.create)
    ..aOM<SecretEnvSource>(3, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretEnvSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EnvFromSource clone() => EnvFromSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EnvFromSource copyWith(void Function(EnvFromSource) updates) => super.copyWith((message) => updates(message as EnvFromSource)) as EnvFromSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EnvFromSource create() => EnvFromSource._();
  EnvFromSource createEmptyInstance() => create();
  static $pb.PbList<EnvFromSource> createRepeated() => $pb.PbList<EnvFromSource>();
  @$core.pragma('dart2js:noInline')
  static EnvFromSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EnvFromSource>(create);
  static EnvFromSource? _defaultInstance;

  /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get prefix => $_getSZ(0);
  @$pb.TagNumber(1)
  set prefix($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPrefix() => $_has(0);
  @$pb.TagNumber(1)
  void clearPrefix() => clearField(1);

  /// The ConfigMap to select from
  /// +optional
  @$pb.TagNumber(2)
  ConfigMapEnvSource get configMapRef => $_getN(1);
  @$pb.TagNumber(2)
  set configMapRef(ConfigMapEnvSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasConfigMapRef() => $_has(1);
  @$pb.TagNumber(2)
  void clearConfigMapRef() => clearField(2);
  @$pb.TagNumber(2)
  ConfigMapEnvSource ensureConfigMapRef() => $_ensure(1);

  /// The Secret to select from
  /// +optional
  @$pb.TagNumber(3)
  SecretEnvSource get secretRef => $_getN(2);
  @$pb.TagNumber(3)
  set secretRef(SecretEnvSource v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSecretRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearSecretRef() => clearField(3);
  @$pb.TagNumber(3)
  SecretEnvSource ensureSecretRef() => $_ensure(2);
}

/// EnvVar represents an environment variable present in a Container.
class EnvVar extends $pb.GeneratedMessage {
  factory EnvVar({
    $core.String? name,
    $core.String? value,
    EnvVarSource? valueFrom,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (value != null) {
      $result.value = value;
    }
    if (valueFrom != null) {
      $result.valueFrom = valueFrom;
    }
    return $result;
  }
  EnvVar._() : super();
  factory EnvVar.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EnvVar.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EnvVar', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'value')
    ..aOM<EnvVarSource>(3, _omitFieldNames ? '' : 'valueFrom', protoName: 'valueFrom', subBuilder: EnvVarSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EnvVar clone() => EnvVar()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EnvVar copyWith(void Function(EnvVar) updates) => super.copyWith((message) => updates(message as EnvVar)) as EnvVar;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EnvVar create() => EnvVar._();
  EnvVar createEmptyInstance() => create();
  static $pb.PbList<EnvVar> createRepeated() => $pb.PbList<EnvVar>();
  @$core.pragma('dart2js:noInline')
  static EnvVar getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EnvVar>(create);
  static EnvVar? _defaultInstance;

  /// Name of the environment variable. Must be a C_IDENTIFIER.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Variable references $(VAR_NAME) are expanded
  /// using the previously defined environment variables in the container and
  /// any service environment variables. If a variable cannot be resolved,
  /// the reference in the input string will be unchanged. Double $$ are reduced
  /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
  /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
  /// Escaped references will never be expanded, regardless of whether the variable
  /// exists or not.
  /// Defaults to "".
  /// +optional
  @$pb.TagNumber(2)
  $core.String get value => $_getSZ(1);
  @$pb.TagNumber(2)
  set value($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasValue() => $_has(1);
  @$pb.TagNumber(2)
  void clearValue() => clearField(2);

  /// Source for the environment variable's value. Cannot be used if value is not empty.
  /// +optional
  @$pb.TagNumber(3)
  EnvVarSource get valueFrom => $_getN(2);
  @$pb.TagNumber(3)
  set valueFrom(EnvVarSource v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasValueFrom() => $_has(2);
  @$pb.TagNumber(3)
  void clearValueFrom() => clearField(3);
  @$pb.TagNumber(3)
  EnvVarSource ensureValueFrom() => $_ensure(2);
}

/// EnvVarSource represents a source for the value of an EnvVar.
class EnvVarSource extends $pb.GeneratedMessage {
  factory EnvVarSource({
    ObjectFieldSelector? fieldRef,
    ResourceFieldSelector? resourceFieldRef,
    ConfigMapKeySelector? configMapKeyRef,
    SecretKeySelector? secretKeyRef,
  }) {
    final $result = create();
    if (fieldRef != null) {
      $result.fieldRef = fieldRef;
    }
    if (resourceFieldRef != null) {
      $result.resourceFieldRef = resourceFieldRef;
    }
    if (configMapKeyRef != null) {
      $result.configMapKeyRef = configMapKeyRef;
    }
    if (secretKeyRef != null) {
      $result.secretKeyRef = secretKeyRef;
    }
    return $result;
  }
  EnvVarSource._() : super();
  factory EnvVarSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EnvVarSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EnvVarSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ObjectFieldSelector>(1, _omitFieldNames ? '' : 'fieldRef', protoName: 'fieldRef', subBuilder: ObjectFieldSelector.create)
    ..aOM<ResourceFieldSelector>(2, _omitFieldNames ? '' : 'resourceFieldRef', protoName: 'resourceFieldRef', subBuilder: ResourceFieldSelector.create)
    ..aOM<ConfigMapKeySelector>(3, _omitFieldNames ? '' : 'configMapKeyRef', protoName: 'configMapKeyRef', subBuilder: ConfigMapKeySelector.create)
    ..aOM<SecretKeySelector>(4, _omitFieldNames ? '' : 'secretKeyRef', protoName: 'secretKeyRef', subBuilder: SecretKeySelector.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EnvVarSource clone() => EnvVarSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EnvVarSource copyWith(void Function(EnvVarSource) updates) => super.copyWith((message) => updates(message as EnvVarSource)) as EnvVarSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EnvVarSource create() => EnvVarSource._();
  EnvVarSource createEmptyInstance() => create();
  static $pb.PbList<EnvVarSource> createRepeated() => $pb.PbList<EnvVarSource>();
  @$core.pragma('dart2js:noInline')
  static EnvVarSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EnvVarSource>(create);
  static EnvVarSource? _defaultInstance;

  /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
  /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  /// +optional
  @$pb.TagNumber(1)
  ObjectFieldSelector get fieldRef => $_getN(0);
  @$pb.TagNumber(1)
  set fieldRef(ObjectFieldSelector v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasFieldRef() => $_has(0);
  @$pb.TagNumber(1)
  void clearFieldRef() => clearField(1);
  @$pb.TagNumber(1)
  ObjectFieldSelector ensureFieldRef() => $_ensure(0);

  /// Selects a resource of the container: only resources limits and requests
  /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  /// +optional
  @$pb.TagNumber(2)
  ResourceFieldSelector get resourceFieldRef => $_getN(1);
  @$pb.TagNumber(2)
  set resourceFieldRef(ResourceFieldSelector v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasResourceFieldRef() => $_has(1);
  @$pb.TagNumber(2)
  void clearResourceFieldRef() => clearField(2);
  @$pb.TagNumber(2)
  ResourceFieldSelector ensureResourceFieldRef() => $_ensure(1);

  /// Selects a key of a ConfigMap.
  /// +optional
  @$pb.TagNumber(3)
  ConfigMapKeySelector get configMapKeyRef => $_getN(2);
  @$pb.TagNumber(3)
  set configMapKeyRef(ConfigMapKeySelector v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasConfigMapKeyRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearConfigMapKeyRef() => clearField(3);
  @$pb.TagNumber(3)
  ConfigMapKeySelector ensureConfigMapKeyRef() => $_ensure(2);

  /// Selects a key of a secret in the pod's namespace
  /// +optional
  @$pb.TagNumber(4)
  SecretKeySelector get secretKeyRef => $_getN(3);
  @$pb.TagNumber(4)
  set secretKeyRef(SecretKeySelector v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasSecretKeyRef() => $_has(3);
  @$pb.TagNumber(4)
  void clearSecretKeyRef() => clearField(4);
  @$pb.TagNumber(4)
  SecretKeySelector ensureSecretKeyRef() => $_ensure(3);
}

///  An EphemeralContainer is a temporary container that you may add to an existing Pod for
///  user-initiated activities such as debugging. Ephemeral containers have no resource or
///  scheduling guarantees, and they will not be restarted when they exit or when a Pod is
///  removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
///  Pod to exceed its resource allocation.
///
///  To add an ephemeral container, use the ephemeralcontainers subresource of an existing
///  Pod. Ephemeral containers may not be removed or restarted.
class EphemeralContainer extends $pb.GeneratedMessage {
  factory EphemeralContainer({
    EphemeralContainerCommon? ephemeralContainerCommon,
    $core.String? targetContainerName,
  }) {
    final $result = create();
    if (ephemeralContainerCommon != null) {
      $result.ephemeralContainerCommon = ephemeralContainerCommon;
    }
    if (targetContainerName != null) {
      $result.targetContainerName = targetContainerName;
    }
    return $result;
  }
  EphemeralContainer._() : super();
  factory EphemeralContainer.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EphemeralContainer.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EphemeralContainer', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<EphemeralContainerCommon>(1, _omitFieldNames ? '' : 'ephemeralContainerCommon', protoName: 'ephemeralContainerCommon', subBuilder: EphemeralContainerCommon.create)
    ..aOS(2, _omitFieldNames ? '' : 'targetContainerName', protoName: 'targetContainerName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EphemeralContainer clone() => EphemeralContainer()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EphemeralContainer copyWith(void Function(EphemeralContainer) updates) => super.copyWith((message) => updates(message as EphemeralContainer)) as EphemeralContainer;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EphemeralContainer create() => EphemeralContainer._();
  EphemeralContainer createEmptyInstance() => create();
  static $pb.PbList<EphemeralContainer> createRepeated() => $pb.PbList<EphemeralContainer>();
  @$core.pragma('dart2js:noInline')
  static EphemeralContainer getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EphemeralContainer>(create);
  static EphemeralContainer? _defaultInstance;

  /// Ephemeral containers have all of the fields of Container, plus additional fields
  /// specific to ephemeral containers. Fields in common with Container are in the
  /// following inlined struct so than an EphemeralContainer may easily be converted
  /// to a Container.
  @$pb.TagNumber(1)
  EphemeralContainerCommon get ephemeralContainerCommon => $_getN(0);
  @$pb.TagNumber(1)
  set ephemeralContainerCommon(EphemeralContainerCommon v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasEphemeralContainerCommon() => $_has(0);
  @$pb.TagNumber(1)
  void clearEphemeralContainerCommon() => clearField(1);
  @$pb.TagNumber(1)
  EphemeralContainerCommon ensureEphemeralContainerCommon() => $_ensure(0);

  ///  If set, the name of the container from PodSpec that this ephemeral container targets.
  ///  The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
  ///  If not set then the ephemeral container uses the namespaces configured in the Pod spec.
  ///
  ///  The container runtime must implement support for this feature. If the runtime does not
  ///  support namespace targeting then the result of setting this field is undefined.
  ///  +optional
  @$pb.TagNumber(2)
  $core.String get targetContainerName => $_getSZ(1);
  @$pb.TagNumber(2)
  set targetContainerName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasTargetContainerName() => $_has(1);
  @$pb.TagNumber(2)
  void clearTargetContainerName() => clearField(2);
}

/// EphemeralContainerCommon is a copy of all fields in Container to be inlined in
/// EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
/// to Container and allows separate documentation for the fields of EphemeralContainer.
/// When a new field is added to Container it must be added here as well.
class EphemeralContainerCommon extends $pb.GeneratedMessage {
  factory EphemeralContainerCommon({
    $core.String? name,
    $core.String? image,
    $core.Iterable<$core.String>? command,
    $core.Iterable<$core.String>? args,
    $core.String? workingDir,
    $core.Iterable<ContainerPort>? ports,
    $core.Iterable<EnvVar>? env,
    ResourceRequirements? resources,
    $core.Iterable<VolumeMount>? volumeMounts,
    Probe? livenessProbe,
    Probe? readinessProbe,
    Lifecycle? lifecycle,
    $core.String? terminationMessagePath,
    $core.String? imagePullPolicy,
    SecurityContext? securityContext,
    $core.bool? stdin,
    $core.bool? stdinOnce,
    $core.bool? tty,
    $core.Iterable<EnvFromSource>? envFrom,
    $core.String? terminationMessagePolicy,
    $core.Iterable<VolumeDevice>? volumeDevices,
    Probe? startupProbe,
    $core.Iterable<ContainerResizePolicy>? resizePolicy,
    $core.String? restartPolicy,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (image != null) {
      $result.image = image;
    }
    if (command != null) {
      $result.command.addAll(command);
    }
    if (args != null) {
      $result.args.addAll(args);
    }
    if (workingDir != null) {
      $result.workingDir = workingDir;
    }
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    if (env != null) {
      $result.env.addAll(env);
    }
    if (resources != null) {
      $result.resources = resources;
    }
    if (volumeMounts != null) {
      $result.volumeMounts.addAll(volumeMounts);
    }
    if (livenessProbe != null) {
      $result.livenessProbe = livenessProbe;
    }
    if (readinessProbe != null) {
      $result.readinessProbe = readinessProbe;
    }
    if (lifecycle != null) {
      $result.lifecycle = lifecycle;
    }
    if (terminationMessagePath != null) {
      $result.terminationMessagePath = terminationMessagePath;
    }
    if (imagePullPolicy != null) {
      $result.imagePullPolicy = imagePullPolicy;
    }
    if (securityContext != null) {
      $result.securityContext = securityContext;
    }
    if (stdin != null) {
      $result.stdin = stdin;
    }
    if (stdinOnce != null) {
      $result.stdinOnce = stdinOnce;
    }
    if (tty != null) {
      $result.tty = tty;
    }
    if (envFrom != null) {
      $result.envFrom.addAll(envFrom);
    }
    if (terminationMessagePolicy != null) {
      $result.terminationMessagePolicy = terminationMessagePolicy;
    }
    if (volumeDevices != null) {
      $result.volumeDevices.addAll(volumeDevices);
    }
    if (startupProbe != null) {
      $result.startupProbe = startupProbe;
    }
    if (resizePolicy != null) {
      $result.resizePolicy.addAll(resizePolicy);
    }
    if (restartPolicy != null) {
      $result.restartPolicy = restartPolicy;
    }
    return $result;
  }
  EphemeralContainerCommon._() : super();
  factory EphemeralContainerCommon.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EphemeralContainerCommon.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EphemeralContainerCommon', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'image')
    ..pPS(3, _omitFieldNames ? '' : 'command')
    ..pPS(4, _omitFieldNames ? '' : 'args')
    ..aOS(5, _omitFieldNames ? '' : 'workingDir', protoName: 'workingDir')
    ..pc<ContainerPort>(6, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.PM, subBuilder: ContainerPort.create)
    ..pc<EnvVar>(7, _omitFieldNames ? '' : 'env', $pb.PbFieldType.PM, subBuilder: EnvVar.create)
    ..aOM<ResourceRequirements>(8, _omitFieldNames ? '' : 'resources', subBuilder: ResourceRequirements.create)
    ..pc<VolumeMount>(9, _omitFieldNames ? '' : 'volumeMounts', $pb.PbFieldType.PM, protoName: 'volumeMounts', subBuilder: VolumeMount.create)
    ..aOM<Probe>(10, _omitFieldNames ? '' : 'livenessProbe', protoName: 'livenessProbe', subBuilder: Probe.create)
    ..aOM<Probe>(11, _omitFieldNames ? '' : 'readinessProbe', protoName: 'readinessProbe', subBuilder: Probe.create)
    ..aOM<Lifecycle>(12, _omitFieldNames ? '' : 'lifecycle', subBuilder: Lifecycle.create)
    ..aOS(13, _omitFieldNames ? '' : 'terminationMessagePath', protoName: 'terminationMessagePath')
    ..aOS(14, _omitFieldNames ? '' : 'imagePullPolicy', protoName: 'imagePullPolicy')
    ..aOM<SecurityContext>(15, _omitFieldNames ? '' : 'securityContext', protoName: 'securityContext', subBuilder: SecurityContext.create)
    ..aOB(16, _omitFieldNames ? '' : 'stdin')
    ..aOB(17, _omitFieldNames ? '' : 'stdinOnce', protoName: 'stdinOnce')
    ..aOB(18, _omitFieldNames ? '' : 'tty')
    ..pc<EnvFromSource>(19, _omitFieldNames ? '' : 'envFrom', $pb.PbFieldType.PM, protoName: 'envFrom', subBuilder: EnvFromSource.create)
    ..aOS(20, _omitFieldNames ? '' : 'terminationMessagePolicy', protoName: 'terminationMessagePolicy')
    ..pc<VolumeDevice>(21, _omitFieldNames ? '' : 'volumeDevices', $pb.PbFieldType.PM, protoName: 'volumeDevices', subBuilder: VolumeDevice.create)
    ..aOM<Probe>(22, _omitFieldNames ? '' : 'startupProbe', protoName: 'startupProbe', subBuilder: Probe.create)
    ..pc<ContainerResizePolicy>(23, _omitFieldNames ? '' : 'resizePolicy', $pb.PbFieldType.PM, protoName: 'resizePolicy', subBuilder: ContainerResizePolicy.create)
    ..aOS(24, _omitFieldNames ? '' : 'restartPolicy', protoName: 'restartPolicy')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EphemeralContainerCommon clone() => EphemeralContainerCommon()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EphemeralContainerCommon copyWith(void Function(EphemeralContainerCommon) updates) => super.copyWith((message) => updates(message as EphemeralContainerCommon)) as EphemeralContainerCommon;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EphemeralContainerCommon create() => EphemeralContainerCommon._();
  EphemeralContainerCommon createEmptyInstance() => create();
  static $pb.PbList<EphemeralContainerCommon> createRepeated() => $pb.PbList<EphemeralContainerCommon>();
  @$core.pragma('dart2js:noInline')
  static EphemeralContainerCommon getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EphemeralContainerCommon>(create);
  static EphemeralContainerCommon? _defaultInstance;

  /// Name of the ephemeral container specified as a DNS_LABEL.
  /// This name must be unique among all containers, init containers and ephemeral containers.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Container image name.
  /// More info: https://kubernetes.io/docs/concepts/containers/images
  @$pb.TagNumber(2)
  $core.String get image => $_getSZ(1);
  @$pb.TagNumber(2)
  set image($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasImage() => $_has(1);
  @$pb.TagNumber(2)
  void clearImage() => clearField(2);

  /// Entrypoint array. Not executed within a shell.
  /// The image's ENTRYPOINT is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  /// of whether the variable exists or not. Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<$core.String> get command => $_getList(2);

  /// Arguments to the entrypoint.
  /// The image's CMD is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  /// of whether the variable exists or not. Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(4)
  $core.List<$core.String> get args => $_getList(3);

  /// Container's working directory.
  /// If not specified, the container runtime's default will be used, which
  /// might be configured in the container image.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get workingDir => $_getSZ(4);
  @$pb.TagNumber(5)
  set workingDir($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasWorkingDir() => $_has(4);
  @$pb.TagNumber(5)
  void clearWorkingDir() => clearField(5);

  /// Ports are not allowed for ephemeral containers.
  /// +optional
  /// +patchMergeKey=containerPort
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=containerPort
  /// +listMapKey=protocol
  @$pb.TagNumber(6)
  $core.List<ContainerPort> get ports => $_getList(5);

  /// List of environment variables to set in the container.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(7)
  $core.List<EnvVar> get env => $_getList(6);

  /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
  /// already allocated to the pod.
  /// +optional
  @$pb.TagNumber(8)
  ResourceRequirements get resources => $_getN(7);
  @$pb.TagNumber(8)
  set resources(ResourceRequirements v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasResources() => $_has(7);
  @$pb.TagNumber(8)
  void clearResources() => clearField(8);
  @$pb.TagNumber(8)
  ResourceRequirements ensureResources() => $_ensure(7);

  /// Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=mountPath
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=mountPath
  @$pb.TagNumber(9)
  $core.List<VolumeMount> get volumeMounts => $_getList(8);

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  @$pb.TagNumber(10)
  Probe get livenessProbe => $_getN(9);
  @$pb.TagNumber(10)
  set livenessProbe(Probe v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasLivenessProbe() => $_has(9);
  @$pb.TagNumber(10)
  void clearLivenessProbe() => clearField(10);
  @$pb.TagNumber(10)
  Probe ensureLivenessProbe() => $_ensure(9);

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  @$pb.TagNumber(11)
  Probe get readinessProbe => $_getN(10);
  @$pb.TagNumber(11)
  set readinessProbe(Probe v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasReadinessProbe() => $_has(10);
  @$pb.TagNumber(11)
  void clearReadinessProbe() => clearField(11);
  @$pb.TagNumber(11)
  Probe ensureReadinessProbe() => $_ensure(10);

  /// Lifecycle is not allowed for ephemeral containers.
  /// +optional
  @$pb.TagNumber(12)
  Lifecycle get lifecycle => $_getN(11);
  @$pb.TagNumber(12)
  set lifecycle(Lifecycle v) { setField(12, v); }
  @$pb.TagNumber(12)
  $core.bool hasLifecycle() => $_has(11);
  @$pb.TagNumber(12)
  void clearLifecycle() => clearField(12);
  @$pb.TagNumber(12)
  Lifecycle ensureLifecycle() => $_ensure(11);

  /// Optional: Path at which the file to which the container's termination message
  /// will be written is mounted into the container's filesystem.
  /// Message written is intended to be brief final status, such as an assertion failure message.
  /// Will be truncated by the node if greater than 4096 bytes. The total message length across
  /// all containers will be limited to 12kb.
  /// Defaults to /dev/termination-log.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(13)
  $core.String get terminationMessagePath => $_getSZ(12);
  @$pb.TagNumber(13)
  set terminationMessagePath($core.String v) { $_setString(12, v); }
  @$pb.TagNumber(13)
  $core.bool hasTerminationMessagePath() => $_has(12);
  @$pb.TagNumber(13)
  void clearTerminationMessagePath() => clearField(13);

  /// Image pull policy.
  /// One of Always, Never, IfNotPresent.
  /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  /// +optional
  @$pb.TagNumber(14)
  $core.String get imagePullPolicy => $_getSZ(13);
  @$pb.TagNumber(14)
  set imagePullPolicy($core.String v) { $_setString(13, v); }
  @$pb.TagNumber(14)
  $core.bool hasImagePullPolicy() => $_has(13);
  @$pb.TagNumber(14)
  void clearImagePullPolicy() => clearField(14);

  /// Optional: SecurityContext defines the security options the ephemeral container should be run with.
  /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
  /// +optional
  @$pb.TagNumber(15)
  SecurityContext get securityContext => $_getN(14);
  @$pb.TagNumber(15)
  set securityContext(SecurityContext v) { setField(15, v); }
  @$pb.TagNumber(15)
  $core.bool hasSecurityContext() => $_has(14);
  @$pb.TagNumber(15)
  void clearSecurityContext() => clearField(15);
  @$pb.TagNumber(15)
  SecurityContext ensureSecurityContext() => $_ensure(14);

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this
  /// is not set, reads from stdin in the container will always result in EOF.
  /// Default is false.
  /// +optional
  @$pb.TagNumber(16)
  $core.bool get stdin => $_getBF(15);
  @$pb.TagNumber(16)
  set stdin($core.bool v) { $_setBool(15, v); }
  @$pb.TagNumber(16)
  $core.bool hasStdin() => $_has(15);
  @$pb.TagNumber(16)
  void clearStdin() => clearField(16);

  /// Whether the container runtime should close the stdin channel after it has been opened by
  /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
  /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  /// at which time stdin is closed and remains closed until the container is restarted. If this
  /// flag is false, a container processes that reads from stdin will never receive an EOF.
  /// Default is false
  /// +optional
  @$pb.TagNumber(17)
  $core.bool get stdinOnce => $_getBF(16);
  @$pb.TagNumber(17)
  set stdinOnce($core.bool v) { $_setBool(16, v); }
  @$pb.TagNumber(17)
  $core.bool hasStdinOnce() => $_has(16);
  @$pb.TagNumber(17)
  void clearStdinOnce() => clearField(17);

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  /// Default is false.
  /// +optional
  @$pb.TagNumber(18)
  $core.bool get tty => $_getBF(17);
  @$pb.TagNumber(18)
  set tty($core.bool v) { $_setBool(17, v); }
  @$pb.TagNumber(18)
  $core.bool hasTty() => $_has(17);
  @$pb.TagNumber(18)
  void clearTty() => clearField(18);

  /// List of sources to populate environment variables in the container.
  /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  /// will be reported as an event when the container is starting. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence.
  /// Values defined by an Env with a duplicate key will take precedence.
  /// Cannot be updated.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(19)
  $core.List<EnvFromSource> get envFrom => $_getList(18);

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination
  /// message file is empty and the container exited with an error.
  /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  /// Defaults to File.
  /// Cannot be updated.
  /// +optional
  @$pb.TagNumber(20)
  $core.String get terminationMessagePolicy => $_getSZ(19);
  @$pb.TagNumber(20)
  set terminationMessagePolicy($core.String v) { $_setString(19, v); }
  @$pb.TagNumber(20)
  $core.bool hasTerminationMessagePolicy() => $_has(19);
  @$pb.TagNumber(20)
  void clearTerminationMessagePolicy() => clearField(20);

  /// volumeDevices is the list of block devices to be used by the container.
  /// +patchMergeKey=devicePath
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=devicePath
  /// +optional
  @$pb.TagNumber(21)
  $core.List<VolumeDevice> get volumeDevices => $_getList(20);

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  @$pb.TagNumber(22)
  Probe get startupProbe => $_getN(21);
  @$pb.TagNumber(22)
  set startupProbe(Probe v) { setField(22, v); }
  @$pb.TagNumber(22)
  $core.bool hasStartupProbe() => $_has(21);
  @$pb.TagNumber(22)
  void clearStartupProbe() => clearField(22);
  @$pb.TagNumber(22)
  Probe ensureStartupProbe() => $_ensure(21);

  /// Resources resize policy for the container.
  /// +featureGate=InPlacePodVerticalScaling
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(23)
  $core.List<ContainerResizePolicy> get resizePolicy => $_getList(22);

  /// Restart policy for the container to manage the restart behavior of each
  /// container within a pod.
  /// This may only be set for init containers. You cannot set this field on
  /// ephemeral containers.
  /// +featureGate=SidecarContainers
  /// +optional
  @$pb.TagNumber(24)
  $core.String get restartPolicy => $_getSZ(23);
  @$pb.TagNumber(24)
  set restartPolicy($core.String v) { $_setString(23, v); }
  @$pb.TagNumber(24)
  $core.bool hasRestartPolicy() => $_has(23);
  @$pb.TagNumber(24)
  void clearRestartPolicy() => clearField(24);
}

/// Represents an ephemeral volume that is handled by a normal storage driver.
class EphemeralVolumeSource extends $pb.GeneratedMessage {
  factory EphemeralVolumeSource({
    PersistentVolumeClaimTemplate? volumeClaimTemplate,
  }) {
    final $result = create();
    if (volumeClaimTemplate != null) {
      $result.volumeClaimTemplate = volumeClaimTemplate;
    }
    return $result;
  }
  EphemeralVolumeSource._() : super();
  factory EphemeralVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EphemeralVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EphemeralVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<PersistentVolumeClaimTemplate>(1, _omitFieldNames ? '' : 'volumeClaimTemplate', protoName: 'volumeClaimTemplate', subBuilder: PersistentVolumeClaimTemplate.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EphemeralVolumeSource clone() => EphemeralVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EphemeralVolumeSource copyWith(void Function(EphemeralVolumeSource) updates) => super.copyWith((message) => updates(message as EphemeralVolumeSource)) as EphemeralVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EphemeralVolumeSource create() => EphemeralVolumeSource._();
  EphemeralVolumeSource createEmptyInstance() => create();
  static $pb.PbList<EphemeralVolumeSource> createRepeated() => $pb.PbList<EphemeralVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static EphemeralVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EphemeralVolumeSource>(create);
  static EphemeralVolumeSource? _defaultInstance;

  ///  Will be used to create a stand-alone PVC to provision the volume.
  ///  The pod in which this EphemeralVolumeSource is embedded will be the
  ///  owner of the PVC, i.e. the PVC will be deleted together with the
  ///  pod.  The name of the PVC will be `<pod name>-<volume name>` where
  ///  `<volume name>` is the name from the `PodSpec.Volumes` array
  ///  entry. Pod validation will reject the pod if the concatenated name
  ///  is not valid for a PVC (for example, too long).
  ///
  ///  An existing PVC with that name that is not owned by the pod
  ///  will *not* be used for the pod to avoid using an unrelated
  ///  volume by mistake. Starting the pod is then blocked until
  ///  the unrelated PVC is removed. If such a pre-created PVC is
  ///  meant to be used by the pod, the PVC has to updated with an
  ///  owner reference to the pod once the pod exists. Normally
  ///  this should not be necessary, but it may be useful when
  ///  manually reconstructing a broken cluster.
  ///
  ///  This field is read-only and no changes will be made by Kubernetes
  ///  to the PVC after it has been created.
  ///
  ///  Required, must not be nil.
  @$pb.TagNumber(1)
  PersistentVolumeClaimTemplate get volumeClaimTemplate => $_getN(0);
  @$pb.TagNumber(1)
  set volumeClaimTemplate(PersistentVolumeClaimTemplate v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeClaimTemplate() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeClaimTemplate() => clearField(1);
  @$pb.TagNumber(1)
  PersistentVolumeClaimTemplate ensureVolumeClaimTemplate() => $_ensure(0);
}

/// Event is a report of an event somewhere in the cluster.  Events
/// have a limited retention time and triggers and messages may evolve
/// with time.  Event consumers should not rely on the timing of an event
/// with a given Reason reflecting a consistent underlying trigger, or the
/// continued existence of events with that Reason.  Events should be
/// treated as informative, best-effort, supplemental data.
class Event extends $pb.GeneratedMessage {
  factory Event({
    $0.ObjectMeta? metadata,
    ObjectReference? involvedObject,
    $core.String? reason,
    $core.String? message,
    EventSource? source,
    $0.Time? firstTimestamp,
    $0.Time? lastTimestamp,
    $core.int? count,
    $core.String? type,
    $0.MicroTime? eventTime,
    EventSeries? series,
    $core.String? action,
    ObjectReference? related,
    $core.String? reportingComponent,
    $core.String? reportingInstance,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (involvedObject != null) {
      $result.involvedObject = involvedObject;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    if (source != null) {
      $result.source = source;
    }
    if (firstTimestamp != null) {
      $result.firstTimestamp = firstTimestamp;
    }
    if (lastTimestamp != null) {
      $result.lastTimestamp = lastTimestamp;
    }
    if (count != null) {
      $result.count = count;
    }
    if (type != null) {
      $result.type = type;
    }
    if (eventTime != null) {
      $result.eventTime = eventTime;
    }
    if (series != null) {
      $result.series = series;
    }
    if (action != null) {
      $result.action = action;
    }
    if (related != null) {
      $result.related = related;
    }
    if (reportingComponent != null) {
      $result.reportingComponent = reportingComponent;
    }
    if (reportingInstance != null) {
      $result.reportingInstance = reportingInstance;
    }
    return $result;
  }
  Event._() : super();
  factory Event.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Event.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Event', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<ObjectReference>(2, _omitFieldNames ? '' : 'involvedObject', protoName: 'involvedObject', subBuilder: ObjectReference.create)
    ..aOS(3, _omitFieldNames ? '' : 'reason')
    ..aOS(4, _omitFieldNames ? '' : 'message')
    ..aOM<EventSource>(5, _omitFieldNames ? '' : 'source', subBuilder: EventSource.create)
    ..aOM<$0.Time>(6, _omitFieldNames ? '' : 'firstTimestamp', protoName: 'firstTimestamp', subBuilder: $0.Time.create)
    ..aOM<$0.Time>(7, _omitFieldNames ? '' : 'lastTimestamp', protoName: 'lastTimestamp', subBuilder: $0.Time.create)
    ..a<$core.int>(8, _omitFieldNames ? '' : 'count', $pb.PbFieldType.O3)
    ..aOS(9, _omitFieldNames ? '' : 'type')
    ..aOM<$0.MicroTime>(10, _omitFieldNames ? '' : 'eventTime', protoName: 'eventTime', subBuilder: $0.MicroTime.create)
    ..aOM<EventSeries>(11, _omitFieldNames ? '' : 'series', subBuilder: EventSeries.create)
    ..aOS(12, _omitFieldNames ? '' : 'action')
    ..aOM<ObjectReference>(13, _omitFieldNames ? '' : 'related', subBuilder: ObjectReference.create)
    ..aOS(14, _omitFieldNames ? '' : 'reportingComponent', protoName: 'reportingComponent')
    ..aOS(15, _omitFieldNames ? '' : 'reportingInstance', protoName: 'reportingInstance')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Event clone() => Event()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Event copyWith(void Function(Event) updates) => super.copyWith((message) => updates(message as Event)) as Event;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Event create() => Event._();
  Event createEmptyInstance() => create();
  static $pb.PbList<Event> createRepeated() => $pb.PbList<Event>();
  @$core.pragma('dart2js:noInline')
  static Event getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Event>(create);
  static Event? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// The object that this event is about.
  @$pb.TagNumber(2)
  ObjectReference get involvedObject => $_getN(1);
  @$pb.TagNumber(2)
  set involvedObject(ObjectReference v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasInvolvedObject() => $_has(1);
  @$pb.TagNumber(2)
  void clearInvolvedObject() => clearField(2);
  @$pb.TagNumber(2)
  ObjectReference ensureInvolvedObject() => $_ensure(1);

  /// This should be a short, machine understandable string that gives the reason
  /// for the transition into the object's current status.
  /// TODO: provide exact specification for format.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get reason => $_getSZ(2);
  @$pb.TagNumber(3)
  set reason($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReason() => $_has(2);
  @$pb.TagNumber(3)
  void clearReason() => clearField(3);

  /// A human-readable description of the status of this operation.
  /// TODO: decide on maximum length.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get message => $_getSZ(3);
  @$pb.TagNumber(4)
  set message($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasMessage() => $_has(3);
  @$pb.TagNumber(4)
  void clearMessage() => clearField(4);

  /// The component reporting this event. Should be a short machine understandable string.
  /// +optional
  @$pb.TagNumber(5)
  EventSource get source => $_getN(4);
  @$pb.TagNumber(5)
  set source(EventSource v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSource() => $_has(4);
  @$pb.TagNumber(5)
  void clearSource() => clearField(5);
  @$pb.TagNumber(5)
  EventSource ensureSource() => $_ensure(4);

  /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
  /// +optional
  @$pb.TagNumber(6)
  $0.Time get firstTimestamp => $_getN(5);
  @$pb.TagNumber(6)
  set firstTimestamp($0.Time v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasFirstTimestamp() => $_has(5);
  @$pb.TagNumber(6)
  void clearFirstTimestamp() => clearField(6);
  @$pb.TagNumber(6)
  $0.Time ensureFirstTimestamp() => $_ensure(5);

  /// The time at which the most recent occurrence of this event was recorded.
  /// +optional
  @$pb.TagNumber(7)
  $0.Time get lastTimestamp => $_getN(6);
  @$pb.TagNumber(7)
  set lastTimestamp($0.Time v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasLastTimestamp() => $_has(6);
  @$pb.TagNumber(7)
  void clearLastTimestamp() => clearField(7);
  @$pb.TagNumber(7)
  $0.Time ensureLastTimestamp() => $_ensure(6);

  /// The number of times this event has occurred.
  /// +optional
  @$pb.TagNumber(8)
  $core.int get count => $_getIZ(7);
  @$pb.TagNumber(8)
  set count($core.int v) { $_setSignedInt32(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasCount() => $_has(7);
  @$pb.TagNumber(8)
  void clearCount() => clearField(8);

  /// Type of this event (Normal, Warning), new types could be added in the future
  /// +optional
  @$pb.TagNumber(9)
  $core.String get type => $_getSZ(8);
  @$pb.TagNumber(9)
  set type($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasType() => $_has(8);
  @$pb.TagNumber(9)
  void clearType() => clearField(9);

  /// Time when this Event was first observed.
  /// +optional
  @$pb.TagNumber(10)
  $0.MicroTime get eventTime => $_getN(9);
  @$pb.TagNumber(10)
  set eventTime($0.MicroTime v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasEventTime() => $_has(9);
  @$pb.TagNumber(10)
  void clearEventTime() => clearField(10);
  @$pb.TagNumber(10)
  $0.MicroTime ensureEventTime() => $_ensure(9);

  /// Data about the Event series this event represents or nil if it's a singleton Event.
  /// +optional
  @$pb.TagNumber(11)
  EventSeries get series => $_getN(10);
  @$pb.TagNumber(11)
  set series(EventSeries v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasSeries() => $_has(10);
  @$pb.TagNumber(11)
  void clearSeries() => clearField(11);
  @$pb.TagNumber(11)
  EventSeries ensureSeries() => $_ensure(10);

  /// What action was taken/failed regarding to the Regarding object.
  /// +optional
  @$pb.TagNumber(12)
  $core.String get action => $_getSZ(11);
  @$pb.TagNumber(12)
  set action($core.String v) { $_setString(11, v); }
  @$pb.TagNumber(12)
  $core.bool hasAction() => $_has(11);
  @$pb.TagNumber(12)
  void clearAction() => clearField(12);

  /// Optional secondary object for more complex actions.
  /// +optional
  @$pb.TagNumber(13)
  ObjectReference get related => $_getN(12);
  @$pb.TagNumber(13)
  set related(ObjectReference v) { setField(13, v); }
  @$pb.TagNumber(13)
  $core.bool hasRelated() => $_has(12);
  @$pb.TagNumber(13)
  void clearRelated() => clearField(13);
  @$pb.TagNumber(13)
  ObjectReference ensureRelated() => $_ensure(12);

  /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
  /// +optional
  @$pb.TagNumber(14)
  $core.String get reportingComponent => $_getSZ(13);
  @$pb.TagNumber(14)
  set reportingComponent($core.String v) { $_setString(13, v); }
  @$pb.TagNumber(14)
  $core.bool hasReportingComponent() => $_has(13);
  @$pb.TagNumber(14)
  void clearReportingComponent() => clearField(14);

  /// ID of the controller instance, e.g. `kubelet-xyzf`.
  /// +optional
  @$pb.TagNumber(15)
  $core.String get reportingInstance => $_getSZ(14);
  @$pb.TagNumber(15)
  set reportingInstance($core.String v) { $_setString(14, v); }
  @$pb.TagNumber(15)
  $core.bool hasReportingInstance() => $_has(14);
  @$pb.TagNumber(15)
  void clearReportingInstance() => clearField(15);
}

/// EventList is a list of events.
class EventList extends $pb.GeneratedMessage {
  factory EventList({
    $0.ListMeta? metadata,
    $core.Iterable<Event>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  EventList._() : super();
  factory EventList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EventList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EventList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Event>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Event.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EventList clone() => EventList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EventList copyWith(void Function(EventList) updates) => super.copyWith((message) => updates(message as EventList)) as EventList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EventList create() => EventList._();
  EventList createEmptyInstance() => create();
  static $pb.PbList<EventList> createRepeated() => $pb.PbList<EventList>();
  @$core.pragma('dart2js:noInline')
  static EventList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EventList>(create);
  static EventList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of events
  @$pb.TagNumber(2)
  $core.List<Event> get items => $_getList(1);
}

/// EventSeries contain information on series of events, i.e. thing that was/is happening
/// continuously for some time.
class EventSeries extends $pb.GeneratedMessage {
  factory EventSeries({
    $core.int? count,
    $0.MicroTime? lastObservedTime,
  }) {
    final $result = create();
    if (count != null) {
      $result.count = count;
    }
    if (lastObservedTime != null) {
      $result.lastObservedTime = lastObservedTime;
    }
    return $result;
  }
  EventSeries._() : super();
  factory EventSeries.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EventSeries.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EventSeries', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'count', $pb.PbFieldType.O3)
    ..aOM<$0.MicroTime>(2, _omitFieldNames ? '' : 'lastObservedTime', protoName: 'lastObservedTime', subBuilder: $0.MicroTime.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EventSeries clone() => EventSeries()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EventSeries copyWith(void Function(EventSeries) updates) => super.copyWith((message) => updates(message as EventSeries)) as EventSeries;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EventSeries create() => EventSeries._();
  EventSeries createEmptyInstance() => create();
  static $pb.PbList<EventSeries> createRepeated() => $pb.PbList<EventSeries>();
  @$core.pragma('dart2js:noInline')
  static EventSeries getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EventSeries>(create);
  static EventSeries? _defaultInstance;

  /// Number of occurrences in this series up to the last heartbeat time
  @$pb.TagNumber(1)
  $core.int get count => $_getIZ(0);
  @$pb.TagNumber(1)
  set count($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasCount() => $_has(0);
  @$pb.TagNumber(1)
  void clearCount() => clearField(1);

  /// Time of the last occurrence observed
  @$pb.TagNumber(2)
  $0.MicroTime get lastObservedTime => $_getN(1);
  @$pb.TagNumber(2)
  set lastObservedTime($0.MicroTime v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasLastObservedTime() => $_has(1);
  @$pb.TagNumber(2)
  void clearLastObservedTime() => clearField(2);
  @$pb.TagNumber(2)
  $0.MicroTime ensureLastObservedTime() => $_ensure(1);
}

/// EventSource contains information for an event.
class EventSource extends $pb.GeneratedMessage {
  factory EventSource({
    $core.String? component,
    $core.String? host,
  }) {
    final $result = create();
    if (component != null) {
      $result.component = component;
    }
    if (host != null) {
      $result.host = host;
    }
    return $result;
  }
  EventSource._() : super();
  factory EventSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory EventSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'EventSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'component')
    ..aOS(2, _omitFieldNames ? '' : 'host')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  EventSource clone() => EventSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  EventSource copyWith(void Function(EventSource) updates) => super.copyWith((message) => updates(message as EventSource)) as EventSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static EventSource create() => EventSource._();
  EventSource createEmptyInstance() => create();
  static $pb.PbList<EventSource> createRepeated() => $pb.PbList<EventSource>();
  @$core.pragma('dart2js:noInline')
  static EventSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<EventSource>(create);
  static EventSource? _defaultInstance;

  /// Component from which the event is generated.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get component => $_getSZ(0);
  @$pb.TagNumber(1)
  set component($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasComponent() => $_has(0);
  @$pb.TagNumber(1)
  void clearComponent() => clearField(1);

  /// Node name on which the event is generated.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get host => $_getSZ(1);
  @$pb.TagNumber(2)
  set host($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasHost() => $_has(1);
  @$pb.TagNumber(2)
  void clearHost() => clearField(2);
}

/// ExecAction describes a "run in container" action.
class ExecAction extends $pb.GeneratedMessage {
  factory ExecAction({
    $core.Iterable<$core.String>? command,
  }) {
    final $result = create();
    if (command != null) {
      $result.command.addAll(command);
    }
    return $result;
  }
  ExecAction._() : super();
  factory ExecAction.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ExecAction.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ExecAction', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'command')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ExecAction clone() => ExecAction()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ExecAction copyWith(void Function(ExecAction) updates) => super.copyWith((message) => updates(message as ExecAction)) as ExecAction;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ExecAction create() => ExecAction._();
  ExecAction createEmptyInstance() => create();
  static $pb.PbList<ExecAction> createRepeated() => $pb.PbList<ExecAction>();
  @$core.pragma('dart2js:noInline')
  static ExecAction getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ExecAction>(create);
  static ExecAction? _defaultInstance;

  /// Command is the command line to execute inside the container, the working directory for the
  /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  /// a shell, you need to explicitly call out to that shell.
  /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get command => $_getList(0);
}

/// Represents a Fibre Channel volume.
/// Fibre Channel volumes can only be mounted as read/write once.
/// Fibre Channel volumes support ownership management and SELinux relabeling.
class FCVolumeSource extends $pb.GeneratedMessage {
  factory FCVolumeSource({
    $core.Iterable<$core.String>? targetWWNs,
    $core.int? lun,
    $core.String? fsType,
    $core.bool? readOnly,
    $core.Iterable<$core.String>? wwids,
  }) {
    final $result = create();
    if (targetWWNs != null) {
      $result.targetWWNs.addAll(targetWWNs);
    }
    if (lun != null) {
      $result.lun = lun;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (wwids != null) {
      $result.wwids.addAll(wwids);
    }
    return $result;
  }
  FCVolumeSource._() : super();
  factory FCVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory FCVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'FCVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'targetWWNs', protoName: 'targetWWNs')
    ..a<$core.int>(2, _omitFieldNames ? '' : 'lun', $pb.PbFieldType.O3)
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..pPS(5, _omitFieldNames ? '' : 'wwids')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  FCVolumeSource clone() => FCVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  FCVolumeSource copyWith(void Function(FCVolumeSource) updates) => super.copyWith((message) => updates(message as FCVolumeSource)) as FCVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static FCVolumeSource create() => FCVolumeSource._();
  FCVolumeSource createEmptyInstance() => create();
  static $pb.PbList<FCVolumeSource> createRepeated() => $pb.PbList<FCVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static FCVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<FCVolumeSource>(create);
  static FCVolumeSource? _defaultInstance;

  /// targetWWNs is Optional: FC target worldwide names (WWNs)
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get targetWWNs => $_getList(0);

  /// lun is Optional: FC target lun number
  /// +optional
  @$pb.TagNumber(2)
  $core.int get lun => $_getIZ(1);
  @$pb.TagNumber(2)
  set lun($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasLun() => $_has(1);
  @$pb.TagNumber(2)
  void clearLun() => clearField(2);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);

  /// wwids Optional: FC volume world wide identifiers (wwids)
  /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(5)
  $core.List<$core.String> get wwids => $_getList(4);
}

/// FlexPersistentVolumeSource represents a generic persistent volume resource that is
/// provisioned/attached using an exec based plugin.
class FlexPersistentVolumeSource extends $pb.GeneratedMessage {
  factory FlexPersistentVolumeSource({
    $core.String? driver,
    $core.String? fsType,
    SecretReference? secretRef,
    $core.bool? readOnly,
    $core.Map<$core.String, $core.String>? options,
  }) {
    final $result = create();
    if (driver != null) {
      $result.driver = driver;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (options != null) {
      $result.options.addAll(options);
    }
    return $result;
  }
  FlexPersistentVolumeSource._() : super();
  factory FlexPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory FlexPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'FlexPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'driver')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOM<SecretReference>(3, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..m<$core.String, $core.String>(5, _omitFieldNames ? '' : 'options', entryClassName: 'FlexPersistentVolumeSource.OptionsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  FlexPersistentVolumeSource clone() => FlexPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  FlexPersistentVolumeSource copyWith(void Function(FlexPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as FlexPersistentVolumeSource)) as FlexPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static FlexPersistentVolumeSource create() => FlexPersistentVolumeSource._();
  FlexPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<FlexPersistentVolumeSource> createRepeated() => $pb.PbList<FlexPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static FlexPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<FlexPersistentVolumeSource>(create);
  static FlexPersistentVolumeSource? _defaultInstance;

  /// driver is the name of the driver to use for this volume.
  @$pb.TagNumber(1)
  $core.String get driver => $_getSZ(0);
  @$pb.TagNumber(1)
  set driver($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDriver() => $_has(0);
  @$pb.TagNumber(1)
  void clearDriver() => clearField(1);

  /// fsType is the Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// secretRef is Optional: SecretRef is reference to the secret object containing
  /// sensitive information to pass to the plugin scripts. This may be
  /// empty if no secret object is specified. If the secret object
  /// contains more than one secret, all secrets are passed to the plugin
  /// scripts.
  /// +optional
  @$pb.TagNumber(3)
  SecretReference get secretRef => $_getN(2);
  @$pb.TagNumber(3)
  set secretRef(SecretReference v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSecretRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearSecretRef() => clearField(3);
  @$pb.TagNumber(3)
  SecretReference ensureSecretRef() => $_ensure(2);

  /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);

  /// options is Optional: this field holds extra command options if any.
  /// +optional
  @$pb.TagNumber(5)
  $core.Map<$core.String, $core.String> get options => $_getMap(4);
}

/// FlexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
class FlexVolumeSource extends $pb.GeneratedMessage {
  factory FlexVolumeSource({
    $core.String? driver,
    $core.String? fsType,
    LocalObjectReference? secretRef,
    $core.bool? readOnly,
    $core.Map<$core.String, $core.String>? options,
  }) {
    final $result = create();
    if (driver != null) {
      $result.driver = driver;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (options != null) {
      $result.options.addAll(options);
    }
    return $result;
  }
  FlexVolumeSource._() : super();
  factory FlexVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory FlexVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'FlexVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'driver')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOM<LocalObjectReference>(3, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..m<$core.String, $core.String>(5, _omitFieldNames ? '' : 'options', entryClassName: 'FlexVolumeSource.OptionsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  FlexVolumeSource clone() => FlexVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  FlexVolumeSource copyWith(void Function(FlexVolumeSource) updates) => super.copyWith((message) => updates(message as FlexVolumeSource)) as FlexVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static FlexVolumeSource create() => FlexVolumeSource._();
  FlexVolumeSource createEmptyInstance() => create();
  static $pb.PbList<FlexVolumeSource> createRepeated() => $pb.PbList<FlexVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static FlexVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<FlexVolumeSource>(create);
  static FlexVolumeSource? _defaultInstance;

  /// driver is the name of the driver to use for this volume.
  @$pb.TagNumber(1)
  $core.String get driver => $_getSZ(0);
  @$pb.TagNumber(1)
  set driver($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDriver() => $_has(0);
  @$pb.TagNumber(1)
  void clearDriver() => clearField(1);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// secretRef is Optional: secretRef is reference to the secret object containing
  /// sensitive information to pass to the plugin scripts. This may be
  /// empty if no secret object is specified. If the secret object
  /// contains more than one secret, all secrets are passed to the plugin
  /// scripts.
  /// +optional
  @$pb.TagNumber(3)
  LocalObjectReference get secretRef => $_getN(2);
  @$pb.TagNumber(3)
  set secretRef(LocalObjectReference v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSecretRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearSecretRef() => clearField(3);
  @$pb.TagNumber(3)
  LocalObjectReference ensureSecretRef() => $_ensure(2);

  /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);

  /// options is Optional: this field holds extra command options if any.
  /// +optional
  @$pb.TagNumber(5)
  $core.Map<$core.String, $core.String> get options => $_getMap(4);
}

/// Represents a Flocker volume mounted by the Flocker agent.
/// One and only one of datasetName and datasetUUID should be set.
/// Flocker volumes do not support ownership management or SELinux relabeling.
class FlockerVolumeSource extends $pb.GeneratedMessage {
  factory FlockerVolumeSource({
    $core.String? datasetName,
    $core.String? datasetUUID,
  }) {
    final $result = create();
    if (datasetName != null) {
      $result.datasetName = datasetName;
    }
    if (datasetUUID != null) {
      $result.datasetUUID = datasetUUID;
    }
    return $result;
  }
  FlockerVolumeSource._() : super();
  factory FlockerVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory FlockerVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'FlockerVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'datasetName', protoName: 'datasetName')
    ..aOS(2, _omitFieldNames ? '' : 'datasetUUID', protoName: 'datasetUUID')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  FlockerVolumeSource clone() => FlockerVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  FlockerVolumeSource copyWith(void Function(FlockerVolumeSource) updates) => super.copyWith((message) => updates(message as FlockerVolumeSource)) as FlockerVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static FlockerVolumeSource create() => FlockerVolumeSource._();
  FlockerVolumeSource createEmptyInstance() => create();
  static $pb.PbList<FlockerVolumeSource> createRepeated() => $pb.PbList<FlockerVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static FlockerVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<FlockerVolumeSource>(create);
  static FlockerVolumeSource? _defaultInstance;

  /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
  /// should be considered as deprecated
  /// +optional
  @$pb.TagNumber(1)
  $core.String get datasetName => $_getSZ(0);
  @$pb.TagNumber(1)
  set datasetName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasDatasetName() => $_has(0);
  @$pb.TagNumber(1)
  void clearDatasetName() => clearField(1);

  /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
  /// +optional
  @$pb.TagNumber(2)
  $core.String get datasetUUID => $_getSZ(1);
  @$pb.TagNumber(2)
  set datasetUUID($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDatasetUUID() => $_has(1);
  @$pb.TagNumber(2)
  void clearDatasetUUID() => clearField(2);
}

///  Represents a Persistent Disk resource in Google Compute Engine.
///
///  A GCE PD must exist before mounting to a container. The disk must
///  also be in the same GCE project and zone as the kubelet. A GCE PD
///  can only be mounted as read/write once or read-only many times. GCE
///  PDs support ownership management and SELinux relabeling.
class GCEPersistentDiskVolumeSource extends $pb.GeneratedMessage {
  factory GCEPersistentDiskVolumeSource({
    $core.String? pdName,
    $core.String? fsType,
    $core.int? partition,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (pdName != null) {
      $result.pdName = pdName;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (partition != null) {
      $result.partition = partition;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  GCEPersistentDiskVolumeSource._() : super();
  factory GCEPersistentDiskVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory GCEPersistentDiskVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'GCEPersistentDiskVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'pdName', protoName: 'pdName')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'partition', $pb.PbFieldType.O3)
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  GCEPersistentDiskVolumeSource clone() => GCEPersistentDiskVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  GCEPersistentDiskVolumeSource copyWith(void Function(GCEPersistentDiskVolumeSource) updates) => super.copyWith((message) => updates(message as GCEPersistentDiskVolumeSource)) as GCEPersistentDiskVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static GCEPersistentDiskVolumeSource create() => GCEPersistentDiskVolumeSource._();
  GCEPersistentDiskVolumeSource createEmptyInstance() => create();
  static $pb.PbList<GCEPersistentDiskVolumeSource> createRepeated() => $pb.PbList<GCEPersistentDiskVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static GCEPersistentDiskVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<GCEPersistentDiskVolumeSource>(create);
  static GCEPersistentDiskVolumeSource? _defaultInstance;

  /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  @$pb.TagNumber(1)
  $core.String get pdName => $_getSZ(0);
  @$pb.TagNumber(1)
  set pdName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPdName() => $_has(0);
  @$pb.TagNumber(1)
  void clearPdName() => clearField(1);

  /// fsType is filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// partition is the partition in the volume that you want to mount.
  /// If omitted, the default is to mount by volume name.
  /// Examples: For volume /dev/sda1, you specify the partition as "1".
  /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  @$pb.TagNumber(3)
  $core.int get partition => $_getIZ(2);
  @$pb.TagNumber(3)
  set partition($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPartition() => $_has(2);
  @$pb.TagNumber(3)
  void clearPartition() => clearField(3);

  /// readOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);
}

class GRPCAction extends $pb.GeneratedMessage {
  factory GRPCAction({
    $core.int? port,
    $core.String? service,
  }) {
    final $result = create();
    if (port != null) {
      $result.port = port;
    }
    if (service != null) {
      $result.service = service;
    }
    return $result;
  }
  GRPCAction._() : super();
  factory GRPCAction.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory GRPCAction.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'GRPCAction', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'port', $pb.PbFieldType.O3)
    ..aOS(2, _omitFieldNames ? '' : 'service')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  GRPCAction clone() => GRPCAction()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  GRPCAction copyWith(void Function(GRPCAction) updates) => super.copyWith((message) => updates(message as GRPCAction)) as GRPCAction;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static GRPCAction create() => GRPCAction._();
  GRPCAction createEmptyInstance() => create();
  static $pb.PbList<GRPCAction> createRepeated() => $pb.PbList<GRPCAction>();
  @$core.pragma('dart2js:noInline')
  static GRPCAction getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<GRPCAction>(create);
  static GRPCAction? _defaultInstance;

  /// Port number of the gRPC service. Number must be in the range 1 to 65535.
  @$pb.TagNumber(1)
  $core.int get port => $_getIZ(0);
  @$pb.TagNumber(1)
  set port($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPort() => $_has(0);
  @$pb.TagNumber(1)
  void clearPort() => clearField(1);

  ///  Service is the name of the service to place in the gRPC HealthCheckRequest
  ///  (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  ///
  ///  If this is not specified, the default behavior is defined by gRPC.
  ///  +optional
  ///  +default=""
  @$pb.TagNumber(2)
  $core.String get service => $_getSZ(1);
  @$pb.TagNumber(2)
  set service($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasService() => $_has(1);
  @$pb.TagNumber(2)
  void clearService() => clearField(2);
}

///  Represents a volume that is populated with the contents of a git repository.
///  Git repo volumes do not support ownership management.
///  Git repo volumes support SELinux relabeling.
///
///  DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
///  EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
///  into the Pod's container.
class GitRepoVolumeSource extends $pb.GeneratedMessage {
  factory GitRepoVolumeSource({
    $core.String? repository,
    $core.String? revision,
    $core.String? directory,
  }) {
    final $result = create();
    if (repository != null) {
      $result.repository = repository;
    }
    if (revision != null) {
      $result.revision = revision;
    }
    if (directory != null) {
      $result.directory = directory;
    }
    return $result;
  }
  GitRepoVolumeSource._() : super();
  factory GitRepoVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory GitRepoVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'GitRepoVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'repository')
    ..aOS(2, _omitFieldNames ? '' : 'revision')
    ..aOS(3, _omitFieldNames ? '' : 'directory')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  GitRepoVolumeSource clone() => GitRepoVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  GitRepoVolumeSource copyWith(void Function(GitRepoVolumeSource) updates) => super.copyWith((message) => updates(message as GitRepoVolumeSource)) as GitRepoVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static GitRepoVolumeSource create() => GitRepoVolumeSource._();
  GitRepoVolumeSource createEmptyInstance() => create();
  static $pb.PbList<GitRepoVolumeSource> createRepeated() => $pb.PbList<GitRepoVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static GitRepoVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<GitRepoVolumeSource>(create);
  static GitRepoVolumeSource? _defaultInstance;

  /// repository is the URL
  @$pb.TagNumber(1)
  $core.String get repository => $_getSZ(0);
  @$pb.TagNumber(1)
  set repository($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasRepository() => $_has(0);
  @$pb.TagNumber(1)
  void clearRepository() => clearField(1);

  /// revision is the commit hash for the specified revision.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get revision => $_getSZ(1);
  @$pb.TagNumber(2)
  set revision($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasRevision() => $_has(1);
  @$pb.TagNumber(2)
  void clearRevision() => clearField(2);

  /// directory is the target directory name.
  /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  /// git repository.  Otherwise, if specified, the volume will contain the git repository in
  /// the subdirectory with the given name.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get directory => $_getSZ(2);
  @$pb.TagNumber(3)
  set directory($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasDirectory() => $_has(2);
  @$pb.TagNumber(3)
  void clearDirectory() => clearField(3);
}

/// Represents a Glusterfs mount that lasts the lifetime of a pod.
/// Glusterfs volumes do not support ownership management or SELinux relabeling.
class GlusterfsPersistentVolumeSource extends $pb.GeneratedMessage {
  factory GlusterfsPersistentVolumeSource({
    $core.String? endpoints,
    $core.String? path,
    $core.bool? readOnly,
    $core.String? endpointsNamespace,
  }) {
    final $result = create();
    if (endpoints != null) {
      $result.endpoints = endpoints;
    }
    if (path != null) {
      $result.path = path;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (endpointsNamespace != null) {
      $result.endpointsNamespace = endpointsNamespace;
    }
    return $result;
  }
  GlusterfsPersistentVolumeSource._() : super();
  factory GlusterfsPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory GlusterfsPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'GlusterfsPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'endpoints')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(4, _omitFieldNames ? '' : 'endpointsNamespace', protoName: 'endpointsNamespace')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  GlusterfsPersistentVolumeSource clone() => GlusterfsPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  GlusterfsPersistentVolumeSource copyWith(void Function(GlusterfsPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as GlusterfsPersistentVolumeSource)) as GlusterfsPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static GlusterfsPersistentVolumeSource create() => GlusterfsPersistentVolumeSource._();
  GlusterfsPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<GlusterfsPersistentVolumeSource> createRepeated() => $pb.PbList<GlusterfsPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static GlusterfsPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<GlusterfsPersistentVolumeSource>(create);
  static GlusterfsPersistentVolumeSource? _defaultInstance;

  /// endpoints is the endpoint name that details Glusterfs topology.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  @$pb.TagNumber(1)
  $core.String get endpoints => $_getSZ(0);
  @$pb.TagNumber(1)
  set endpoints($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasEndpoints() => $_has(0);
  @$pb.TagNumber(1)
  void clearEndpoints() => clearField(1);

  /// path is the Glusterfs volume path.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// endpointsNamespace is the namespace that contains Glusterfs endpoint.
  /// If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  @$pb.TagNumber(4)
  $core.String get endpointsNamespace => $_getSZ(3);
  @$pb.TagNumber(4)
  set endpointsNamespace($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasEndpointsNamespace() => $_has(3);
  @$pb.TagNumber(4)
  void clearEndpointsNamespace() => clearField(4);
}

/// Represents a Glusterfs mount that lasts the lifetime of a pod.
/// Glusterfs volumes do not support ownership management or SELinux relabeling.
class GlusterfsVolumeSource extends $pb.GeneratedMessage {
  factory GlusterfsVolumeSource({
    $core.String? endpoints,
    $core.String? path,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (endpoints != null) {
      $result.endpoints = endpoints;
    }
    if (path != null) {
      $result.path = path;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  GlusterfsVolumeSource._() : super();
  factory GlusterfsVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory GlusterfsVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'GlusterfsVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'endpoints')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  GlusterfsVolumeSource clone() => GlusterfsVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  GlusterfsVolumeSource copyWith(void Function(GlusterfsVolumeSource) updates) => super.copyWith((message) => updates(message as GlusterfsVolumeSource)) as GlusterfsVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static GlusterfsVolumeSource create() => GlusterfsVolumeSource._();
  GlusterfsVolumeSource createEmptyInstance() => create();
  static $pb.PbList<GlusterfsVolumeSource> createRepeated() => $pb.PbList<GlusterfsVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static GlusterfsVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<GlusterfsVolumeSource>(create);
  static GlusterfsVolumeSource? _defaultInstance;

  /// endpoints is the endpoint name that details Glusterfs topology.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  @$pb.TagNumber(1)
  $core.String get endpoints => $_getSZ(0);
  @$pb.TagNumber(1)
  set endpoints($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasEndpoints() => $_has(0);
  @$pb.TagNumber(1)
  void clearEndpoints() => clearField(1);

  /// path is the Glusterfs volume path.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);
}

/// HTTPGetAction describes an action based on HTTP Get requests.
class HTTPGetAction extends $pb.GeneratedMessage {
  factory HTTPGetAction({
    $core.String? path,
    $2.IntOrString? port,
    $core.String? host,
    $core.String? scheme,
    $core.Iterable<HTTPHeader>? httpHeaders,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    if (port != null) {
      $result.port = port;
    }
    if (host != null) {
      $result.host = host;
    }
    if (scheme != null) {
      $result.scheme = scheme;
    }
    if (httpHeaders != null) {
      $result.httpHeaders.addAll(httpHeaders);
    }
    return $result;
  }
  HTTPGetAction._() : super();
  factory HTTPGetAction.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory HTTPGetAction.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'HTTPGetAction', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..aOM<$2.IntOrString>(2, _omitFieldNames ? '' : 'port', subBuilder: $2.IntOrString.create)
    ..aOS(3, _omitFieldNames ? '' : 'host')
    ..aOS(4, _omitFieldNames ? '' : 'scheme')
    ..pc<HTTPHeader>(5, _omitFieldNames ? '' : 'httpHeaders', $pb.PbFieldType.PM, protoName: 'httpHeaders', subBuilder: HTTPHeader.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  HTTPGetAction clone() => HTTPGetAction()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  HTTPGetAction copyWith(void Function(HTTPGetAction) updates) => super.copyWith((message) => updates(message as HTTPGetAction)) as HTTPGetAction;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static HTTPGetAction create() => HTTPGetAction._();
  HTTPGetAction createEmptyInstance() => create();
  static $pb.PbList<HTTPGetAction> createRepeated() => $pb.PbList<HTTPGetAction>();
  @$core.pragma('dart2js:noInline')
  static HTTPGetAction getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<HTTPGetAction>(create);
  static HTTPGetAction? _defaultInstance;

  /// Path to access on the HTTP server.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);

  /// Name or number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  /// Name must be an IANA_SVC_NAME.
  @$pb.TagNumber(2)
  $2.IntOrString get port => $_getN(1);
  @$pb.TagNumber(2)
  set port($2.IntOrString v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPort() => $_has(1);
  @$pb.TagNumber(2)
  void clearPort() => clearField(2);
  @$pb.TagNumber(2)
  $2.IntOrString ensurePort() => $_ensure(1);

  /// Host name to connect to, defaults to the pod IP. You probably want to set
  /// "Host" in httpHeaders instead.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get host => $_getSZ(2);
  @$pb.TagNumber(3)
  set host($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasHost() => $_has(2);
  @$pb.TagNumber(3)
  void clearHost() => clearField(3);

  /// Scheme to use for connecting to the host.
  /// Defaults to HTTP.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get scheme => $_getSZ(3);
  @$pb.TagNumber(4)
  set scheme($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasScheme() => $_has(3);
  @$pb.TagNumber(4)
  void clearScheme() => clearField(4);

  /// Custom headers to set in the request. HTTP allows repeated headers.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(5)
  $core.List<HTTPHeader> get httpHeaders => $_getList(4);
}

/// HTTPHeader describes a custom header to be used in HTTP probes
class HTTPHeader extends $pb.GeneratedMessage {
  factory HTTPHeader({
    $core.String? name,
    $core.String? value,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (value != null) {
      $result.value = value;
    }
    return $result;
  }
  HTTPHeader._() : super();
  factory HTTPHeader.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory HTTPHeader.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'HTTPHeader', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'value')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  HTTPHeader clone() => HTTPHeader()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  HTTPHeader copyWith(void Function(HTTPHeader) updates) => super.copyWith((message) => updates(message as HTTPHeader)) as HTTPHeader;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static HTTPHeader create() => HTTPHeader._();
  HTTPHeader createEmptyInstance() => create();
  static $pb.PbList<HTTPHeader> createRepeated() => $pb.PbList<HTTPHeader>();
  @$core.pragma('dart2js:noInline')
  static HTTPHeader getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<HTTPHeader>(create);
  static HTTPHeader? _defaultInstance;

  /// The header field name.
  /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// The header field value
  @$pb.TagNumber(2)
  $core.String get value => $_getSZ(1);
  @$pb.TagNumber(2)
  set value($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasValue() => $_has(1);
  @$pb.TagNumber(2)
  void clearValue() => clearField(2);
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
class HostAlias extends $pb.GeneratedMessage {
  factory HostAlias({
    $core.String? ip,
    $core.Iterable<$core.String>? hostnames,
  }) {
    final $result = create();
    if (ip != null) {
      $result.ip = ip;
    }
    if (hostnames != null) {
      $result.hostnames.addAll(hostnames);
    }
    return $result;
  }
  HostAlias._() : super();
  factory HostAlias.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory HostAlias.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'HostAlias', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'ip')
    ..pPS(2, _omitFieldNames ? '' : 'hostnames')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  HostAlias clone() => HostAlias()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  HostAlias copyWith(void Function(HostAlias) updates) => super.copyWith((message) => updates(message as HostAlias)) as HostAlias;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static HostAlias create() => HostAlias._();
  HostAlias createEmptyInstance() => create();
  static $pb.PbList<HostAlias> createRepeated() => $pb.PbList<HostAlias>();
  @$core.pragma('dart2js:noInline')
  static HostAlias getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<HostAlias>(create);
  static HostAlias? _defaultInstance;

  /// IP address of the host file entry.
  /// +required
  @$pb.TagNumber(1)
  $core.String get ip => $_getSZ(0);
  @$pb.TagNumber(1)
  set ip($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIp() => $_has(0);
  @$pb.TagNumber(1)
  void clearIp() => clearField(1);

  /// Hostnames for the above IP address.
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get hostnames => $_getList(1);
}

/// HostIP represents a single IP address allocated to the host.
class HostIP extends $pb.GeneratedMessage {
  factory HostIP({
    $core.String? ip,
  }) {
    final $result = create();
    if (ip != null) {
      $result.ip = ip;
    }
    return $result;
  }
  HostIP._() : super();
  factory HostIP.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory HostIP.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'HostIP', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'ip')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  HostIP clone() => HostIP()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  HostIP copyWith(void Function(HostIP) updates) => super.copyWith((message) => updates(message as HostIP)) as HostIP;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static HostIP create() => HostIP._();
  HostIP createEmptyInstance() => create();
  static $pb.PbList<HostIP> createRepeated() => $pb.PbList<HostIP>();
  @$core.pragma('dart2js:noInline')
  static HostIP getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<HostIP>(create);
  static HostIP? _defaultInstance;

  /// IP is the IP address assigned to the host
  @$pb.TagNumber(1)
  $core.String get ip => $_getSZ(0);
  @$pb.TagNumber(1)
  set ip($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIp() => $_has(0);
  @$pb.TagNumber(1)
  void clearIp() => clearField(1);
}

/// Represents a host path mapped into a pod.
/// Host path volumes do not support ownership management or SELinux relabeling.
class HostPathVolumeSource extends $pb.GeneratedMessage {
  factory HostPathVolumeSource({
    $core.String? path,
    $core.String? type,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    if (type != null) {
      $result.type = type;
    }
    return $result;
  }
  HostPathVolumeSource._() : super();
  factory HostPathVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory HostPathVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'HostPathVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..aOS(2, _omitFieldNames ? '' : 'type')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  HostPathVolumeSource clone() => HostPathVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  HostPathVolumeSource copyWith(void Function(HostPathVolumeSource) updates) => super.copyWith((message) => updates(message as HostPathVolumeSource)) as HostPathVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static HostPathVolumeSource create() => HostPathVolumeSource._();
  HostPathVolumeSource createEmptyInstance() => create();
  static $pb.PbList<HostPathVolumeSource> createRepeated() => $pb.PbList<HostPathVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static HostPathVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<HostPathVolumeSource>(create);
  static HostPathVolumeSource? _defaultInstance;

  /// path of the directory on the host.
  /// If the path is a symlink, it will follow the link to the real path.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);

  /// type for HostPath Volume
  /// Defaults to ""
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// +optional
  @$pb.TagNumber(2)
  $core.String get type => $_getSZ(1);
  @$pb.TagNumber(2)
  set type($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasType() => $_has(1);
  @$pb.TagNumber(2)
  void clearType() => clearField(2);
}

/// ISCSIPersistentVolumeSource represents an ISCSI disk.
/// ISCSI volumes can only be mounted as read/write once.
/// ISCSI volumes support ownership management and SELinux relabeling.
class ISCSIPersistentVolumeSource extends $pb.GeneratedMessage {
  factory ISCSIPersistentVolumeSource({
    $core.String? targetPortal,
    $core.String? iqn,
    $core.int? lun,
    $core.String? iscsiInterface,
    $core.String? fsType,
    $core.bool? readOnly,
    $core.Iterable<$core.String>? portals,
    $core.bool? chapAuthDiscovery,
    SecretReference? secretRef,
    $core.bool? chapAuthSession,
    $core.String? initiatorName,
  }) {
    final $result = create();
    if (targetPortal != null) {
      $result.targetPortal = targetPortal;
    }
    if (iqn != null) {
      $result.iqn = iqn;
    }
    if (lun != null) {
      $result.lun = lun;
    }
    if (iscsiInterface != null) {
      $result.iscsiInterface = iscsiInterface;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (portals != null) {
      $result.portals.addAll(portals);
    }
    if (chapAuthDiscovery != null) {
      $result.chapAuthDiscovery = chapAuthDiscovery;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (chapAuthSession != null) {
      $result.chapAuthSession = chapAuthSession;
    }
    if (initiatorName != null) {
      $result.initiatorName = initiatorName;
    }
    return $result;
  }
  ISCSIPersistentVolumeSource._() : super();
  factory ISCSIPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ISCSIPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ISCSIPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'targetPortal', protoName: 'targetPortal')
    ..aOS(2, _omitFieldNames ? '' : 'iqn')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'lun', $pb.PbFieldType.O3)
    ..aOS(4, _omitFieldNames ? '' : 'iscsiInterface', protoName: 'iscsiInterface')
    ..aOS(5, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(6, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..pPS(7, _omitFieldNames ? '' : 'portals')
    ..aOB(8, _omitFieldNames ? '' : 'chapAuthDiscovery', protoName: 'chapAuthDiscovery')
    ..aOM<SecretReference>(10, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..aOB(11, _omitFieldNames ? '' : 'chapAuthSession', protoName: 'chapAuthSession')
    ..aOS(12, _omitFieldNames ? '' : 'initiatorName', protoName: 'initiatorName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ISCSIPersistentVolumeSource clone() => ISCSIPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ISCSIPersistentVolumeSource copyWith(void Function(ISCSIPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as ISCSIPersistentVolumeSource)) as ISCSIPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ISCSIPersistentVolumeSource create() => ISCSIPersistentVolumeSource._();
  ISCSIPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ISCSIPersistentVolumeSource> createRepeated() => $pb.PbList<ISCSIPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ISCSIPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ISCSIPersistentVolumeSource>(create);
  static ISCSIPersistentVolumeSource? _defaultInstance;

  /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  @$pb.TagNumber(1)
  $core.String get targetPortal => $_getSZ(0);
  @$pb.TagNumber(1)
  set targetPortal($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasTargetPortal() => $_has(0);
  @$pb.TagNumber(1)
  void clearTargetPortal() => clearField(1);

  /// iqn is Target iSCSI Qualified Name.
  @$pb.TagNumber(2)
  $core.String get iqn => $_getSZ(1);
  @$pb.TagNumber(2)
  set iqn($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasIqn() => $_has(1);
  @$pb.TagNumber(2)
  void clearIqn() => clearField(2);

  /// lun is iSCSI Target Lun number.
  @$pb.TagNumber(3)
  $core.int get lun => $_getIZ(2);
  @$pb.TagNumber(3)
  set lun($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasLun() => $_has(2);
  @$pb.TagNumber(3)
  void clearLun() => clearField(3);

  /// iscsiInterface is the interface Name that uses an iSCSI transport.
  /// Defaults to 'default' (tcp).
  /// +optional
  @$pb.TagNumber(4)
  $core.String get iscsiInterface => $_getSZ(3);
  @$pb.TagNumber(4)
  set iscsiInterface($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasIscsiInterface() => $_has(3);
  @$pb.TagNumber(4)
  void clearIscsiInterface() => clearField(4);

  /// fsType is the filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(5)
  $core.String get fsType => $_getSZ(4);
  @$pb.TagNumber(5)
  set fsType($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasFsType() => $_has(4);
  @$pb.TagNumber(5)
  void clearFsType() => clearField(5);

  /// readOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get readOnly => $_getBF(5);
  @$pb.TagNumber(6)
  set readOnly($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasReadOnly() => $_has(5);
  @$pb.TagNumber(6)
  void clearReadOnly() => clearField(6);

  /// portals is the iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(7)
  $core.List<$core.String> get portals => $_getList(6);

  /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
  /// +optional
  @$pb.TagNumber(8)
  $core.bool get chapAuthDiscovery => $_getBF(7);
  @$pb.TagNumber(8)
  set chapAuthDiscovery($core.bool v) { $_setBool(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasChapAuthDiscovery() => $_has(7);
  @$pb.TagNumber(8)
  void clearChapAuthDiscovery() => clearField(8);

  /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
  /// +optional
  @$pb.TagNumber(10)
  SecretReference get secretRef => $_getN(8);
  @$pb.TagNumber(10)
  set secretRef(SecretReference v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasSecretRef() => $_has(8);
  @$pb.TagNumber(10)
  void clearSecretRef() => clearField(10);
  @$pb.TagNumber(10)
  SecretReference ensureSecretRef() => $_ensure(8);

  /// chapAuthSession defines whether support iSCSI Session CHAP authentication
  /// +optional
  @$pb.TagNumber(11)
  $core.bool get chapAuthSession => $_getBF(9);
  @$pb.TagNumber(11)
  set chapAuthSession($core.bool v) { $_setBool(9, v); }
  @$pb.TagNumber(11)
  $core.bool hasChapAuthSession() => $_has(9);
  @$pb.TagNumber(11)
  void clearChapAuthSession() => clearField(11);

  /// initiatorName is the custom iSCSI Initiator Name.
  /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  /// <target portal>:<volume name> will be created for the connection.
  /// +optional
  @$pb.TagNumber(12)
  $core.String get initiatorName => $_getSZ(10);
  @$pb.TagNumber(12)
  set initiatorName($core.String v) { $_setString(10, v); }
  @$pb.TagNumber(12)
  $core.bool hasInitiatorName() => $_has(10);
  @$pb.TagNumber(12)
  void clearInitiatorName() => clearField(12);
}

/// Represents an ISCSI disk.
/// ISCSI volumes can only be mounted as read/write once.
/// ISCSI volumes support ownership management and SELinux relabeling.
class ISCSIVolumeSource extends $pb.GeneratedMessage {
  factory ISCSIVolumeSource({
    $core.String? targetPortal,
    $core.String? iqn,
    $core.int? lun,
    $core.String? iscsiInterface,
    $core.String? fsType,
    $core.bool? readOnly,
    $core.Iterable<$core.String>? portals,
    $core.bool? chapAuthDiscovery,
    LocalObjectReference? secretRef,
    $core.bool? chapAuthSession,
    $core.String? initiatorName,
  }) {
    final $result = create();
    if (targetPortal != null) {
      $result.targetPortal = targetPortal;
    }
    if (iqn != null) {
      $result.iqn = iqn;
    }
    if (lun != null) {
      $result.lun = lun;
    }
    if (iscsiInterface != null) {
      $result.iscsiInterface = iscsiInterface;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (portals != null) {
      $result.portals.addAll(portals);
    }
    if (chapAuthDiscovery != null) {
      $result.chapAuthDiscovery = chapAuthDiscovery;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (chapAuthSession != null) {
      $result.chapAuthSession = chapAuthSession;
    }
    if (initiatorName != null) {
      $result.initiatorName = initiatorName;
    }
    return $result;
  }
  ISCSIVolumeSource._() : super();
  factory ISCSIVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ISCSIVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ISCSIVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'targetPortal', protoName: 'targetPortal')
    ..aOS(2, _omitFieldNames ? '' : 'iqn')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'lun', $pb.PbFieldType.O3)
    ..aOS(4, _omitFieldNames ? '' : 'iscsiInterface', protoName: 'iscsiInterface')
    ..aOS(5, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(6, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..pPS(7, _omitFieldNames ? '' : 'portals')
    ..aOB(8, _omitFieldNames ? '' : 'chapAuthDiscovery', protoName: 'chapAuthDiscovery')
    ..aOM<LocalObjectReference>(10, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..aOB(11, _omitFieldNames ? '' : 'chapAuthSession', protoName: 'chapAuthSession')
    ..aOS(12, _omitFieldNames ? '' : 'initiatorName', protoName: 'initiatorName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ISCSIVolumeSource clone() => ISCSIVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ISCSIVolumeSource copyWith(void Function(ISCSIVolumeSource) updates) => super.copyWith((message) => updates(message as ISCSIVolumeSource)) as ISCSIVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ISCSIVolumeSource create() => ISCSIVolumeSource._();
  ISCSIVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ISCSIVolumeSource> createRepeated() => $pb.PbList<ISCSIVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ISCSIVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ISCSIVolumeSource>(create);
  static ISCSIVolumeSource? _defaultInstance;

  /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  @$pb.TagNumber(1)
  $core.String get targetPortal => $_getSZ(0);
  @$pb.TagNumber(1)
  set targetPortal($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasTargetPortal() => $_has(0);
  @$pb.TagNumber(1)
  void clearTargetPortal() => clearField(1);

  /// iqn is the target iSCSI Qualified Name.
  @$pb.TagNumber(2)
  $core.String get iqn => $_getSZ(1);
  @$pb.TagNumber(2)
  set iqn($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasIqn() => $_has(1);
  @$pb.TagNumber(2)
  void clearIqn() => clearField(2);

  /// lun represents iSCSI Target Lun number.
  @$pb.TagNumber(3)
  $core.int get lun => $_getIZ(2);
  @$pb.TagNumber(3)
  set lun($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasLun() => $_has(2);
  @$pb.TagNumber(3)
  void clearLun() => clearField(3);

  /// iscsiInterface is the interface Name that uses an iSCSI transport.
  /// Defaults to 'default' (tcp).
  /// +optional
  @$pb.TagNumber(4)
  $core.String get iscsiInterface => $_getSZ(3);
  @$pb.TagNumber(4)
  set iscsiInterface($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasIscsiInterface() => $_has(3);
  @$pb.TagNumber(4)
  void clearIscsiInterface() => clearField(4);

  /// fsType is the filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(5)
  $core.String get fsType => $_getSZ(4);
  @$pb.TagNumber(5)
  set fsType($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasFsType() => $_has(4);
  @$pb.TagNumber(5)
  void clearFsType() => clearField(5);

  /// readOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get readOnly => $_getBF(5);
  @$pb.TagNumber(6)
  set readOnly($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasReadOnly() => $_has(5);
  @$pb.TagNumber(6)
  void clearReadOnly() => clearField(6);

  /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(7)
  $core.List<$core.String> get portals => $_getList(6);

  /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
  /// +optional
  @$pb.TagNumber(8)
  $core.bool get chapAuthDiscovery => $_getBF(7);
  @$pb.TagNumber(8)
  set chapAuthDiscovery($core.bool v) { $_setBool(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasChapAuthDiscovery() => $_has(7);
  @$pb.TagNumber(8)
  void clearChapAuthDiscovery() => clearField(8);

  /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
  /// +optional
  @$pb.TagNumber(10)
  LocalObjectReference get secretRef => $_getN(8);
  @$pb.TagNumber(10)
  set secretRef(LocalObjectReference v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasSecretRef() => $_has(8);
  @$pb.TagNumber(10)
  void clearSecretRef() => clearField(10);
  @$pb.TagNumber(10)
  LocalObjectReference ensureSecretRef() => $_ensure(8);

  /// chapAuthSession defines whether support iSCSI Session CHAP authentication
  /// +optional
  @$pb.TagNumber(11)
  $core.bool get chapAuthSession => $_getBF(9);
  @$pb.TagNumber(11)
  set chapAuthSession($core.bool v) { $_setBool(9, v); }
  @$pb.TagNumber(11)
  $core.bool hasChapAuthSession() => $_has(9);
  @$pb.TagNumber(11)
  void clearChapAuthSession() => clearField(11);

  /// initiatorName is the custom iSCSI Initiator Name.
  /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  /// <target portal>:<volume name> will be created for the connection.
  /// +optional
  @$pb.TagNumber(12)
  $core.String get initiatorName => $_getSZ(10);
  @$pb.TagNumber(12)
  set initiatorName($core.String v) { $_setString(10, v); }
  @$pb.TagNumber(12)
  $core.bool hasInitiatorName() => $_has(10);
  @$pb.TagNumber(12)
  void clearInitiatorName() => clearField(12);
}

/// Maps a string key to a path within a volume.
class KeyToPath extends $pb.GeneratedMessage {
  factory KeyToPath({
    $core.String? key,
    $core.String? path,
    $core.int? mode,
  }) {
    final $result = create();
    if (key != null) {
      $result.key = key;
    }
    if (path != null) {
      $result.path = path;
    }
    if (mode != null) {
      $result.mode = mode;
    }
    return $result;
  }
  KeyToPath._() : super();
  factory KeyToPath.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory KeyToPath.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'KeyToPath', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'key')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'mode', $pb.PbFieldType.O3)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  KeyToPath clone() => KeyToPath()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  KeyToPath copyWith(void Function(KeyToPath) updates) => super.copyWith((message) => updates(message as KeyToPath)) as KeyToPath;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static KeyToPath create() => KeyToPath._();
  KeyToPath createEmptyInstance() => create();
  static $pb.PbList<KeyToPath> createRepeated() => $pb.PbList<KeyToPath>();
  @$core.pragma('dart2js:noInline')
  static KeyToPath getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<KeyToPath>(create);
  static KeyToPath? _defaultInstance;

  /// key is the key to project.
  @$pb.TagNumber(1)
  $core.String get key => $_getSZ(0);
  @$pb.TagNumber(1)
  set key($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKey() => $_has(0);
  @$pb.TagNumber(1)
  void clearKey() => clearField(1);

  /// path is the relative path of the file to map the key to.
  /// May not be an absolute path.
  /// May not contain the path element '..'.
  /// May not start with the string '..'.
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// mode is Optional: mode bits used to set permissions on this file.
  /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  /// If not specified, the volume defaultMode will be used.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(3)
  $core.int get mode => $_getIZ(2);
  @$pb.TagNumber(3)
  set mode($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasMode() => $_has(2);
  @$pb.TagNumber(3)
  void clearMode() => clearField(3);
}

/// Lifecycle describes actions that the management system should take in response to container lifecycle
/// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
/// until the action is complete, unless the container process fails, in which case the handler is aborted.
class Lifecycle extends $pb.GeneratedMessage {
  factory Lifecycle({
    LifecycleHandler? postStart,
    LifecycleHandler? preStop,
  }) {
    final $result = create();
    if (postStart != null) {
      $result.postStart = postStart;
    }
    if (preStop != null) {
      $result.preStop = preStop;
    }
    return $result;
  }
  Lifecycle._() : super();
  factory Lifecycle.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Lifecycle.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Lifecycle', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LifecycleHandler>(1, _omitFieldNames ? '' : 'postStart', protoName: 'postStart', subBuilder: LifecycleHandler.create)
    ..aOM<LifecycleHandler>(2, _omitFieldNames ? '' : 'preStop', protoName: 'preStop', subBuilder: LifecycleHandler.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Lifecycle clone() => Lifecycle()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Lifecycle copyWith(void Function(Lifecycle) updates) => super.copyWith((message) => updates(message as Lifecycle)) as Lifecycle;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Lifecycle create() => Lifecycle._();
  Lifecycle createEmptyInstance() => create();
  static $pb.PbList<Lifecycle> createRepeated() => $pb.PbList<Lifecycle>();
  @$core.pragma('dart2js:noInline')
  static Lifecycle getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Lifecycle>(create);
  static Lifecycle? _defaultInstance;

  /// PostStart is called immediately after a container is created. If the handler fails,
  /// the container is terminated and restarted according to its restart policy.
  /// Other management of the container blocks until the hook completes.
  /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  /// +optional
  @$pb.TagNumber(1)
  LifecycleHandler get postStart => $_getN(0);
  @$pb.TagNumber(1)
  set postStart(LifecycleHandler v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasPostStart() => $_has(0);
  @$pb.TagNumber(1)
  void clearPostStart() => clearField(1);
  @$pb.TagNumber(1)
  LifecycleHandler ensurePostStart() => $_ensure(0);

  /// PreStop is called immediately before a container is terminated due to an
  /// API request or management event such as liveness/startup probe failure,
  /// preemption, resource contention, etc. The handler is not called if the
  /// container crashes or exits. The Pod's termination grace period countdown begins before the
  /// PreStop hook is executed. Regardless of the outcome of the handler, the
  /// container will eventually terminate within the Pod's termination grace
  /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
  /// or until the termination grace period is reached.
  /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  /// +optional
  @$pb.TagNumber(2)
  LifecycleHandler get preStop => $_getN(1);
  @$pb.TagNumber(2)
  set preStop(LifecycleHandler v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPreStop() => $_has(1);
  @$pb.TagNumber(2)
  void clearPreStop() => clearField(2);
  @$pb.TagNumber(2)
  LifecycleHandler ensurePreStop() => $_ensure(1);
}

/// LifecycleHandler defines a specific action that should be taken in a lifecycle
/// hook. One and only one of the fields, except TCPSocket must be specified.
class LifecycleHandler extends $pb.GeneratedMessage {
  factory LifecycleHandler({
    ExecAction? exec,
    HTTPGetAction? httpGet,
    TCPSocketAction? tcpSocket,
    SleepAction? sleep,
  }) {
    final $result = create();
    if (exec != null) {
      $result.exec = exec;
    }
    if (httpGet != null) {
      $result.httpGet = httpGet;
    }
    if (tcpSocket != null) {
      $result.tcpSocket = tcpSocket;
    }
    if (sleep != null) {
      $result.sleep = sleep;
    }
    return $result;
  }
  LifecycleHandler._() : super();
  factory LifecycleHandler.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LifecycleHandler.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LifecycleHandler', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ExecAction>(1, _omitFieldNames ? '' : 'exec', subBuilder: ExecAction.create)
    ..aOM<HTTPGetAction>(2, _omitFieldNames ? '' : 'httpGet', protoName: 'httpGet', subBuilder: HTTPGetAction.create)
    ..aOM<TCPSocketAction>(3, _omitFieldNames ? '' : 'tcpSocket', protoName: 'tcpSocket', subBuilder: TCPSocketAction.create)
    ..aOM<SleepAction>(4, _omitFieldNames ? '' : 'sleep', subBuilder: SleepAction.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LifecycleHandler clone() => LifecycleHandler()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LifecycleHandler copyWith(void Function(LifecycleHandler) updates) => super.copyWith((message) => updates(message as LifecycleHandler)) as LifecycleHandler;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LifecycleHandler create() => LifecycleHandler._();
  LifecycleHandler createEmptyInstance() => create();
  static $pb.PbList<LifecycleHandler> createRepeated() => $pb.PbList<LifecycleHandler>();
  @$core.pragma('dart2js:noInline')
  static LifecycleHandler getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LifecycleHandler>(create);
  static LifecycleHandler? _defaultInstance;

  /// Exec specifies the action to take.
  /// +optional
  @$pb.TagNumber(1)
  ExecAction get exec => $_getN(0);
  @$pb.TagNumber(1)
  set exec(ExecAction v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasExec() => $_has(0);
  @$pb.TagNumber(1)
  void clearExec() => clearField(1);
  @$pb.TagNumber(1)
  ExecAction ensureExec() => $_ensure(0);

  /// HTTPGet specifies the http request to perform.
  /// +optional
  @$pb.TagNumber(2)
  HTTPGetAction get httpGet => $_getN(1);
  @$pb.TagNumber(2)
  set httpGet(HTTPGetAction v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasHttpGet() => $_has(1);
  @$pb.TagNumber(2)
  void clearHttpGet() => clearField(2);
  @$pb.TagNumber(2)
  HTTPGetAction ensureHttpGet() => $_ensure(1);

  /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
  /// for the backward compatibility. There are no validation of this field and
  /// lifecycle hooks will fail in runtime when tcp handler is specified.
  /// +optional
  @$pb.TagNumber(3)
  TCPSocketAction get tcpSocket => $_getN(2);
  @$pb.TagNumber(3)
  set tcpSocket(TCPSocketAction v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasTcpSocket() => $_has(2);
  @$pb.TagNumber(3)
  void clearTcpSocket() => clearField(3);
  @$pb.TagNumber(3)
  TCPSocketAction ensureTcpSocket() => $_ensure(2);

  /// Sleep represents the duration that the container should sleep before being terminated.
  /// +featureGate=PodLifecycleSleepAction
  /// +optional
  @$pb.TagNumber(4)
  SleepAction get sleep => $_getN(3);
  @$pb.TagNumber(4)
  set sleep(SleepAction v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasSleep() => $_has(3);
  @$pb.TagNumber(4)
  void clearSleep() => clearField(4);
  @$pb.TagNumber(4)
  SleepAction ensureSleep() => $_ensure(3);
}

/// LimitRange sets resource usage limits for each kind of resource in a Namespace.
class LimitRange extends $pb.GeneratedMessage {
  factory LimitRange({
    $0.ObjectMeta? metadata,
    LimitRangeSpec? spec,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    return $result;
  }
  LimitRange._() : super();
  factory LimitRange.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LimitRange.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LimitRange', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<LimitRangeSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: LimitRangeSpec.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LimitRange clone() => LimitRange()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LimitRange copyWith(void Function(LimitRange) updates) => super.copyWith((message) => updates(message as LimitRange)) as LimitRange;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LimitRange create() => LimitRange._();
  LimitRange createEmptyInstance() => create();
  static $pb.PbList<LimitRange> createRepeated() => $pb.PbList<LimitRange>();
  @$core.pragma('dart2js:noInline')
  static LimitRange getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LimitRange>(create);
  static LimitRange? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the limits enforced.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  LimitRangeSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(LimitRangeSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  LimitRangeSpec ensureSpec() => $_ensure(1);
}

/// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
class LimitRangeItem extends $pb.GeneratedMessage {
  factory LimitRangeItem({
    $core.String? type,
    $core.Map<$core.String, $1.Quantity>? max,
    $core.Map<$core.String, $1.Quantity>? min,
    $core.Map<$core.String, $1.Quantity>? default_4,
    $core.Map<$core.String, $1.Quantity>? defaultRequest,
    $core.Map<$core.String, $1.Quantity>? maxLimitRequestRatio,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (max != null) {
      $result.max.addAll(max);
    }
    if (min != null) {
      $result.min.addAll(min);
    }
    if (default_4 != null) {
      $result.default_4.addAll(default_4);
    }
    if (defaultRequest != null) {
      $result.defaultRequest.addAll(defaultRequest);
    }
    if (maxLimitRequestRatio != null) {
      $result.maxLimitRequestRatio.addAll(maxLimitRequestRatio);
    }
    return $result;
  }
  LimitRangeItem._() : super();
  factory LimitRangeItem.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LimitRangeItem.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LimitRangeItem', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..m<$core.String, $1.Quantity>(2, _omitFieldNames ? '' : 'max', entryClassName: 'LimitRangeItem.MaxEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(3, _omitFieldNames ? '' : 'min', entryClassName: 'LimitRangeItem.MinEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(4, _omitFieldNames ? '' : 'default', entryClassName: 'LimitRangeItem.DefaultEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(5, _omitFieldNames ? '' : 'defaultRequest', protoName: 'defaultRequest', entryClassName: 'LimitRangeItem.DefaultRequestEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(6, _omitFieldNames ? '' : 'maxLimitRequestRatio', protoName: 'maxLimitRequestRatio', entryClassName: 'LimitRangeItem.MaxLimitRequestRatioEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LimitRangeItem clone() => LimitRangeItem()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LimitRangeItem copyWith(void Function(LimitRangeItem) updates) => super.copyWith((message) => updates(message as LimitRangeItem)) as LimitRangeItem;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LimitRangeItem create() => LimitRangeItem._();
  LimitRangeItem createEmptyInstance() => create();
  static $pb.PbList<LimitRangeItem> createRepeated() => $pb.PbList<LimitRangeItem>();
  @$core.pragma('dart2js:noInline')
  static LimitRangeItem getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LimitRangeItem>(create);
  static LimitRangeItem? _defaultInstance;

  /// Type of resource that this limit applies to.
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Max usage constraints on this kind by resource name.
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $1.Quantity> get max => $_getMap(1);

  /// Min usage constraints on this kind by resource name.
  /// +optional
  @$pb.TagNumber(3)
  $core.Map<$core.String, $1.Quantity> get min => $_getMap(2);

  /// Default resource requirement limit value by resource name if resource limit is omitted.
  /// +optional
  @$pb.TagNumber(4)
  $core.Map<$core.String, $1.Quantity> get default_4 => $_getMap(3);

  /// DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
  /// +optional
  @$pb.TagNumber(5)
  $core.Map<$core.String, $1.Quantity> get defaultRequest => $_getMap(4);

  /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
  /// +optional
  @$pb.TagNumber(6)
  $core.Map<$core.String, $1.Quantity> get maxLimitRequestRatio => $_getMap(5);
}

/// LimitRangeList is a list of LimitRange items.
class LimitRangeList extends $pb.GeneratedMessage {
  factory LimitRangeList({
    $0.ListMeta? metadata,
    $core.Iterable<LimitRange>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  LimitRangeList._() : super();
  factory LimitRangeList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LimitRangeList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LimitRangeList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<LimitRange>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: LimitRange.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LimitRangeList clone() => LimitRangeList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LimitRangeList copyWith(void Function(LimitRangeList) updates) => super.copyWith((message) => updates(message as LimitRangeList)) as LimitRangeList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LimitRangeList create() => LimitRangeList._();
  LimitRangeList createEmptyInstance() => create();
  static $pb.PbList<LimitRangeList> createRepeated() => $pb.PbList<LimitRangeList>();
  @$core.pragma('dart2js:noInline')
  static LimitRangeList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LimitRangeList>(create);
  static LimitRangeList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// Items is a list of LimitRange objects.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  @$pb.TagNumber(2)
  $core.List<LimitRange> get items => $_getList(1);
}

/// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
class LimitRangeSpec extends $pb.GeneratedMessage {
  factory LimitRangeSpec({
    $core.Iterable<LimitRangeItem>? limits,
  }) {
    final $result = create();
    if (limits != null) {
      $result.limits.addAll(limits);
    }
    return $result;
  }
  LimitRangeSpec._() : super();
  factory LimitRangeSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LimitRangeSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LimitRangeSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<LimitRangeItem>(1, _omitFieldNames ? '' : 'limits', $pb.PbFieldType.PM, subBuilder: LimitRangeItem.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LimitRangeSpec clone() => LimitRangeSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LimitRangeSpec copyWith(void Function(LimitRangeSpec) updates) => super.copyWith((message) => updates(message as LimitRangeSpec)) as LimitRangeSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LimitRangeSpec create() => LimitRangeSpec._();
  LimitRangeSpec createEmptyInstance() => create();
  static $pb.PbList<LimitRangeSpec> createRepeated() => $pb.PbList<LimitRangeSpec>();
  @$core.pragma('dart2js:noInline')
  static LimitRangeSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LimitRangeSpec>(create);
  static LimitRangeSpec? _defaultInstance;

  /// Limits is the list of LimitRangeItem objects that are enforced.
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<LimitRangeItem> get limits => $_getList(0);
}

/// List holds a list of objects, which may not be known by the server.
class List_ extends $pb.GeneratedMessage {
  factory List_({
    $0.ListMeta? metadata,
    $core.Iterable<$3.RawExtension>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  List_._() : super();
  factory List_.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory List_.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'List', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<$3.RawExtension>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: $3.RawExtension.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  List_ clone() => List_()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  List_ copyWith(void Function(List_) updates) => super.copyWith((message) => updates(message as List_)) as List_;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static List_ create() => List_._();
  List_ createEmptyInstance() => create();
  static $pb.PbList<List_> createRepeated() => $pb.PbList<List_>();
  @$core.pragma('dart2js:noInline')
  static List_ getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<List_>(create);
  static List_? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of objects
  @$pb.TagNumber(2)
  $core.List<$3.RawExtension> get items => $_getList(1);
}

/// LoadBalancerIngress represents the status of a load-balancer ingress point:
/// traffic intended for the service should be sent to an ingress point.
class LoadBalancerIngress extends $pb.GeneratedMessage {
  factory LoadBalancerIngress({
    $core.String? ip,
    $core.String? hostname,
    $core.String? ipMode,
    $core.Iterable<PortStatus>? ports,
  }) {
    final $result = create();
    if (ip != null) {
      $result.ip = ip;
    }
    if (hostname != null) {
      $result.hostname = hostname;
    }
    if (ipMode != null) {
      $result.ipMode = ipMode;
    }
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    return $result;
  }
  LoadBalancerIngress._() : super();
  factory LoadBalancerIngress.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LoadBalancerIngress.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LoadBalancerIngress', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'ip')
    ..aOS(2, _omitFieldNames ? '' : 'hostname')
    ..aOS(3, _omitFieldNames ? '' : 'ipMode', protoName: 'ipMode')
    ..pc<PortStatus>(4, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.PM, subBuilder: PortStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LoadBalancerIngress clone() => LoadBalancerIngress()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LoadBalancerIngress copyWith(void Function(LoadBalancerIngress) updates) => super.copyWith((message) => updates(message as LoadBalancerIngress)) as LoadBalancerIngress;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LoadBalancerIngress create() => LoadBalancerIngress._();
  LoadBalancerIngress createEmptyInstance() => create();
  static $pb.PbList<LoadBalancerIngress> createRepeated() => $pb.PbList<LoadBalancerIngress>();
  @$core.pragma('dart2js:noInline')
  static LoadBalancerIngress getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LoadBalancerIngress>(create);
  static LoadBalancerIngress? _defaultInstance;

  /// IP is set for load-balancer ingress points that are IP based
  /// (typically GCE or OpenStack load-balancers)
  /// +optional
  @$pb.TagNumber(1)
  $core.String get ip => $_getSZ(0);
  @$pb.TagNumber(1)
  set ip($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIp() => $_has(0);
  @$pb.TagNumber(1)
  void clearIp() => clearField(1);

  /// Hostname is set for load-balancer ingress points that are DNS based
  /// (typically AWS load-balancers)
  /// +optional
  @$pb.TagNumber(2)
  $core.String get hostname => $_getSZ(1);
  @$pb.TagNumber(2)
  set hostname($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasHostname() => $_has(1);
  @$pb.TagNumber(2)
  void clearHostname() => clearField(2);

  /// IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.
  /// Setting this to "VIP" indicates that traffic is delivered to the node with
  /// the destination set to the load-balancer's IP and port.
  /// Setting this to "Proxy" indicates that traffic is delivered to the node or pod with
  /// the destination set to the node's IP and node port or the pod's IP and port.
  /// Service implementations may use this information to adjust traffic routing.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get ipMode => $_getSZ(2);
  @$pb.TagNumber(3)
  set ipMode($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasIpMode() => $_has(2);
  @$pb.TagNumber(3)
  void clearIpMode() => clearField(3);

  /// Ports is a list of records of service ports
  /// If used, every port defined in the service should have an entry in it
  /// +listType=atomic
  /// +optional
  @$pb.TagNumber(4)
  $core.List<PortStatus> get ports => $_getList(3);
}

/// LoadBalancerStatus represents the status of a load-balancer.
class LoadBalancerStatus extends $pb.GeneratedMessage {
  factory LoadBalancerStatus({
    $core.Iterable<LoadBalancerIngress>? ingress,
  }) {
    final $result = create();
    if (ingress != null) {
      $result.ingress.addAll(ingress);
    }
    return $result;
  }
  LoadBalancerStatus._() : super();
  factory LoadBalancerStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LoadBalancerStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LoadBalancerStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<LoadBalancerIngress>(1, _omitFieldNames ? '' : 'ingress', $pb.PbFieldType.PM, subBuilder: LoadBalancerIngress.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LoadBalancerStatus clone() => LoadBalancerStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LoadBalancerStatus copyWith(void Function(LoadBalancerStatus) updates) => super.copyWith((message) => updates(message as LoadBalancerStatus)) as LoadBalancerStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LoadBalancerStatus create() => LoadBalancerStatus._();
  LoadBalancerStatus createEmptyInstance() => create();
  static $pb.PbList<LoadBalancerStatus> createRepeated() => $pb.PbList<LoadBalancerStatus>();
  @$core.pragma('dart2js:noInline')
  static LoadBalancerStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LoadBalancerStatus>(create);
  static LoadBalancerStatus? _defaultInstance;

  /// Ingress is a list containing ingress points for the load-balancer.
  /// Traffic intended for the service should be sent to these ingress points.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<LoadBalancerIngress> get ingress => $_getList(0);
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
/// +structType=atomic
class LocalObjectReference extends $pb.GeneratedMessage {
  factory LocalObjectReference({
    $core.String? name,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    return $result;
  }
  LocalObjectReference._() : super();
  factory LocalObjectReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LocalObjectReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LocalObjectReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LocalObjectReference clone() => LocalObjectReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LocalObjectReference copyWith(void Function(LocalObjectReference) updates) => super.copyWith((message) => updates(message as LocalObjectReference)) as LocalObjectReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LocalObjectReference create() => LocalObjectReference._();
  LocalObjectReference createEmptyInstance() => create();
  static $pb.PbList<LocalObjectReference> createRepeated() => $pb.PbList<LocalObjectReference>();
  @$core.pragma('dart2js:noInline')
  static LocalObjectReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LocalObjectReference>(create);
  static LocalObjectReference? _defaultInstance;

  /// Name of the referent.
  /// This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are
  /// almost certainly wrong.
  /// TODO: Add other useful fields. apiVersion, kind, uid?
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  /// +optional
  /// +default=""
  /// +kubebuilder:default=""
  /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);
}

/// Local represents directly-attached storage with node affinity (Beta feature)
class LocalVolumeSource extends $pb.GeneratedMessage {
  factory LocalVolumeSource({
    $core.String? path,
    $core.String? fsType,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    return $result;
  }
  LocalVolumeSource._() : super();
  factory LocalVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory LocalVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'LocalVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  LocalVolumeSource clone() => LocalVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  LocalVolumeSource copyWith(void Function(LocalVolumeSource) updates) => super.copyWith((message) => updates(message as LocalVolumeSource)) as LocalVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static LocalVolumeSource create() => LocalVolumeSource._();
  LocalVolumeSource createEmptyInstance() => create();
  static $pb.PbList<LocalVolumeSource> createRepeated() => $pb.PbList<LocalVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static LocalVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<LocalVolumeSource>(create);
  static LocalVolumeSource? _defaultInstance;

  /// path of the full path to the volume on the node.
  /// It can be either a directory or block device (disk, partition, ...).
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);

  /// fsType is the filesystem type to mount.
  /// It applies only when the Path is a block device.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a filesystem if unspecified.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);
}

/// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation
class ModifyVolumeStatus extends $pb.GeneratedMessage {
  factory ModifyVolumeStatus({
    $core.String? targetVolumeAttributesClassName,
    $core.String? status,
  }) {
    final $result = create();
    if (targetVolumeAttributesClassName != null) {
      $result.targetVolumeAttributesClassName = targetVolumeAttributesClassName;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  ModifyVolumeStatus._() : super();
  factory ModifyVolumeStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ModifyVolumeStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ModifyVolumeStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'targetVolumeAttributesClassName', protoName: 'targetVolumeAttributesClassName')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ModifyVolumeStatus clone() => ModifyVolumeStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ModifyVolumeStatus copyWith(void Function(ModifyVolumeStatus) updates) => super.copyWith((message) => updates(message as ModifyVolumeStatus)) as ModifyVolumeStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ModifyVolumeStatus create() => ModifyVolumeStatus._();
  ModifyVolumeStatus createEmptyInstance() => create();
  static $pb.PbList<ModifyVolumeStatus> createRepeated() => $pb.PbList<ModifyVolumeStatus>();
  @$core.pragma('dart2js:noInline')
  static ModifyVolumeStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ModifyVolumeStatus>(create);
  static ModifyVolumeStatus? _defaultInstance;

  /// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
  @$pb.TagNumber(1)
  $core.String get targetVolumeAttributesClassName => $_getSZ(0);
  @$pb.TagNumber(1)
  set targetVolumeAttributesClassName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasTargetVolumeAttributesClassName() => $_has(0);
  @$pb.TagNumber(1)
  void clearTargetVolumeAttributesClassName() => clearField(1);

  /// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
  ///  - Pending
  ///    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
  ///    the specified VolumeAttributesClass not existing.
  ///  - InProgress
  ///    InProgress indicates that the volume is being modified.
  ///  - Infeasible
  ///   Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
  /// 	  resolve the error, a valid VolumeAttributesClass needs to be specified.
  /// Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);
}

/// Represents an NFS mount that lasts the lifetime of a pod.
/// NFS volumes do not support ownership management or SELinux relabeling.
class NFSVolumeSource extends $pb.GeneratedMessage {
  factory NFSVolumeSource({
    $core.String? server,
    $core.String? path,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (server != null) {
      $result.server = server;
    }
    if (path != null) {
      $result.path = path;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  NFSVolumeSource._() : super();
  factory NFSVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NFSVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NFSVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'server')
    ..aOS(2, _omitFieldNames ? '' : 'path')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NFSVolumeSource clone() => NFSVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NFSVolumeSource copyWith(void Function(NFSVolumeSource) updates) => super.copyWith((message) => updates(message as NFSVolumeSource)) as NFSVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NFSVolumeSource create() => NFSVolumeSource._();
  NFSVolumeSource createEmptyInstance() => create();
  static $pb.PbList<NFSVolumeSource> createRepeated() => $pb.PbList<NFSVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static NFSVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NFSVolumeSource>(create);
  static NFSVolumeSource? _defaultInstance;

  /// server is the hostname or IP address of the NFS server.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  @$pb.TagNumber(1)
  $core.String get server => $_getSZ(0);
  @$pb.TagNumber(1)
  set server($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasServer() => $_has(0);
  @$pb.TagNumber(1)
  void clearServer() => clearField(1);

  /// path that is exported by the NFS server.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  @$pb.TagNumber(2)
  $core.String get path => $_getSZ(1);
  @$pb.TagNumber(2)
  set path($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearPath() => clearField(2);

  /// readOnly here will force the NFS export to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);
}

/// Namespace provides a scope for Names.
/// Use of multiple namespaces is optional.
class Namespace extends $pb.GeneratedMessage {
  factory Namespace({
    $0.ObjectMeta? metadata,
    NamespaceSpec? spec,
    NamespaceStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  Namespace._() : super();
  factory Namespace.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Namespace.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Namespace', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<NamespaceSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: NamespaceSpec.create)
    ..aOM<NamespaceStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: NamespaceStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Namespace clone() => Namespace()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Namespace copyWith(void Function(Namespace) updates) => super.copyWith((message) => updates(message as Namespace)) as Namespace;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Namespace create() => Namespace._();
  Namespace createEmptyInstance() => create();
  static $pb.PbList<Namespace> createRepeated() => $pb.PbList<Namespace>();
  @$core.pragma('dart2js:noInline')
  static Namespace getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Namespace>(create);
  static Namespace? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the behavior of the Namespace.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  NamespaceSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(NamespaceSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  NamespaceSpec ensureSpec() => $_ensure(1);

  /// Status describes the current status of a Namespace.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  NamespaceStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(NamespaceStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  NamespaceStatus ensureStatus() => $_ensure(2);
}

/// NamespaceCondition contains details about state of namespace.
class NamespaceCondition extends $pb.GeneratedMessage {
  factory NamespaceCondition({
    $core.String? type,
    $core.String? status,
    $0.Time? lastTransitionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (lastTransitionTime != null) {
      $result.lastTransitionTime = lastTransitionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  NamespaceCondition._() : super();
  factory NamespaceCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NamespaceCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NamespaceCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'lastTransitionTime', protoName: 'lastTransitionTime', subBuilder: $0.Time.create)
    ..aOS(5, _omitFieldNames ? '' : 'reason')
    ..aOS(6, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NamespaceCondition clone() => NamespaceCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NamespaceCondition copyWith(void Function(NamespaceCondition) updates) => super.copyWith((message) => updates(message as NamespaceCondition)) as NamespaceCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NamespaceCondition create() => NamespaceCondition._();
  NamespaceCondition createEmptyInstance() => create();
  static $pb.PbList<NamespaceCondition> createRepeated() => $pb.PbList<NamespaceCondition>();
  @$core.pragma('dart2js:noInline')
  static NamespaceCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NamespaceCondition>(create);
  static NamespaceCondition? _defaultInstance;

  /// Type of namespace controller condition.
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Status of the condition, one of True, False, Unknown.
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// +optional
  @$pb.TagNumber(4)
  $0.Time get lastTransitionTime => $_getN(2);
  @$pb.TagNumber(4)
  set lastTransitionTime($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLastTransitionTime() => $_has(2);
  @$pb.TagNumber(4)
  void clearLastTransitionTime() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureLastTransitionTime() => $_ensure(2);

  /// +optional
  @$pb.TagNumber(5)
  $core.String get reason => $_getSZ(3);
  @$pb.TagNumber(5)
  set reason($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(5)
  $core.bool hasReason() => $_has(3);
  @$pb.TagNumber(5)
  void clearReason() => clearField(5);

  /// +optional
  @$pb.TagNumber(6)
  $core.String get message => $_getSZ(4);
  @$pb.TagNumber(6)
  set message($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(6)
  $core.bool hasMessage() => $_has(4);
  @$pb.TagNumber(6)
  void clearMessage() => clearField(6);
}

/// NamespaceList is a list of Namespaces.
class NamespaceList extends $pb.GeneratedMessage {
  factory NamespaceList({
    $0.ListMeta? metadata,
    $core.Iterable<Namespace>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  NamespaceList._() : super();
  factory NamespaceList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NamespaceList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NamespaceList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Namespace>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Namespace.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NamespaceList clone() => NamespaceList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NamespaceList copyWith(void Function(NamespaceList) updates) => super.copyWith((message) => updates(message as NamespaceList)) as NamespaceList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NamespaceList create() => NamespaceList._();
  NamespaceList createEmptyInstance() => create();
  static $pb.PbList<NamespaceList> createRepeated() => $pb.PbList<NamespaceList>();
  @$core.pragma('dart2js:noInline')
  static NamespaceList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NamespaceList>(create);
  static NamespaceList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// Items is the list of Namespace objects in the list.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  @$pb.TagNumber(2)
  $core.List<Namespace> get items => $_getList(1);
}

/// NamespaceSpec describes the attributes on a Namespace.
class NamespaceSpec extends $pb.GeneratedMessage {
  factory NamespaceSpec({
    $core.Iterable<$core.String>? finalizers,
  }) {
    final $result = create();
    if (finalizers != null) {
      $result.finalizers.addAll(finalizers);
    }
    return $result;
  }
  NamespaceSpec._() : super();
  factory NamespaceSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NamespaceSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NamespaceSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'finalizers')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NamespaceSpec clone() => NamespaceSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NamespaceSpec copyWith(void Function(NamespaceSpec) updates) => super.copyWith((message) => updates(message as NamespaceSpec)) as NamespaceSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NamespaceSpec create() => NamespaceSpec._();
  NamespaceSpec createEmptyInstance() => create();
  static $pb.PbList<NamespaceSpec> createRepeated() => $pb.PbList<NamespaceSpec>();
  @$core.pragma('dart2js:noInline')
  static NamespaceSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NamespaceSpec>(create);
  static NamespaceSpec? _defaultInstance;

  /// Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
  /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get finalizers => $_getList(0);
}

/// NamespaceStatus is information about the current status of a Namespace.
class NamespaceStatus extends $pb.GeneratedMessage {
  factory NamespaceStatus({
    $core.String? phase,
    $core.Iterable<NamespaceCondition>? conditions,
  }) {
    final $result = create();
    if (phase != null) {
      $result.phase = phase;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    return $result;
  }
  NamespaceStatus._() : super();
  factory NamespaceStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NamespaceStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NamespaceStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'phase')
    ..pc<NamespaceCondition>(2, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: NamespaceCondition.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NamespaceStatus clone() => NamespaceStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NamespaceStatus copyWith(void Function(NamespaceStatus) updates) => super.copyWith((message) => updates(message as NamespaceStatus)) as NamespaceStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NamespaceStatus create() => NamespaceStatus._();
  NamespaceStatus createEmptyInstance() => create();
  static $pb.PbList<NamespaceStatus> createRepeated() => $pb.PbList<NamespaceStatus>();
  @$core.pragma('dart2js:noInline')
  static NamespaceStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NamespaceStatus>(create);
  static NamespaceStatus? _defaultInstance;

  /// Phase is the current lifecycle phase of the namespace.
  /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  /// +optional
  @$pb.TagNumber(1)
  $core.String get phase => $_getSZ(0);
  @$pb.TagNumber(1)
  set phase($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPhase() => $_has(0);
  @$pb.TagNumber(1)
  void clearPhase() => clearField(1);

  /// Represents the latest available observations of a namespace's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(2)
  $core.List<NamespaceCondition> get conditions => $_getList(1);
}

/// Node is a worker node in Kubernetes.
/// Each node will have a unique identifier in the cache (i.e. in etcd).
class Node extends $pb.GeneratedMessage {
  factory Node({
    $0.ObjectMeta? metadata,
    NodeSpec? spec,
    NodeStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  Node._() : super();
  factory Node.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Node.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Node', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<NodeSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: NodeSpec.create)
    ..aOM<NodeStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: NodeStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Node clone() => Node()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Node copyWith(void Function(Node) updates) => super.copyWith((message) => updates(message as Node)) as Node;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Node create() => Node._();
  Node createEmptyInstance() => create();
  static $pb.PbList<Node> createRepeated() => $pb.PbList<Node>();
  @$core.pragma('dart2js:noInline')
  static Node getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Node>(create);
  static Node? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the behavior of a node.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  NodeSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(NodeSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  NodeSpec ensureSpec() => $_ensure(1);

  /// Most recently observed status of the node.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  NodeStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(NodeStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  NodeStatus ensureStatus() => $_ensure(2);
}

/// NodeAddress contains information for the node's address.
class NodeAddress extends $pb.GeneratedMessage {
  factory NodeAddress({
    $core.String? type,
    $core.String? address,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (address != null) {
      $result.address = address;
    }
    return $result;
  }
  NodeAddress._() : super();
  factory NodeAddress.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeAddress.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeAddress', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'address')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeAddress clone() => NodeAddress()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeAddress copyWith(void Function(NodeAddress) updates) => super.copyWith((message) => updates(message as NodeAddress)) as NodeAddress;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeAddress create() => NodeAddress._();
  NodeAddress createEmptyInstance() => create();
  static $pb.PbList<NodeAddress> createRepeated() => $pb.PbList<NodeAddress>();
  @$core.pragma('dart2js:noInline')
  static NodeAddress getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeAddress>(create);
  static NodeAddress? _defaultInstance;

  /// Node address type, one of Hostname, ExternalIP or InternalIP.
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// The node address.
  @$pb.TagNumber(2)
  $core.String get address => $_getSZ(1);
  @$pb.TagNumber(2)
  set address($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasAddress() => $_has(1);
  @$pb.TagNumber(2)
  void clearAddress() => clearField(2);
}

/// Node affinity is a group of node affinity scheduling rules.
class NodeAffinity extends $pb.GeneratedMessage {
  factory NodeAffinity({
    NodeSelector? requiredDuringSchedulingIgnoredDuringExecution,
    $core.Iterable<PreferredSchedulingTerm>? preferredDuringSchedulingIgnoredDuringExecution,
  }) {
    final $result = create();
    if (requiredDuringSchedulingIgnoredDuringExecution != null) {
      $result.requiredDuringSchedulingIgnoredDuringExecution = requiredDuringSchedulingIgnoredDuringExecution;
    }
    if (preferredDuringSchedulingIgnoredDuringExecution != null) {
      $result.preferredDuringSchedulingIgnoredDuringExecution.addAll(preferredDuringSchedulingIgnoredDuringExecution);
    }
    return $result;
  }
  NodeAffinity._() : super();
  factory NodeAffinity.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeAffinity.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeAffinity', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<NodeSelector>(1, _omitFieldNames ? '' : 'requiredDuringSchedulingIgnoredDuringExecution', protoName: 'requiredDuringSchedulingIgnoredDuringExecution', subBuilder: NodeSelector.create)
    ..pc<PreferredSchedulingTerm>(2, _omitFieldNames ? '' : 'preferredDuringSchedulingIgnoredDuringExecution', $pb.PbFieldType.PM, protoName: 'preferredDuringSchedulingIgnoredDuringExecution', subBuilder: PreferredSchedulingTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeAffinity clone() => NodeAffinity()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeAffinity copyWith(void Function(NodeAffinity) updates) => super.copyWith((message) => updates(message as NodeAffinity)) as NodeAffinity;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeAffinity create() => NodeAffinity._();
  NodeAffinity createEmptyInstance() => create();
  static $pb.PbList<NodeAffinity> createRepeated() => $pb.PbList<NodeAffinity>();
  @$core.pragma('dart2js:noInline')
  static NodeAffinity getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeAffinity>(create);
  static NodeAffinity? _defaultInstance;

  /// If the affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to an update), the system
  /// may or may not try to eventually evict the pod from its node.
  /// +optional
  @$pb.TagNumber(1)
  NodeSelector get requiredDuringSchedulingIgnoredDuringExecution => $_getN(0);
  @$pb.TagNumber(1)
  set requiredDuringSchedulingIgnoredDuringExecution(NodeSelector v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasRequiredDuringSchedulingIgnoredDuringExecution() => $_has(0);
  @$pb.TagNumber(1)
  void clearRequiredDuringSchedulingIgnoredDuringExecution() => clearField(1);
  @$pb.TagNumber(1)
  NodeSelector ensureRequiredDuringSchedulingIgnoredDuringExecution() => $_ensure(0);

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node matches the corresponding matchExpressions; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<PreferredSchedulingTerm> get preferredDuringSchedulingIgnoredDuringExecution => $_getList(1);
}

/// NodeCondition contains condition information for a node.
class NodeCondition extends $pb.GeneratedMessage {
  factory NodeCondition({
    $core.String? type,
    $core.String? status,
    $0.Time? lastHeartbeatTime,
    $0.Time? lastTransitionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (lastHeartbeatTime != null) {
      $result.lastHeartbeatTime = lastHeartbeatTime;
    }
    if (lastTransitionTime != null) {
      $result.lastTransitionTime = lastTransitionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  NodeCondition._() : super();
  factory NodeCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOM<$0.Time>(3, _omitFieldNames ? '' : 'lastHeartbeatTime', protoName: 'lastHeartbeatTime', subBuilder: $0.Time.create)
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'lastTransitionTime', protoName: 'lastTransitionTime', subBuilder: $0.Time.create)
    ..aOS(5, _omitFieldNames ? '' : 'reason')
    ..aOS(6, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeCondition clone() => NodeCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeCondition copyWith(void Function(NodeCondition) updates) => super.copyWith((message) => updates(message as NodeCondition)) as NodeCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeCondition create() => NodeCondition._();
  NodeCondition createEmptyInstance() => create();
  static $pb.PbList<NodeCondition> createRepeated() => $pb.PbList<NodeCondition>();
  @$core.pragma('dart2js:noInline')
  static NodeCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeCondition>(create);
  static NodeCondition? _defaultInstance;

  /// Type of node condition.
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Status of the condition, one of True, False, Unknown.
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// Last time we got an update on a given condition.
  /// +optional
  @$pb.TagNumber(3)
  $0.Time get lastHeartbeatTime => $_getN(2);
  @$pb.TagNumber(3)
  set lastHeartbeatTime($0.Time v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastHeartbeatTime() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastHeartbeatTime() => clearField(3);
  @$pb.TagNumber(3)
  $0.Time ensureLastHeartbeatTime() => $_ensure(2);

  /// Last time the condition transit from one status to another.
  /// +optional
  @$pb.TagNumber(4)
  $0.Time get lastTransitionTime => $_getN(3);
  @$pb.TagNumber(4)
  set lastTransitionTime($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLastTransitionTime() => $_has(3);
  @$pb.TagNumber(4)
  void clearLastTransitionTime() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureLastTransitionTime() => $_ensure(3);

  /// (brief) reason for the condition's last transition.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get reason => $_getSZ(4);
  @$pb.TagNumber(5)
  set reason($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasReason() => $_has(4);
  @$pb.TagNumber(5)
  void clearReason() => clearField(5);

  /// Human readable message indicating details about last transition.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get message => $_getSZ(5);
  @$pb.TagNumber(6)
  set message($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasMessage() => $_has(5);
  @$pb.TagNumber(6)
  void clearMessage() => clearField(6);
}

/// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
/// This API is deprecated since 1.22
class NodeConfigSource extends $pb.GeneratedMessage {
  factory NodeConfigSource({
    ConfigMapNodeConfigSource? configMap,
  }) {
    final $result = create();
    if (configMap != null) {
      $result.configMap = configMap;
    }
    return $result;
  }
  NodeConfigSource._() : super();
  factory NodeConfigSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeConfigSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeConfigSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ConfigMapNodeConfigSource>(2, _omitFieldNames ? '' : 'configMap', protoName: 'configMap', subBuilder: ConfigMapNodeConfigSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeConfigSource clone() => NodeConfigSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeConfigSource copyWith(void Function(NodeConfigSource) updates) => super.copyWith((message) => updates(message as NodeConfigSource)) as NodeConfigSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeConfigSource create() => NodeConfigSource._();
  NodeConfigSource createEmptyInstance() => create();
  static $pb.PbList<NodeConfigSource> createRepeated() => $pb.PbList<NodeConfigSource>();
  @$core.pragma('dart2js:noInline')
  static NodeConfigSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeConfigSource>(create);
  static NodeConfigSource? _defaultInstance;

  /// ConfigMap is a reference to a Node's ConfigMap
  @$pb.TagNumber(2)
  ConfigMapNodeConfigSource get configMap => $_getN(0);
  @$pb.TagNumber(2)
  set configMap(ConfigMapNodeConfigSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasConfigMap() => $_has(0);
  @$pb.TagNumber(2)
  void clearConfigMap() => clearField(2);
  @$pb.TagNumber(2)
  ConfigMapNodeConfigSource ensureConfigMap() => $_ensure(0);
}

/// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
class NodeConfigStatus extends $pb.GeneratedMessage {
  factory NodeConfigStatus({
    NodeConfigSource? assigned,
    NodeConfigSource? active,
    NodeConfigSource? lastKnownGood,
    $core.String? error,
  }) {
    final $result = create();
    if (assigned != null) {
      $result.assigned = assigned;
    }
    if (active != null) {
      $result.active = active;
    }
    if (lastKnownGood != null) {
      $result.lastKnownGood = lastKnownGood;
    }
    if (error != null) {
      $result.error = error;
    }
    return $result;
  }
  NodeConfigStatus._() : super();
  factory NodeConfigStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeConfigStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeConfigStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<NodeConfigSource>(1, _omitFieldNames ? '' : 'assigned', subBuilder: NodeConfigSource.create)
    ..aOM<NodeConfigSource>(2, _omitFieldNames ? '' : 'active', subBuilder: NodeConfigSource.create)
    ..aOM<NodeConfigSource>(3, _omitFieldNames ? '' : 'lastKnownGood', protoName: 'lastKnownGood', subBuilder: NodeConfigSource.create)
    ..aOS(4, _omitFieldNames ? '' : 'error')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeConfigStatus clone() => NodeConfigStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeConfigStatus copyWith(void Function(NodeConfigStatus) updates) => super.copyWith((message) => updates(message as NodeConfigStatus)) as NodeConfigStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeConfigStatus create() => NodeConfigStatus._();
  NodeConfigStatus createEmptyInstance() => create();
  static $pb.PbList<NodeConfigStatus> createRepeated() => $pb.PbList<NodeConfigStatus>();
  @$core.pragma('dart2js:noInline')
  static NodeConfigStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeConfigStatus>(create);
  static NodeConfigStatus? _defaultInstance;

  /// Assigned reports the checkpointed config the node will try to use.
  /// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
  /// config payload to local disk, along with a record indicating intended
  /// config. The node refers to this record to choose its config checkpoint, and
  /// reports this record in Assigned. Assigned only updates in the status after
  /// the record has been checkpointed to disk. When the Kubelet is restarted,
  /// it tries to make the Assigned config the Active config by loading and
  /// validating the checkpointed payload identified by Assigned.
  /// +optional
  @$pb.TagNumber(1)
  NodeConfigSource get assigned => $_getN(0);
  @$pb.TagNumber(1)
  set assigned(NodeConfigSource v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasAssigned() => $_has(0);
  @$pb.TagNumber(1)
  void clearAssigned() => clearField(1);
  @$pb.TagNumber(1)
  NodeConfigSource ensureAssigned() => $_ensure(0);

  /// Active reports the checkpointed config the node is actively using.
  /// Active will represent either the current version of the Assigned config,
  /// or the current LastKnownGood config, depending on whether attempting to use the
  /// Assigned config results in an error.
  /// +optional
  @$pb.TagNumber(2)
  NodeConfigSource get active => $_getN(1);
  @$pb.TagNumber(2)
  set active(NodeConfigSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasActive() => $_has(1);
  @$pb.TagNumber(2)
  void clearActive() => clearField(2);
  @$pb.TagNumber(2)
  NodeConfigSource ensureActive() => $_ensure(1);

  /// LastKnownGood reports the checkpointed config the node will fall back to
  /// when it encounters an error attempting to use the Assigned config.
  /// The Assigned config becomes the LastKnownGood config when the node determines
  /// that the Assigned config is stable and correct.
  /// This is currently implemented as a 10-minute soak period starting when the local
  /// record of Assigned config is updated. If the Assigned config is Active at the end
  /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
  /// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
  /// because the local default config is always assumed good.
  /// You should not make assumptions about the node's method of determining config stability
  /// and correctness, as this may change or become configurable in the future.
  /// +optional
  @$pb.TagNumber(3)
  NodeConfigSource get lastKnownGood => $_getN(2);
  @$pb.TagNumber(3)
  set lastKnownGood(NodeConfigSource v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastKnownGood() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastKnownGood() => clearField(3);
  @$pb.TagNumber(3)
  NodeConfigSource ensureLastKnownGood() => $_ensure(2);

  /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
  /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
  /// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
  /// to load or validate the Assigned config, etc.
  /// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
  /// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
  /// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
  /// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
  /// by fixing the config assigned in Spec.ConfigSource.
  /// You can find additional information for debugging by searching the error message in the Kubelet log.
  /// Error is a human-readable description of the error state; machines can check whether or not Error
  /// is empty, but should not rely on the stability of the Error text across Kubelet versions.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get error => $_getSZ(3);
  @$pb.TagNumber(4)
  set error($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasError() => $_has(3);
  @$pb.TagNumber(4)
  void clearError() => clearField(4);
}

/// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
class NodeDaemonEndpoints extends $pb.GeneratedMessage {
  factory NodeDaemonEndpoints({
    DaemonEndpoint? kubeletEndpoint,
  }) {
    final $result = create();
    if (kubeletEndpoint != null) {
      $result.kubeletEndpoint = kubeletEndpoint;
    }
    return $result;
  }
  NodeDaemonEndpoints._() : super();
  factory NodeDaemonEndpoints.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeDaemonEndpoints.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeDaemonEndpoints', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<DaemonEndpoint>(1, _omitFieldNames ? '' : 'kubeletEndpoint', protoName: 'kubeletEndpoint', subBuilder: DaemonEndpoint.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeDaemonEndpoints clone() => NodeDaemonEndpoints()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeDaemonEndpoints copyWith(void Function(NodeDaemonEndpoints) updates) => super.copyWith((message) => updates(message as NodeDaemonEndpoints)) as NodeDaemonEndpoints;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeDaemonEndpoints create() => NodeDaemonEndpoints._();
  NodeDaemonEndpoints createEmptyInstance() => create();
  static $pb.PbList<NodeDaemonEndpoints> createRepeated() => $pb.PbList<NodeDaemonEndpoints>();
  @$core.pragma('dart2js:noInline')
  static NodeDaemonEndpoints getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeDaemonEndpoints>(create);
  static NodeDaemonEndpoints? _defaultInstance;

  /// Endpoint on which Kubelet is listening.
  /// +optional
  @$pb.TagNumber(1)
  DaemonEndpoint get kubeletEndpoint => $_getN(0);
  @$pb.TagNumber(1)
  set kubeletEndpoint(DaemonEndpoint v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasKubeletEndpoint() => $_has(0);
  @$pb.TagNumber(1)
  void clearKubeletEndpoint() => clearField(1);
  @$pb.TagNumber(1)
  DaemonEndpoint ensureKubeletEndpoint() => $_ensure(0);
}

/// NodeList is the whole list of all Nodes which have been registered with master.
class NodeList extends $pb.GeneratedMessage {
  factory NodeList({
    $0.ListMeta? metadata,
    $core.Iterable<Node>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  NodeList._() : super();
  factory NodeList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Node>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Node.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeList clone() => NodeList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeList copyWith(void Function(NodeList) updates) => super.copyWith((message) => updates(message as NodeList)) as NodeList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeList create() => NodeList._();
  NodeList createEmptyInstance() => create();
  static $pb.PbList<NodeList> createRepeated() => $pb.PbList<NodeList>();
  @$core.pragma('dart2js:noInline')
  static NodeList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeList>(create);
  static NodeList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of nodes
  @$pb.TagNumber(2)
  $core.List<Node> get items => $_getList(1);
}

/// NodeProxyOptions is the query options to a Node's proxy call.
class NodeProxyOptions extends $pb.GeneratedMessage {
  factory NodeProxyOptions({
    $core.String? path,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    return $result;
  }
  NodeProxyOptions._() : super();
  factory NodeProxyOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeProxyOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeProxyOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeProxyOptions clone() => NodeProxyOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeProxyOptions copyWith(void Function(NodeProxyOptions) updates) => super.copyWith((message) => updates(message as NodeProxyOptions)) as NodeProxyOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeProxyOptions create() => NodeProxyOptions._();
  NodeProxyOptions createEmptyInstance() => create();
  static $pb.PbList<NodeProxyOptions> createRepeated() => $pb.PbList<NodeProxyOptions>();
  @$core.pragma('dart2js:noInline')
  static NodeProxyOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeProxyOptions>(create);
  static NodeProxyOptions? _defaultInstance;

  /// Path is the URL path to use for the current proxy request to node.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);
}

/// NodeRuntimeHandler is a set of runtime handler information.
class NodeRuntimeHandler extends $pb.GeneratedMessage {
  factory NodeRuntimeHandler({
    $core.String? name,
    NodeRuntimeHandlerFeatures? features,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (features != null) {
      $result.features = features;
    }
    return $result;
  }
  NodeRuntimeHandler._() : super();
  factory NodeRuntimeHandler.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeRuntimeHandler.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeRuntimeHandler', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOM<NodeRuntimeHandlerFeatures>(2, _omitFieldNames ? '' : 'features', subBuilder: NodeRuntimeHandlerFeatures.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeRuntimeHandler clone() => NodeRuntimeHandler()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeRuntimeHandler copyWith(void Function(NodeRuntimeHandler) updates) => super.copyWith((message) => updates(message as NodeRuntimeHandler)) as NodeRuntimeHandler;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeRuntimeHandler create() => NodeRuntimeHandler._();
  NodeRuntimeHandler createEmptyInstance() => create();
  static $pb.PbList<NodeRuntimeHandler> createRepeated() => $pb.PbList<NodeRuntimeHandler>();
  @$core.pragma('dart2js:noInline')
  static NodeRuntimeHandler getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeRuntimeHandler>(create);
  static NodeRuntimeHandler? _defaultInstance;

  /// Runtime handler name.
  /// Empty for the default runtime handler.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Supported features.
  /// +optional
  @$pb.TagNumber(2)
  NodeRuntimeHandlerFeatures get features => $_getN(1);
  @$pb.TagNumber(2)
  set features(NodeRuntimeHandlerFeatures v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasFeatures() => $_has(1);
  @$pb.TagNumber(2)
  void clearFeatures() => clearField(2);
  @$pb.TagNumber(2)
  NodeRuntimeHandlerFeatures ensureFeatures() => $_ensure(1);
}

/// NodeRuntimeHandlerFeatures is a set of runtime features.
class NodeRuntimeHandlerFeatures extends $pb.GeneratedMessage {
  factory NodeRuntimeHandlerFeatures({
    $core.bool? recursiveReadOnlyMounts,
  }) {
    final $result = create();
    if (recursiveReadOnlyMounts != null) {
      $result.recursiveReadOnlyMounts = recursiveReadOnlyMounts;
    }
    return $result;
  }
  NodeRuntimeHandlerFeatures._() : super();
  factory NodeRuntimeHandlerFeatures.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeRuntimeHandlerFeatures.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeRuntimeHandlerFeatures', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOB(1, _omitFieldNames ? '' : 'recursiveReadOnlyMounts', protoName: 'recursiveReadOnlyMounts')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeRuntimeHandlerFeatures clone() => NodeRuntimeHandlerFeatures()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeRuntimeHandlerFeatures copyWith(void Function(NodeRuntimeHandlerFeatures) updates) => super.copyWith((message) => updates(message as NodeRuntimeHandlerFeatures)) as NodeRuntimeHandlerFeatures;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeRuntimeHandlerFeatures create() => NodeRuntimeHandlerFeatures._();
  NodeRuntimeHandlerFeatures createEmptyInstance() => create();
  static $pb.PbList<NodeRuntimeHandlerFeatures> createRepeated() => $pb.PbList<NodeRuntimeHandlerFeatures>();
  @$core.pragma('dart2js:noInline')
  static NodeRuntimeHandlerFeatures getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeRuntimeHandlerFeatures>(create);
  static NodeRuntimeHandlerFeatures? _defaultInstance;

  /// RecursiveReadOnlyMounts is set to true if the runtime handler supports RecursiveReadOnlyMounts.
  /// +featureGate=RecursiveReadOnlyMounts
  /// +optional
  @$pb.TagNumber(1)
  $core.bool get recursiveReadOnlyMounts => $_getBF(0);
  @$pb.TagNumber(1)
  set recursiveReadOnlyMounts($core.bool v) { $_setBool(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasRecursiveReadOnlyMounts() => $_has(0);
  @$pb.TagNumber(1)
  void clearRecursiveReadOnlyMounts() => clearField(1);
}

/// A node selector represents the union of the results of one or more label queries
/// over a set of nodes; that is, it represents the OR of the selectors represented
/// by the node selector terms.
/// +structType=atomic
class NodeSelector extends $pb.GeneratedMessage {
  factory NodeSelector({
    $core.Iterable<NodeSelectorTerm>? nodeSelectorTerms,
  }) {
    final $result = create();
    if (nodeSelectorTerms != null) {
      $result.nodeSelectorTerms.addAll(nodeSelectorTerms);
    }
    return $result;
  }
  NodeSelector._() : super();
  factory NodeSelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeSelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeSelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<NodeSelectorTerm>(1, _omitFieldNames ? '' : 'nodeSelectorTerms', $pb.PbFieldType.PM, protoName: 'nodeSelectorTerms', subBuilder: NodeSelectorTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeSelector clone() => NodeSelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeSelector copyWith(void Function(NodeSelector) updates) => super.copyWith((message) => updates(message as NodeSelector)) as NodeSelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeSelector create() => NodeSelector._();
  NodeSelector createEmptyInstance() => create();
  static $pb.PbList<NodeSelector> createRepeated() => $pb.PbList<NodeSelector>();
  @$core.pragma('dart2js:noInline')
  static NodeSelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeSelector>(create);
  static NodeSelector? _defaultInstance;

  /// Required. A list of node selector terms. The terms are ORed.
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<NodeSelectorTerm> get nodeSelectorTerms => $_getList(0);
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
class NodeSelectorRequirement extends $pb.GeneratedMessage {
  factory NodeSelectorRequirement({
    $core.String? key,
    $core.String? operator,
    $core.Iterable<$core.String>? values,
  }) {
    final $result = create();
    if (key != null) {
      $result.key = key;
    }
    if (operator != null) {
      $result.operator = operator;
    }
    if (values != null) {
      $result.values.addAll(values);
    }
    return $result;
  }
  NodeSelectorRequirement._() : super();
  factory NodeSelectorRequirement.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeSelectorRequirement.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeSelectorRequirement', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'key')
    ..aOS(2, _omitFieldNames ? '' : 'operator')
    ..pPS(3, _omitFieldNames ? '' : 'values')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeSelectorRequirement clone() => NodeSelectorRequirement()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeSelectorRequirement copyWith(void Function(NodeSelectorRequirement) updates) => super.copyWith((message) => updates(message as NodeSelectorRequirement)) as NodeSelectorRequirement;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeSelectorRequirement create() => NodeSelectorRequirement._();
  NodeSelectorRequirement createEmptyInstance() => create();
  static $pb.PbList<NodeSelectorRequirement> createRepeated() => $pb.PbList<NodeSelectorRequirement>();
  @$core.pragma('dart2js:noInline')
  static NodeSelectorRequirement getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeSelectorRequirement>(create);
  static NodeSelectorRequirement? _defaultInstance;

  /// The label key that the selector applies to.
  @$pb.TagNumber(1)
  $core.String get key => $_getSZ(0);
  @$pb.TagNumber(1)
  set key($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKey() => $_has(0);
  @$pb.TagNumber(1)
  void clearKey() => clearField(1);

  /// Represents a key's relationship to a set of values.
  /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  @$pb.TagNumber(2)
  $core.String get operator => $_getSZ(1);
  @$pb.TagNumber(2)
  set operator($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasOperator() => $_has(1);
  @$pb.TagNumber(2)
  void clearOperator() => clearField(2);

  /// An array of string values. If the operator is In or NotIn,
  /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
  /// the values array must be empty. If the operator is Gt or Lt, the values
  /// array must have a single element, which will be interpreted as an integer.
  /// This array is replaced during a strategic merge patch.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<$core.String> get values => $_getList(2);
}

/// A null or empty node selector term matches no objects. The requirements of
/// them are ANDed.
/// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
/// +structType=atomic
class NodeSelectorTerm extends $pb.GeneratedMessage {
  factory NodeSelectorTerm({
    $core.Iterable<NodeSelectorRequirement>? matchExpressions,
    $core.Iterable<NodeSelectorRequirement>? matchFields,
  }) {
    final $result = create();
    if (matchExpressions != null) {
      $result.matchExpressions.addAll(matchExpressions);
    }
    if (matchFields != null) {
      $result.matchFields.addAll(matchFields);
    }
    return $result;
  }
  NodeSelectorTerm._() : super();
  factory NodeSelectorTerm.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeSelectorTerm.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeSelectorTerm', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<NodeSelectorRequirement>(1, _omitFieldNames ? '' : 'matchExpressions', $pb.PbFieldType.PM, protoName: 'matchExpressions', subBuilder: NodeSelectorRequirement.create)
    ..pc<NodeSelectorRequirement>(2, _omitFieldNames ? '' : 'matchFields', $pb.PbFieldType.PM, protoName: 'matchFields', subBuilder: NodeSelectorRequirement.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeSelectorTerm clone() => NodeSelectorTerm()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeSelectorTerm copyWith(void Function(NodeSelectorTerm) updates) => super.copyWith((message) => updates(message as NodeSelectorTerm)) as NodeSelectorTerm;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeSelectorTerm create() => NodeSelectorTerm._();
  NodeSelectorTerm createEmptyInstance() => create();
  static $pb.PbList<NodeSelectorTerm> createRepeated() => $pb.PbList<NodeSelectorTerm>();
  @$core.pragma('dart2js:noInline')
  static NodeSelectorTerm getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeSelectorTerm>(create);
  static NodeSelectorTerm? _defaultInstance;

  /// A list of node selector requirements by node's labels.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<NodeSelectorRequirement> get matchExpressions => $_getList(0);

  /// A list of node selector requirements by node's fields.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<NodeSelectorRequirement> get matchFields => $_getList(1);
}

/// NodeSpec describes the attributes that a node is created with.
class NodeSpec extends $pb.GeneratedMessage {
  factory NodeSpec({
    $core.String? podCIDR,
    $core.String? externalID,
    $core.String? providerID,
    $core.bool? unschedulable,
    $core.Iterable<Taint>? taints,
    NodeConfigSource? configSource,
    $core.Iterable<$core.String>? podCIDRs,
  }) {
    final $result = create();
    if (podCIDR != null) {
      $result.podCIDR = podCIDR;
    }
    if (externalID != null) {
      $result.externalID = externalID;
    }
    if (providerID != null) {
      $result.providerID = providerID;
    }
    if (unschedulable != null) {
      $result.unschedulable = unschedulable;
    }
    if (taints != null) {
      $result.taints.addAll(taints);
    }
    if (configSource != null) {
      $result.configSource = configSource;
    }
    if (podCIDRs != null) {
      $result.podCIDRs.addAll(podCIDRs);
    }
    return $result;
  }
  NodeSpec._() : super();
  factory NodeSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'podCIDR', protoName: 'podCIDR')
    ..aOS(2, _omitFieldNames ? '' : 'externalID', protoName: 'externalID')
    ..aOS(3, _omitFieldNames ? '' : 'providerID', protoName: 'providerID')
    ..aOB(4, _omitFieldNames ? '' : 'unschedulable')
    ..pc<Taint>(5, _omitFieldNames ? '' : 'taints', $pb.PbFieldType.PM, subBuilder: Taint.create)
    ..aOM<NodeConfigSource>(6, _omitFieldNames ? '' : 'configSource', protoName: 'configSource', subBuilder: NodeConfigSource.create)
    ..pPS(7, _omitFieldNames ? '' : 'podCIDRs', protoName: 'podCIDRs')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeSpec clone() => NodeSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeSpec copyWith(void Function(NodeSpec) updates) => super.copyWith((message) => updates(message as NodeSpec)) as NodeSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeSpec create() => NodeSpec._();
  NodeSpec createEmptyInstance() => create();
  static $pb.PbList<NodeSpec> createRepeated() => $pb.PbList<NodeSpec>();
  @$core.pragma('dart2js:noInline')
  static NodeSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeSpec>(create);
  static NodeSpec? _defaultInstance;

  /// PodCIDR represents the pod IP range assigned to the node.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get podCIDR => $_getSZ(0);
  @$pb.TagNumber(1)
  set podCIDR($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPodCIDR() => $_has(0);
  @$pb.TagNumber(1)
  void clearPodCIDR() => clearField(1);

  /// Deprecated. Not all kubelets will set this field. Remove field after 1.13.
  /// see: https://issues.k8s.io/61966
  /// +optional
  @$pb.TagNumber(2)
  $core.String get externalID => $_getSZ(1);
  @$pb.TagNumber(2)
  set externalID($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasExternalID() => $_has(1);
  @$pb.TagNumber(2)
  void clearExternalID() => clearField(2);

  /// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
  /// +optional
  @$pb.TagNumber(3)
  $core.String get providerID => $_getSZ(2);
  @$pb.TagNumber(3)
  set providerID($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasProviderID() => $_has(2);
  @$pb.TagNumber(3)
  void clearProviderID() => clearField(3);

  /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get unschedulable => $_getBF(3);
  @$pb.TagNumber(4)
  set unschedulable($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasUnschedulable() => $_has(3);
  @$pb.TagNumber(4)
  void clearUnschedulable() => clearField(4);

  /// If specified, the node's taints.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(5)
  $core.List<Taint> get taints => $_getList(4);

  /// Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed.
  /// +optional
  @$pb.TagNumber(6)
  NodeConfigSource get configSource => $_getN(5);
  @$pb.TagNumber(6)
  set configSource(NodeConfigSource v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasConfigSource() => $_has(5);
  @$pb.TagNumber(6)
  void clearConfigSource() => clearField(6);
  @$pb.TagNumber(6)
  NodeConfigSource ensureConfigSource() => $_ensure(5);

  /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
  /// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
  /// each of IPv4 and IPv6.
  /// +optional
  /// +patchStrategy=merge
  /// +listType=set
  @$pb.TagNumber(7)
  $core.List<$core.String> get podCIDRs => $_getList(6);
}

/// NodeStatus is information about the current status of a node.
class NodeStatus extends $pb.GeneratedMessage {
  factory NodeStatus({
    $core.Map<$core.String, $1.Quantity>? capacity,
    $core.Map<$core.String, $1.Quantity>? allocatable,
    $core.String? phase,
    $core.Iterable<NodeCondition>? conditions,
    $core.Iterable<NodeAddress>? addresses,
    NodeDaemonEndpoints? daemonEndpoints,
    NodeSystemInfo? nodeInfo,
    $core.Iterable<ContainerImage>? images,
    $core.Iterable<$core.String>? volumesInUse,
    $core.Iterable<AttachedVolume>? volumesAttached,
    NodeConfigStatus? config,
    $core.Iterable<NodeRuntimeHandler>? runtimeHandlers,
  }) {
    final $result = create();
    if (capacity != null) {
      $result.capacity.addAll(capacity);
    }
    if (allocatable != null) {
      $result.allocatable.addAll(allocatable);
    }
    if (phase != null) {
      $result.phase = phase;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    if (addresses != null) {
      $result.addresses.addAll(addresses);
    }
    if (daemonEndpoints != null) {
      $result.daemonEndpoints = daemonEndpoints;
    }
    if (nodeInfo != null) {
      $result.nodeInfo = nodeInfo;
    }
    if (images != null) {
      $result.images.addAll(images);
    }
    if (volumesInUse != null) {
      $result.volumesInUse.addAll(volumesInUse);
    }
    if (volumesAttached != null) {
      $result.volumesAttached.addAll(volumesAttached);
    }
    if (config != null) {
      $result.config = config;
    }
    if (runtimeHandlers != null) {
      $result.runtimeHandlers.addAll(runtimeHandlers);
    }
    return $result;
  }
  NodeStatus._() : super();
  factory NodeStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'capacity', entryClassName: 'NodeStatus.CapacityEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(2, _omitFieldNames ? '' : 'allocatable', entryClassName: 'NodeStatus.AllocatableEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..aOS(3, _omitFieldNames ? '' : 'phase')
    ..pc<NodeCondition>(4, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: NodeCondition.create)
    ..pc<NodeAddress>(5, _omitFieldNames ? '' : 'addresses', $pb.PbFieldType.PM, subBuilder: NodeAddress.create)
    ..aOM<NodeDaemonEndpoints>(6, _omitFieldNames ? '' : 'daemonEndpoints', protoName: 'daemonEndpoints', subBuilder: NodeDaemonEndpoints.create)
    ..aOM<NodeSystemInfo>(7, _omitFieldNames ? '' : 'nodeInfo', protoName: 'nodeInfo', subBuilder: NodeSystemInfo.create)
    ..pc<ContainerImage>(8, _omitFieldNames ? '' : 'images', $pb.PbFieldType.PM, subBuilder: ContainerImage.create)
    ..pPS(9, _omitFieldNames ? '' : 'volumesInUse', protoName: 'volumesInUse')
    ..pc<AttachedVolume>(10, _omitFieldNames ? '' : 'volumesAttached', $pb.PbFieldType.PM, protoName: 'volumesAttached', subBuilder: AttachedVolume.create)
    ..aOM<NodeConfigStatus>(11, _omitFieldNames ? '' : 'config', subBuilder: NodeConfigStatus.create)
    ..pc<NodeRuntimeHandler>(12, _omitFieldNames ? '' : 'runtimeHandlers', $pb.PbFieldType.PM, protoName: 'runtimeHandlers', subBuilder: NodeRuntimeHandler.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeStatus clone() => NodeStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeStatus copyWith(void Function(NodeStatus) updates) => super.copyWith((message) => updates(message as NodeStatus)) as NodeStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeStatus create() => NodeStatus._();
  NodeStatus createEmptyInstance() => create();
  static $pb.PbList<NodeStatus> createRepeated() => $pb.PbList<NodeStatus>();
  @$core.pragma('dart2js:noInline')
  static NodeStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeStatus>(create);
  static NodeStatus? _defaultInstance;

  /// Capacity represents the total resources of a node.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get capacity => $_getMap(0);

  /// Allocatable represents the resources of a node that are available for scheduling.
  /// Defaults to Capacity.
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $1.Quantity> get allocatable => $_getMap(1);

  /// NodePhase is the recently observed lifecycle phase of the node.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
  /// The field is never populated, and now is deprecated.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get phase => $_getSZ(2);
  @$pb.TagNumber(3)
  set phase($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPhase() => $_has(2);
  @$pb.TagNumber(3)
  void clearPhase() => clearField(3);

  /// Conditions is an array of current observed node conditions.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(4)
  $core.List<NodeCondition> get conditions => $_getList(3);

  /// List of addresses reachable to the node.
  /// Queried from cloud provider, if available.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
  /// Note: This field is declared as mergeable, but the merge key is not sufficiently
  /// unique, which can cause data corruption when it is merged. Callers should instead
  /// use a full-replacement patch. See https://pr.k8s.io/79391 for an example.
  /// Consumers should assume that addresses can change during the
  /// lifetime of a Node. However, there are some exceptions where this may not
  /// be possible, such as Pods that inherit a Node's address in its own status or
  /// consumers of the downward API (status.hostIP).
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(5)
  $core.List<NodeAddress> get addresses => $_getList(4);

  /// Endpoints of daemons running on the Node.
  /// +optional
  @$pb.TagNumber(6)
  NodeDaemonEndpoints get daemonEndpoints => $_getN(5);
  @$pb.TagNumber(6)
  set daemonEndpoints(NodeDaemonEndpoints v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasDaemonEndpoints() => $_has(5);
  @$pb.TagNumber(6)
  void clearDaemonEndpoints() => clearField(6);
  @$pb.TagNumber(6)
  NodeDaemonEndpoints ensureDaemonEndpoints() => $_ensure(5);

  /// Set of ids/uuids to uniquely identify the node.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
  /// +optional
  @$pb.TagNumber(7)
  NodeSystemInfo get nodeInfo => $_getN(6);
  @$pb.TagNumber(7)
  set nodeInfo(NodeSystemInfo v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasNodeInfo() => $_has(6);
  @$pb.TagNumber(7)
  void clearNodeInfo() => clearField(7);
  @$pb.TagNumber(7)
  NodeSystemInfo ensureNodeInfo() => $_ensure(6);

  /// List of container images on this node
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(8)
  $core.List<ContainerImage> get images => $_getList(7);

  /// List of attachable volumes in use (mounted) by the node.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(9)
  $core.List<$core.String> get volumesInUse => $_getList(8);

  /// List of volumes that are attached to the node.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(10)
  $core.List<AttachedVolume> get volumesAttached => $_getList(9);

  /// Status of the config assigned to the node via the dynamic Kubelet config feature.
  /// +optional
  @$pb.TagNumber(11)
  NodeConfigStatus get config => $_getN(10);
  @$pb.TagNumber(11)
  set config(NodeConfigStatus v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasConfig() => $_has(10);
  @$pb.TagNumber(11)
  void clearConfig() => clearField(11);
  @$pb.TagNumber(11)
  NodeConfigStatus ensureConfig() => $_ensure(10);

  /// The available runtime handlers.
  /// +featureGate=RecursiveReadOnlyMounts
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(12)
  $core.List<NodeRuntimeHandler> get runtimeHandlers => $_getList(11);
}

/// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
class NodeSystemInfo extends $pb.GeneratedMessage {
  factory NodeSystemInfo({
    $core.String? machineID,
    $core.String? systemUUID,
    $core.String? bootID,
    $core.String? kernelVersion,
    $core.String? osImage,
    $core.String? containerRuntimeVersion,
    $core.String? kubeletVersion,
    $core.String? kubeProxyVersion,
    $core.String? operatingSystem,
    $core.String? architecture,
  }) {
    final $result = create();
    if (machineID != null) {
      $result.machineID = machineID;
    }
    if (systemUUID != null) {
      $result.systemUUID = systemUUID;
    }
    if (bootID != null) {
      $result.bootID = bootID;
    }
    if (kernelVersion != null) {
      $result.kernelVersion = kernelVersion;
    }
    if (osImage != null) {
      $result.osImage = osImage;
    }
    if (containerRuntimeVersion != null) {
      $result.containerRuntimeVersion = containerRuntimeVersion;
    }
    if (kubeletVersion != null) {
      $result.kubeletVersion = kubeletVersion;
    }
    if (kubeProxyVersion != null) {
      $result.kubeProxyVersion = kubeProxyVersion;
    }
    if (operatingSystem != null) {
      $result.operatingSystem = operatingSystem;
    }
    if (architecture != null) {
      $result.architecture = architecture;
    }
    return $result;
  }
  NodeSystemInfo._() : super();
  factory NodeSystemInfo.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory NodeSystemInfo.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'NodeSystemInfo', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'machineID', protoName: 'machineID')
    ..aOS(2, _omitFieldNames ? '' : 'systemUUID', protoName: 'systemUUID')
    ..aOS(3, _omitFieldNames ? '' : 'bootID', protoName: 'bootID')
    ..aOS(4, _omitFieldNames ? '' : 'kernelVersion', protoName: 'kernelVersion')
    ..aOS(5, _omitFieldNames ? '' : 'osImage', protoName: 'osImage')
    ..aOS(6, _omitFieldNames ? '' : 'containerRuntimeVersion', protoName: 'containerRuntimeVersion')
    ..aOS(7, _omitFieldNames ? '' : 'kubeletVersion', protoName: 'kubeletVersion')
    ..aOS(8, _omitFieldNames ? '' : 'kubeProxyVersion', protoName: 'kubeProxyVersion')
    ..aOS(9, _omitFieldNames ? '' : 'operatingSystem', protoName: 'operatingSystem')
    ..aOS(10, _omitFieldNames ? '' : 'architecture')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  NodeSystemInfo clone() => NodeSystemInfo()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  NodeSystemInfo copyWith(void Function(NodeSystemInfo) updates) => super.copyWith((message) => updates(message as NodeSystemInfo)) as NodeSystemInfo;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static NodeSystemInfo create() => NodeSystemInfo._();
  NodeSystemInfo createEmptyInstance() => create();
  static $pb.PbList<NodeSystemInfo> createRepeated() => $pb.PbList<NodeSystemInfo>();
  @$core.pragma('dart2js:noInline')
  static NodeSystemInfo getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<NodeSystemInfo>(create);
  static NodeSystemInfo? _defaultInstance;

  /// MachineID reported by the node. For unique machine identification
  /// in the cluster this field is preferred. Learn more from man(5)
  /// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
  @$pb.TagNumber(1)
  $core.String get machineID => $_getSZ(0);
  @$pb.TagNumber(1)
  set machineID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasMachineID() => $_has(0);
  @$pb.TagNumber(1)
  void clearMachineID() => clearField(1);

  /// SystemUUID reported by the node. For unique machine identification
  /// MachineID is preferred. This field is specific to Red Hat hosts
  /// https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
  @$pb.TagNumber(2)
  $core.String get systemUUID => $_getSZ(1);
  @$pb.TagNumber(2)
  set systemUUID($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSystemUUID() => $_has(1);
  @$pb.TagNumber(2)
  void clearSystemUUID() => clearField(2);

  /// Boot ID reported by the node.
  @$pb.TagNumber(3)
  $core.String get bootID => $_getSZ(2);
  @$pb.TagNumber(3)
  set bootID($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasBootID() => $_has(2);
  @$pb.TagNumber(3)
  void clearBootID() => clearField(3);

  /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
  @$pb.TagNumber(4)
  $core.String get kernelVersion => $_getSZ(3);
  @$pb.TagNumber(4)
  set kernelVersion($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasKernelVersion() => $_has(3);
  @$pb.TagNumber(4)
  void clearKernelVersion() => clearField(4);

  /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
  @$pb.TagNumber(5)
  $core.String get osImage => $_getSZ(4);
  @$pb.TagNumber(5)
  set osImage($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasOsImage() => $_has(4);
  @$pb.TagNumber(5)
  void clearOsImage() => clearField(5);

  /// ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
  @$pb.TagNumber(6)
  $core.String get containerRuntimeVersion => $_getSZ(5);
  @$pb.TagNumber(6)
  set containerRuntimeVersion($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasContainerRuntimeVersion() => $_has(5);
  @$pb.TagNumber(6)
  void clearContainerRuntimeVersion() => clearField(6);

  /// Kubelet Version reported by the node.
  @$pb.TagNumber(7)
  $core.String get kubeletVersion => $_getSZ(6);
  @$pb.TagNumber(7)
  set kubeletVersion($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasKubeletVersion() => $_has(6);
  @$pb.TagNumber(7)
  void clearKubeletVersion() => clearField(7);

  /// KubeProxy Version reported by the node.
  @$pb.TagNumber(8)
  $core.String get kubeProxyVersion => $_getSZ(7);
  @$pb.TagNumber(8)
  set kubeProxyVersion($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasKubeProxyVersion() => $_has(7);
  @$pb.TagNumber(8)
  void clearKubeProxyVersion() => clearField(8);

  /// The Operating System reported by the node
  @$pb.TagNumber(9)
  $core.String get operatingSystem => $_getSZ(8);
  @$pb.TagNumber(9)
  set operatingSystem($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasOperatingSystem() => $_has(8);
  @$pb.TagNumber(9)
  void clearOperatingSystem() => clearField(9);

  /// The Architecture reported by the node
  @$pb.TagNumber(10)
  $core.String get architecture => $_getSZ(9);
  @$pb.TagNumber(10)
  set architecture($core.String v) { $_setString(9, v); }
  @$pb.TagNumber(10)
  $core.bool hasArchitecture() => $_has(9);
  @$pb.TagNumber(10)
  void clearArchitecture() => clearField(10);
}

/// ObjectFieldSelector selects an APIVersioned field of an object.
/// +structType=atomic
class ObjectFieldSelector extends $pb.GeneratedMessage {
  factory ObjectFieldSelector({
    $core.String? apiVersion,
    $core.String? fieldPath,
  }) {
    final $result = create();
    if (apiVersion != null) {
      $result.apiVersion = apiVersion;
    }
    if (fieldPath != null) {
      $result.fieldPath = fieldPath;
    }
    return $result;
  }
  ObjectFieldSelector._() : super();
  factory ObjectFieldSelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ObjectFieldSelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ObjectFieldSelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'apiVersion', protoName: 'apiVersion')
    ..aOS(2, _omitFieldNames ? '' : 'fieldPath', protoName: 'fieldPath')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ObjectFieldSelector clone() => ObjectFieldSelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ObjectFieldSelector copyWith(void Function(ObjectFieldSelector) updates) => super.copyWith((message) => updates(message as ObjectFieldSelector)) as ObjectFieldSelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ObjectFieldSelector create() => ObjectFieldSelector._();
  ObjectFieldSelector createEmptyInstance() => create();
  static $pb.PbList<ObjectFieldSelector> createRepeated() => $pb.PbList<ObjectFieldSelector>();
  @$core.pragma('dart2js:noInline')
  static ObjectFieldSelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ObjectFieldSelector>(create);
  static ObjectFieldSelector? _defaultInstance;

  /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
  /// +optional
  @$pb.TagNumber(1)
  $core.String get apiVersion => $_getSZ(0);
  @$pb.TagNumber(1)
  set apiVersion($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasApiVersion() => $_has(0);
  @$pb.TagNumber(1)
  void clearApiVersion() => clearField(1);

  /// Path of the field to select in the specified API version.
  @$pb.TagNumber(2)
  $core.String get fieldPath => $_getSZ(1);
  @$pb.TagNumber(2)
  set fieldPath($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFieldPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearFieldPath() => clearField(2);
}

///  ObjectReference contains enough information to let you inspect or modify the referred object.
///  ---
///  New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
///   1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
///   2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
///      restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
///      Those cannot be well described when embedded.
///   3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
///   4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
///      during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
///      and the version of the actual struct is irrelevant.
///   5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
///      will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
///
///  Instead of using this type, create a locally provided and used type that is well-focused on your reference.
///  For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
///  +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
///  +structType=atomic
class ObjectReference extends $pb.GeneratedMessage {
  factory ObjectReference({
    $core.String? kind,
    $core.String? namespace,
    $core.String? name,
    $core.String? uid,
    $core.String? apiVersion,
    $core.String? resourceVersion,
    $core.String? fieldPath,
  }) {
    final $result = create();
    if (kind != null) {
      $result.kind = kind;
    }
    if (namespace != null) {
      $result.namespace = namespace;
    }
    if (name != null) {
      $result.name = name;
    }
    if (uid != null) {
      $result.uid = uid;
    }
    if (apiVersion != null) {
      $result.apiVersion = apiVersion;
    }
    if (resourceVersion != null) {
      $result.resourceVersion = resourceVersion;
    }
    if (fieldPath != null) {
      $result.fieldPath = fieldPath;
    }
    return $result;
  }
  ObjectReference._() : super();
  factory ObjectReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ObjectReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ObjectReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'kind')
    ..aOS(2, _omitFieldNames ? '' : 'namespace')
    ..aOS(3, _omitFieldNames ? '' : 'name')
    ..aOS(4, _omitFieldNames ? '' : 'uid')
    ..aOS(5, _omitFieldNames ? '' : 'apiVersion', protoName: 'apiVersion')
    ..aOS(6, _omitFieldNames ? '' : 'resourceVersion', protoName: 'resourceVersion')
    ..aOS(7, _omitFieldNames ? '' : 'fieldPath', protoName: 'fieldPath')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ObjectReference clone() => ObjectReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ObjectReference copyWith(void Function(ObjectReference) updates) => super.copyWith((message) => updates(message as ObjectReference)) as ObjectReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ObjectReference create() => ObjectReference._();
  ObjectReference createEmptyInstance() => create();
  static $pb.PbList<ObjectReference> createRepeated() => $pb.PbList<ObjectReference>();
  @$core.pragma('dart2js:noInline')
  static ObjectReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ObjectReference>(create);
  static ObjectReference? _defaultInstance;

  /// Kind of the referent.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $core.String get kind => $_getSZ(0);
  @$pb.TagNumber(1)
  set kind($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKind() => $_has(0);
  @$pb.TagNumber(1)
  void clearKind() => clearField(1);

  /// Namespace of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  /// +optional
  @$pb.TagNumber(2)
  $core.String get namespace => $_getSZ(1);
  @$pb.TagNumber(2)
  set namespace($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasNamespace() => $_has(1);
  @$pb.TagNumber(2)
  void clearNamespace() => clearField(2);

  /// Name of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  /// +optional
  @$pb.TagNumber(3)
  $core.String get name => $_getSZ(2);
  @$pb.TagNumber(3)
  set name($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasName() => $_has(2);
  @$pb.TagNumber(3)
  void clearName() => clearField(3);

  /// UID of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  /// +optional
  @$pb.TagNumber(4)
  $core.String get uid => $_getSZ(3);
  @$pb.TagNumber(4)
  set uid($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasUid() => $_has(3);
  @$pb.TagNumber(4)
  void clearUid() => clearField(4);

  /// API version of the referent.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get apiVersion => $_getSZ(4);
  @$pb.TagNumber(5)
  set apiVersion($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasApiVersion() => $_has(4);
  @$pb.TagNumber(5)
  void clearApiVersion() => clearField(5);

  /// Specific resourceVersion to which this reference is made, if any.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  /// +optional
  @$pb.TagNumber(6)
  $core.String get resourceVersion => $_getSZ(5);
  @$pb.TagNumber(6)
  set resourceVersion($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasResourceVersion() => $_has(5);
  @$pb.TagNumber(6)
  void clearResourceVersion() => clearField(6);

  /// If referring to a piece of an object instead of an entire object, this string
  /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
  /// For example, if the object reference is to a container within a pod, this would take on a value like:
  /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
  /// the event) or if no container name is specified "spec.containers[2]" (container with
  /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
  /// referencing a part of an object.
  /// TODO: this design is not final and this field is subject to change in the future.
  /// +optional
  @$pb.TagNumber(7)
  $core.String get fieldPath => $_getSZ(6);
  @$pb.TagNumber(7)
  set fieldPath($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasFieldPath() => $_has(6);
  @$pb.TagNumber(7)
  void clearFieldPath() => clearField(7);
}

/// PersistentVolume (PV) is a storage resource provisioned by an administrator.
/// It is analogous to a node.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
class PersistentVolume extends $pb.GeneratedMessage {
  factory PersistentVolume({
    $0.ObjectMeta? metadata,
    PersistentVolumeSpec? spec,
    PersistentVolumeStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  PersistentVolume._() : super();
  factory PersistentVolume.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolume.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolume', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PersistentVolumeSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: PersistentVolumeSpec.create)
    ..aOM<PersistentVolumeStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: PersistentVolumeStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolume clone() => PersistentVolume()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolume copyWith(void Function(PersistentVolume) updates) => super.copyWith((message) => updates(message as PersistentVolume)) as PersistentVolume;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolume create() => PersistentVolume._();
  PersistentVolume createEmptyInstance() => create();
  static $pb.PbList<PersistentVolume> createRepeated() => $pb.PbList<PersistentVolume>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolume getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolume>(create);
  static PersistentVolume? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// spec defines a specification of a persistent volume owned by the cluster.
  /// Provisioned by an administrator.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  /// +optional
  @$pb.TagNumber(2)
  PersistentVolumeSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(PersistentVolumeSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  PersistentVolumeSpec ensureSpec() => $_ensure(1);

  /// status represents the current information/status for the persistent volume.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  /// +optional
  @$pb.TagNumber(3)
  PersistentVolumeStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(PersistentVolumeStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  PersistentVolumeStatus ensureStatus() => $_ensure(2);
}

/// PersistentVolumeClaim is a user's request for and claim to a persistent volume
class PersistentVolumeClaim extends $pb.GeneratedMessage {
  factory PersistentVolumeClaim({
    $0.ObjectMeta? metadata,
    PersistentVolumeClaimSpec? spec,
    PersistentVolumeClaimStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  PersistentVolumeClaim._() : super();
  factory PersistentVolumeClaim.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaim.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaim', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PersistentVolumeClaimSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: PersistentVolumeClaimSpec.create)
    ..aOM<PersistentVolumeClaimStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: PersistentVolumeClaimStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaim clone() => PersistentVolumeClaim()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaim copyWith(void Function(PersistentVolumeClaim) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaim)) as PersistentVolumeClaim;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaim create() => PersistentVolumeClaim._();
  PersistentVolumeClaim createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaim> createRepeated() => $pb.PbList<PersistentVolumeClaim>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaim getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaim>(create);
  static PersistentVolumeClaim? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// spec defines the desired characteristics of a volume requested by a pod author.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  @$pb.TagNumber(2)
  PersistentVolumeClaimSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(PersistentVolumeClaimSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  PersistentVolumeClaimSpec ensureSpec() => $_ensure(1);

  /// status represents the current information/status of a persistent volume claim.
  /// Read-only.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  @$pb.TagNumber(3)
  PersistentVolumeClaimStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(PersistentVolumeClaimStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  PersistentVolumeClaimStatus ensureStatus() => $_ensure(2);
}

/// PersistentVolumeClaimCondition contains details about state of pvc
class PersistentVolumeClaimCondition extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimCondition({
    $core.String? type,
    $core.String? status,
    $0.Time? lastProbeTime,
    $0.Time? lastTransitionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (lastProbeTime != null) {
      $result.lastProbeTime = lastProbeTime;
    }
    if (lastTransitionTime != null) {
      $result.lastTransitionTime = lastTransitionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  PersistentVolumeClaimCondition._() : super();
  factory PersistentVolumeClaimCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOM<$0.Time>(3, _omitFieldNames ? '' : 'lastProbeTime', protoName: 'lastProbeTime', subBuilder: $0.Time.create)
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'lastTransitionTime', protoName: 'lastTransitionTime', subBuilder: $0.Time.create)
    ..aOS(5, _omitFieldNames ? '' : 'reason')
    ..aOS(6, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimCondition clone() => PersistentVolumeClaimCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimCondition copyWith(void Function(PersistentVolumeClaimCondition) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimCondition)) as PersistentVolumeClaimCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimCondition create() => PersistentVolumeClaimCondition._();
  PersistentVolumeClaimCondition createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimCondition> createRepeated() => $pb.PbList<PersistentVolumeClaimCondition>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimCondition>(create);
  static PersistentVolumeClaimCondition? _defaultInstance;

  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// lastProbeTime is the time we probed the condition.
  /// +optional
  @$pb.TagNumber(3)
  $0.Time get lastProbeTime => $_getN(2);
  @$pb.TagNumber(3)
  set lastProbeTime($0.Time v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastProbeTime() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastProbeTime() => clearField(3);
  @$pb.TagNumber(3)
  $0.Time ensureLastProbeTime() => $_ensure(2);

  /// lastTransitionTime is the time the condition transitioned from one status to another.
  /// +optional
  @$pb.TagNumber(4)
  $0.Time get lastTransitionTime => $_getN(3);
  @$pb.TagNumber(4)
  set lastTransitionTime($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLastTransitionTime() => $_has(3);
  @$pb.TagNumber(4)
  void clearLastTransitionTime() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureLastTransitionTime() => $_ensure(3);

  /// reason is a unique, this should be a short, machine understandable string that gives the reason
  /// for condition's last transition. If it reports "Resizing" that means the underlying
  /// persistent volume is being resized.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get reason => $_getSZ(4);
  @$pb.TagNumber(5)
  set reason($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasReason() => $_has(4);
  @$pb.TagNumber(5)
  void clearReason() => clearField(5);

  /// message is the human-readable message indicating details about last transition.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get message => $_getSZ(5);
  @$pb.TagNumber(6)
  set message($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasMessage() => $_has(5);
  @$pb.TagNumber(6)
  void clearMessage() => clearField(6);
}

/// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
class PersistentVolumeClaimList extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimList({
    $0.ListMeta? metadata,
    $core.Iterable<PersistentVolumeClaim>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  PersistentVolumeClaimList._() : super();
  factory PersistentVolumeClaimList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<PersistentVolumeClaim>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: PersistentVolumeClaim.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimList clone() => PersistentVolumeClaimList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimList copyWith(void Function(PersistentVolumeClaimList) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimList)) as PersistentVolumeClaimList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimList create() => PersistentVolumeClaimList._();
  PersistentVolumeClaimList createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimList> createRepeated() => $pb.PbList<PersistentVolumeClaimList>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimList>(create);
  static PersistentVolumeClaimList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// items is a list of persistent volume claims.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  @$pb.TagNumber(2)
  $core.List<PersistentVolumeClaim> get items => $_getList(1);
}

/// PersistentVolumeClaimSpec describes the common attributes of storage devices
/// and allows a Source for provider-specific attributes
class PersistentVolumeClaimSpec extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimSpec({
    $core.Iterable<$core.String>? accessModes,
    VolumeResourceRequirements? resources,
    $core.String? volumeName,
    $0.LabelSelector? selector,
    $core.String? storageClassName,
    $core.String? volumeMode,
    TypedLocalObjectReference? dataSource,
    TypedObjectReference? dataSourceRef,
    $core.String? volumeAttributesClassName,
  }) {
    final $result = create();
    if (accessModes != null) {
      $result.accessModes.addAll(accessModes);
    }
    if (resources != null) {
      $result.resources = resources;
    }
    if (volumeName != null) {
      $result.volumeName = volumeName;
    }
    if (selector != null) {
      $result.selector = selector;
    }
    if (storageClassName != null) {
      $result.storageClassName = storageClassName;
    }
    if (volumeMode != null) {
      $result.volumeMode = volumeMode;
    }
    if (dataSource != null) {
      $result.dataSource = dataSource;
    }
    if (dataSourceRef != null) {
      $result.dataSourceRef = dataSourceRef;
    }
    if (volumeAttributesClassName != null) {
      $result.volumeAttributesClassName = volumeAttributesClassName;
    }
    return $result;
  }
  PersistentVolumeClaimSpec._() : super();
  factory PersistentVolumeClaimSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'accessModes', protoName: 'accessModes')
    ..aOM<VolumeResourceRequirements>(2, _omitFieldNames ? '' : 'resources', subBuilder: VolumeResourceRequirements.create)
    ..aOS(3, _omitFieldNames ? '' : 'volumeName', protoName: 'volumeName')
    ..aOM<$0.LabelSelector>(4, _omitFieldNames ? '' : 'selector', subBuilder: $0.LabelSelector.create)
    ..aOS(5, _omitFieldNames ? '' : 'storageClassName', protoName: 'storageClassName')
    ..aOS(6, _omitFieldNames ? '' : 'volumeMode', protoName: 'volumeMode')
    ..aOM<TypedLocalObjectReference>(7, _omitFieldNames ? '' : 'dataSource', protoName: 'dataSource', subBuilder: TypedLocalObjectReference.create)
    ..aOM<TypedObjectReference>(8, _omitFieldNames ? '' : 'dataSourceRef', protoName: 'dataSourceRef', subBuilder: TypedObjectReference.create)
    ..aOS(9, _omitFieldNames ? '' : 'volumeAttributesClassName', protoName: 'volumeAttributesClassName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimSpec clone() => PersistentVolumeClaimSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimSpec copyWith(void Function(PersistentVolumeClaimSpec) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimSpec)) as PersistentVolumeClaimSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimSpec create() => PersistentVolumeClaimSpec._();
  PersistentVolumeClaimSpec createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimSpec> createRepeated() => $pb.PbList<PersistentVolumeClaimSpec>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimSpec>(create);
  static PersistentVolumeClaimSpec? _defaultInstance;

  /// accessModes contains the desired access modes the volume should have.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get accessModes => $_getList(0);

  /// resources represents the minimum resources the volume should have.
  /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
  /// that are lower than previous value but must still be higher than capacity recorded in the
  /// status field of the claim.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  /// +optional
  @$pb.TagNumber(2)
  VolumeResourceRequirements get resources => $_getN(1);
  @$pb.TagNumber(2)
  set resources(VolumeResourceRequirements v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasResources() => $_has(1);
  @$pb.TagNumber(2)
  void clearResources() => clearField(2);
  @$pb.TagNumber(2)
  VolumeResourceRequirements ensureResources() => $_ensure(1);

  /// volumeName is the binding reference to the PersistentVolume backing this claim.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get volumeName => $_getSZ(2);
  @$pb.TagNumber(3)
  set volumeName($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasVolumeName() => $_has(2);
  @$pb.TagNumber(3)
  void clearVolumeName() => clearField(3);

  /// selector is a label query over volumes to consider for binding.
  /// +optional
  @$pb.TagNumber(4)
  $0.LabelSelector get selector => $_getN(3);
  @$pb.TagNumber(4)
  set selector($0.LabelSelector v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasSelector() => $_has(3);
  @$pb.TagNumber(4)
  void clearSelector() => clearField(4);
  @$pb.TagNumber(4)
  $0.LabelSelector ensureSelector() => $_ensure(3);

  /// storageClassName is the name of the StorageClass required by the claim.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  /// +optional
  @$pb.TagNumber(5)
  $core.String get storageClassName => $_getSZ(4);
  @$pb.TagNumber(5)
  set storageClassName($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasStorageClassName() => $_has(4);
  @$pb.TagNumber(5)
  void clearStorageClassName() => clearField(5);

  /// volumeMode defines what type of volume is required by the claim.
  /// Value of Filesystem is implied when not included in claim spec.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get volumeMode => $_getSZ(5);
  @$pb.TagNumber(6)
  set volumeMode($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasVolumeMode() => $_has(5);
  @$pb.TagNumber(6)
  void clearVolumeMode() => clearField(6);

  /// dataSource field can be used to specify either:
  /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
  /// * An existing PVC (PersistentVolumeClaim)
  /// If the provisioner or an external controller can support the specified data source,
  /// it will create a new volume based on the contents of the specified data source.
  /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
  /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
  /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
  /// +optional
  @$pb.TagNumber(7)
  TypedLocalObjectReference get dataSource => $_getN(6);
  @$pb.TagNumber(7)
  set dataSource(TypedLocalObjectReference v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasDataSource() => $_has(6);
  @$pb.TagNumber(7)
  void clearDataSource() => clearField(7);
  @$pb.TagNumber(7)
  TypedLocalObjectReference ensureDataSource() => $_ensure(6);

  /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
  /// volume is desired. This may be any object from a non-empty API group (non
  /// core object) or a PersistentVolumeClaim object.
  /// When this field is specified, volume binding will only succeed if the type of
  /// the specified object matches some installed volume populator or dynamic
  /// provisioner.
  /// This field will replace the functionality of the dataSource field and as such
  /// if both fields are non-empty, they must have the same value. For backwards
  /// compatibility, when namespace isn't specified in dataSourceRef,
  /// both fields (dataSource and dataSourceRef) will be set to the same
  /// value automatically if one of them is empty and the other is non-empty.
  /// When namespace is specified in dataSourceRef,
  /// dataSource isn't set to the same value and must be empty.
  /// There are three important differences between dataSource and dataSourceRef:
  /// * While dataSource only allows two specific types of objects, dataSourceRef
  ///   allows any non-core object, as well as PersistentVolumeClaim objects.
  /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
  ///   preserves all values, and generates an error if a disallowed value is
  ///   specified.
  /// * While dataSource only allows local objects, dataSourceRef allows objects
  ///   in any namespaces.
  /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
  /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  /// +optional
  @$pb.TagNumber(8)
  TypedObjectReference get dataSourceRef => $_getN(7);
  @$pb.TagNumber(8)
  set dataSourceRef(TypedObjectReference v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasDataSourceRef() => $_has(7);
  @$pb.TagNumber(8)
  void clearDataSourceRef() => clearField(8);
  @$pb.TagNumber(8)
  TypedObjectReference ensureDataSourceRef() => $_ensure(7);

  /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
  /// If specified, the CSI driver will create or update the volume with the attributes defined
  /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
  /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
  /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
  /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
  /// will be set by the persistentvolume controller if it exists.
  /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
  /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
  /// exists.
  /// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
  /// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
  /// +featureGate=VolumeAttributesClass
  /// +optional
  @$pb.TagNumber(9)
  $core.String get volumeAttributesClassName => $_getSZ(8);
  @$pb.TagNumber(9)
  set volumeAttributesClassName($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasVolumeAttributesClassName() => $_has(8);
  @$pb.TagNumber(9)
  void clearVolumeAttributesClassName() => clearField(9);
}

/// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
class PersistentVolumeClaimStatus extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimStatus({
    $core.String? phase,
    $core.Iterable<$core.String>? accessModes,
    $core.Map<$core.String, $1.Quantity>? capacity,
    $core.Iterable<PersistentVolumeClaimCondition>? conditions,
    $core.Map<$core.String, $1.Quantity>? allocatedResources,
    $core.Map<$core.String, $core.String>? allocatedResourceStatuses,
    $core.String? currentVolumeAttributesClassName,
    ModifyVolumeStatus? modifyVolumeStatus,
  }) {
    final $result = create();
    if (phase != null) {
      $result.phase = phase;
    }
    if (accessModes != null) {
      $result.accessModes.addAll(accessModes);
    }
    if (capacity != null) {
      $result.capacity.addAll(capacity);
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    if (allocatedResources != null) {
      $result.allocatedResources.addAll(allocatedResources);
    }
    if (allocatedResourceStatuses != null) {
      $result.allocatedResourceStatuses.addAll(allocatedResourceStatuses);
    }
    if (currentVolumeAttributesClassName != null) {
      $result.currentVolumeAttributesClassName = currentVolumeAttributesClassName;
    }
    if (modifyVolumeStatus != null) {
      $result.modifyVolumeStatus = modifyVolumeStatus;
    }
    return $result;
  }
  PersistentVolumeClaimStatus._() : super();
  factory PersistentVolumeClaimStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'phase')
    ..pPS(2, _omitFieldNames ? '' : 'accessModes', protoName: 'accessModes')
    ..m<$core.String, $1.Quantity>(3, _omitFieldNames ? '' : 'capacity', entryClassName: 'PersistentVolumeClaimStatus.CapacityEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..pc<PersistentVolumeClaimCondition>(4, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: PersistentVolumeClaimCondition.create)
    ..m<$core.String, $1.Quantity>(5, _omitFieldNames ? '' : 'allocatedResources', protoName: 'allocatedResources', entryClassName: 'PersistentVolumeClaimStatus.AllocatedResourcesEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $core.String>(7, _omitFieldNames ? '' : 'allocatedResourceStatuses', protoName: 'allocatedResourceStatuses', entryClassName: 'PersistentVolumeClaimStatus.AllocatedResourceStatusesEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOS(8, _omitFieldNames ? '' : 'currentVolumeAttributesClassName', protoName: 'currentVolumeAttributesClassName')
    ..aOM<ModifyVolumeStatus>(9, _omitFieldNames ? '' : 'modifyVolumeStatus', protoName: 'modifyVolumeStatus', subBuilder: ModifyVolumeStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimStatus clone() => PersistentVolumeClaimStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimStatus copyWith(void Function(PersistentVolumeClaimStatus) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimStatus)) as PersistentVolumeClaimStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimStatus create() => PersistentVolumeClaimStatus._();
  PersistentVolumeClaimStatus createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimStatus> createRepeated() => $pb.PbList<PersistentVolumeClaimStatus>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimStatus>(create);
  static PersistentVolumeClaimStatus? _defaultInstance;

  /// phase represents the current phase of PersistentVolumeClaim.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get phase => $_getSZ(0);
  @$pb.TagNumber(1)
  set phase($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPhase() => $_has(0);
  @$pb.TagNumber(1)
  void clearPhase() => clearField(1);

  /// accessModes contains the actual access modes the volume backing the PVC has.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get accessModes => $_getList(1);

  /// capacity represents the actual resources of the underlying volume.
  /// +optional
  @$pb.TagNumber(3)
  $core.Map<$core.String, $1.Quantity> get capacity => $_getMap(2);

  /// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
  /// resized then the Condition will be set to 'Resizing'.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(4)
  $core.List<PersistentVolumeClaimCondition> get conditions => $_getList(3);

  ///  allocatedResources tracks the resources allocated to a PVC including its capacity.
  ///  Key names follow standard Kubernetes label syntax. Valid values are either:
  ///  	* Un-prefixed keys:
  ///  		- storage - the capacity of the volume.
  ///  	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
  ///  Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
  ///  reserved and hence may not be used.
  ///
  ///  Capacity reported here may be larger than the actual capacity when a volume expansion operation
  ///  is requested.
  ///  For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
  ///  If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
  ///  If a volume expansion capacity request is lowered, allocatedResources is only
  ///  lowered if there are no expansion operations in progress and if the actual volume capacity
  ///  is equal or lower than the requested capacity.
  ///
  ///  A controller that receives PVC update with previously unknown resourceName
  ///  should ignore the update for the purpose it was designed. For example - a controller that
  ///  only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
  ///  resources associated with PVC.
  ///
  ///  This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
  ///  +featureGate=RecoverVolumeExpansionFailure
  ///  +optional
  @$pb.TagNumber(5)
  $core.Map<$core.String, $1.Quantity> get allocatedResources => $_getMap(4);

  ///  allocatedResourceStatuses stores status of resource being resized for the given PVC.
  ///  Key names follow standard Kubernetes label syntax. Valid values are either:
  ///  	* Un-prefixed keys:
  ///  		- storage - the capacity of the volume.
  ///  	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
  ///  Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
  ///  reserved and hence may not be used.
  ///
  ///  ClaimResourceStatus can be in any of following states:
  ///  	- ControllerResizeInProgress:
  ///  		State set when resize controller starts resizing the volume in control-plane.
  ///  	- ControllerResizeFailed:
  ///  		State set when resize has failed in resize controller with a terminal error.
  ///  	- NodeResizePending:
  ///  		State set when resize controller has finished resizing the volume but further resizing of
  ///  		volume is needed on the node.
  ///  	- NodeResizeInProgress:
  ///  		State set when kubelet starts resizing the volume.
  ///  	- NodeResizeFailed:
  ///  		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
  ///  		NodeResizeFailed.
  ///  For example: if expanding a PVC for more capacity - this field can be one of the following states:
  ///  	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
  ///       - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
  ///       - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
  ///       - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
  ///       - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
  ///  When this field is not set, it means that no resize operation is in progress for the given PVC.
  ///
  ///  A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
  ///  should ignore the update for the purpose it was designed. For example - a controller that
  ///  only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
  ///  resources associated with PVC.
  ///
  ///  This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
  ///  +featureGate=RecoverVolumeExpansionFailure
  ///  +mapType=granular
  ///  +optional
  @$pb.TagNumber(7)
  $core.Map<$core.String, $core.String> get allocatedResourceStatuses => $_getMap(5);

  /// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
  /// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
  /// This is an alpha field and requires enabling VolumeAttributesClass feature.
  /// +featureGate=VolumeAttributesClass
  /// +optional
  @$pb.TagNumber(8)
  $core.String get currentVolumeAttributesClassName => $_getSZ(6);
  @$pb.TagNumber(8)
  set currentVolumeAttributesClassName($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(8)
  $core.bool hasCurrentVolumeAttributesClassName() => $_has(6);
  @$pb.TagNumber(8)
  void clearCurrentVolumeAttributesClassName() => clearField(8);

  /// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
  /// When this is unset, there is no ModifyVolume operation being attempted.
  /// This is an alpha field and requires enabling VolumeAttributesClass feature.
  /// +featureGate=VolumeAttributesClass
  /// +optional
  @$pb.TagNumber(9)
  ModifyVolumeStatus get modifyVolumeStatus => $_getN(7);
  @$pb.TagNumber(9)
  set modifyVolumeStatus(ModifyVolumeStatus v) { setField(9, v); }
  @$pb.TagNumber(9)
  $core.bool hasModifyVolumeStatus() => $_has(7);
  @$pb.TagNumber(9)
  void clearModifyVolumeStatus() => clearField(9);
  @$pb.TagNumber(9)
  ModifyVolumeStatus ensureModifyVolumeStatus() => $_ensure(7);
}

/// PersistentVolumeClaimTemplate is used to produce
/// PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
class PersistentVolumeClaimTemplate extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimTemplate({
    $0.ObjectMeta? metadata,
    PersistentVolumeClaimSpec? spec,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    return $result;
  }
  PersistentVolumeClaimTemplate._() : super();
  factory PersistentVolumeClaimTemplate.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimTemplate.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimTemplate', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PersistentVolumeClaimSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: PersistentVolumeClaimSpec.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimTemplate clone() => PersistentVolumeClaimTemplate()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimTemplate copyWith(void Function(PersistentVolumeClaimTemplate) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimTemplate)) as PersistentVolumeClaimTemplate;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimTemplate create() => PersistentVolumeClaimTemplate._();
  PersistentVolumeClaimTemplate createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimTemplate> createRepeated() => $pb.PbList<PersistentVolumeClaimTemplate>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimTemplate getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimTemplate>(create);
  static PersistentVolumeClaimTemplate? _defaultInstance;

  ///  May contain labels and annotations that will be copied into the PVC
  ///  when creating it. No other fields are allowed and will be rejected during
  ///  validation.
  ///
  ///  +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// The specification for the PersistentVolumeClaim. The entire content is
  /// copied unchanged into the PVC that gets created from this
  /// template. The same fields as in a PersistentVolumeClaim
  /// are also valid here.
  @$pb.TagNumber(2)
  PersistentVolumeClaimSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(PersistentVolumeClaimSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  PersistentVolumeClaimSpec ensureSpec() => $_ensure(1);
}

/// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
/// This volume finds the bound PV and mounts that volume for the pod. A
/// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
/// type of volume that is owned by someone else (the system).
class PersistentVolumeClaimVolumeSource extends $pb.GeneratedMessage {
  factory PersistentVolumeClaimVolumeSource({
    $core.String? claimName,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (claimName != null) {
      $result.claimName = claimName;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  PersistentVolumeClaimVolumeSource._() : super();
  factory PersistentVolumeClaimVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeClaimVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeClaimVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'claimName', protoName: 'claimName')
    ..aOB(2, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimVolumeSource clone() => PersistentVolumeClaimVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeClaimVolumeSource copyWith(void Function(PersistentVolumeClaimVolumeSource) updates) => super.copyWith((message) => updates(message as PersistentVolumeClaimVolumeSource)) as PersistentVolumeClaimVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimVolumeSource create() => PersistentVolumeClaimVolumeSource._();
  PersistentVolumeClaimVolumeSource createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeClaimVolumeSource> createRepeated() => $pb.PbList<PersistentVolumeClaimVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeClaimVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeClaimVolumeSource>(create);
  static PersistentVolumeClaimVolumeSource? _defaultInstance;

  /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  @$pb.TagNumber(1)
  $core.String get claimName => $_getSZ(0);
  @$pb.TagNumber(1)
  set claimName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasClaimName() => $_has(0);
  @$pb.TagNumber(1)
  void clearClaimName() => clearField(1);

  /// readOnly Will force the ReadOnly setting in VolumeMounts.
  /// Default false.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get readOnly => $_getBF(1);
  @$pb.TagNumber(2)
  set readOnly($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasReadOnly() => $_has(1);
  @$pb.TagNumber(2)
  void clearReadOnly() => clearField(2);
}

/// PersistentVolumeList is a list of PersistentVolume items.
class PersistentVolumeList extends $pb.GeneratedMessage {
  factory PersistentVolumeList({
    $0.ListMeta? metadata,
    $core.Iterable<PersistentVolume>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  PersistentVolumeList._() : super();
  factory PersistentVolumeList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<PersistentVolume>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: PersistentVolume.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeList clone() => PersistentVolumeList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeList copyWith(void Function(PersistentVolumeList) updates) => super.copyWith((message) => updates(message as PersistentVolumeList)) as PersistentVolumeList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeList create() => PersistentVolumeList._();
  PersistentVolumeList createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeList> createRepeated() => $pb.PbList<PersistentVolumeList>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeList>(create);
  static PersistentVolumeList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// items is a list of persistent volumes.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
  @$pb.TagNumber(2)
  $core.List<PersistentVolume> get items => $_getList(1);
}

/// PersistentVolumeSource is similar to VolumeSource but meant for the
/// administrator who creates PVs. Exactly one of its members must be set.
class PersistentVolumeSource extends $pb.GeneratedMessage {
  factory PersistentVolumeSource({
    GCEPersistentDiskVolumeSource? gcePersistentDisk,
    AWSElasticBlockStoreVolumeSource? awsElasticBlockStore,
    HostPathVolumeSource? hostPath,
    GlusterfsPersistentVolumeSource? glusterfs,
    NFSVolumeSource? nfs,
    RBDPersistentVolumeSource? rbd,
    ISCSIPersistentVolumeSource? iscsi,
    CinderPersistentVolumeSource? cinder,
    CephFSPersistentVolumeSource? cephfs,
    FCVolumeSource? fc,
    FlockerVolumeSource? flocker,
    FlexPersistentVolumeSource? flexVolume,
    AzureFilePersistentVolumeSource? azureFile,
    VsphereVirtualDiskVolumeSource? vsphereVolume,
    QuobyteVolumeSource? quobyte,
    AzureDiskVolumeSource? azureDisk,
    PhotonPersistentDiskVolumeSource? photonPersistentDisk,
    PortworxVolumeSource? portworxVolume,
    ScaleIOPersistentVolumeSource? scaleIO,
    LocalVolumeSource? local,
    StorageOSPersistentVolumeSource? storageos,
    CSIPersistentVolumeSource? csi,
  }) {
    final $result = create();
    if (gcePersistentDisk != null) {
      $result.gcePersistentDisk = gcePersistentDisk;
    }
    if (awsElasticBlockStore != null) {
      $result.awsElasticBlockStore = awsElasticBlockStore;
    }
    if (hostPath != null) {
      $result.hostPath = hostPath;
    }
    if (glusterfs != null) {
      $result.glusterfs = glusterfs;
    }
    if (nfs != null) {
      $result.nfs = nfs;
    }
    if (rbd != null) {
      $result.rbd = rbd;
    }
    if (iscsi != null) {
      $result.iscsi = iscsi;
    }
    if (cinder != null) {
      $result.cinder = cinder;
    }
    if (cephfs != null) {
      $result.cephfs = cephfs;
    }
    if (fc != null) {
      $result.fc = fc;
    }
    if (flocker != null) {
      $result.flocker = flocker;
    }
    if (flexVolume != null) {
      $result.flexVolume = flexVolume;
    }
    if (azureFile != null) {
      $result.azureFile = azureFile;
    }
    if (vsphereVolume != null) {
      $result.vsphereVolume = vsphereVolume;
    }
    if (quobyte != null) {
      $result.quobyte = quobyte;
    }
    if (azureDisk != null) {
      $result.azureDisk = azureDisk;
    }
    if (photonPersistentDisk != null) {
      $result.photonPersistentDisk = photonPersistentDisk;
    }
    if (portworxVolume != null) {
      $result.portworxVolume = portworxVolume;
    }
    if (scaleIO != null) {
      $result.scaleIO = scaleIO;
    }
    if (local != null) {
      $result.local = local;
    }
    if (storageos != null) {
      $result.storageos = storageos;
    }
    if (csi != null) {
      $result.csi = csi;
    }
    return $result;
  }
  PersistentVolumeSource._() : super();
  factory PersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<GCEPersistentDiskVolumeSource>(1, _omitFieldNames ? '' : 'gcePersistentDisk', protoName: 'gcePersistentDisk', subBuilder: GCEPersistentDiskVolumeSource.create)
    ..aOM<AWSElasticBlockStoreVolumeSource>(2, _omitFieldNames ? '' : 'awsElasticBlockStore', protoName: 'awsElasticBlockStore', subBuilder: AWSElasticBlockStoreVolumeSource.create)
    ..aOM<HostPathVolumeSource>(3, _omitFieldNames ? '' : 'hostPath', protoName: 'hostPath', subBuilder: HostPathVolumeSource.create)
    ..aOM<GlusterfsPersistentVolumeSource>(4, _omitFieldNames ? '' : 'glusterfs', subBuilder: GlusterfsPersistentVolumeSource.create)
    ..aOM<NFSVolumeSource>(5, _omitFieldNames ? '' : 'nfs', subBuilder: NFSVolumeSource.create)
    ..aOM<RBDPersistentVolumeSource>(6, _omitFieldNames ? '' : 'rbd', subBuilder: RBDPersistentVolumeSource.create)
    ..aOM<ISCSIPersistentVolumeSource>(7, _omitFieldNames ? '' : 'iscsi', subBuilder: ISCSIPersistentVolumeSource.create)
    ..aOM<CinderPersistentVolumeSource>(8, _omitFieldNames ? '' : 'cinder', subBuilder: CinderPersistentVolumeSource.create)
    ..aOM<CephFSPersistentVolumeSource>(9, _omitFieldNames ? '' : 'cephfs', subBuilder: CephFSPersistentVolumeSource.create)
    ..aOM<FCVolumeSource>(10, _omitFieldNames ? '' : 'fc', subBuilder: FCVolumeSource.create)
    ..aOM<FlockerVolumeSource>(11, _omitFieldNames ? '' : 'flocker', subBuilder: FlockerVolumeSource.create)
    ..aOM<FlexPersistentVolumeSource>(12, _omitFieldNames ? '' : 'flexVolume', protoName: 'flexVolume', subBuilder: FlexPersistentVolumeSource.create)
    ..aOM<AzureFilePersistentVolumeSource>(13, _omitFieldNames ? '' : 'azureFile', protoName: 'azureFile', subBuilder: AzureFilePersistentVolumeSource.create)
    ..aOM<VsphereVirtualDiskVolumeSource>(14, _omitFieldNames ? '' : 'vsphereVolume', protoName: 'vsphereVolume', subBuilder: VsphereVirtualDiskVolumeSource.create)
    ..aOM<QuobyteVolumeSource>(15, _omitFieldNames ? '' : 'quobyte', subBuilder: QuobyteVolumeSource.create)
    ..aOM<AzureDiskVolumeSource>(16, _omitFieldNames ? '' : 'azureDisk', protoName: 'azureDisk', subBuilder: AzureDiskVolumeSource.create)
    ..aOM<PhotonPersistentDiskVolumeSource>(17, _omitFieldNames ? '' : 'photonPersistentDisk', protoName: 'photonPersistentDisk', subBuilder: PhotonPersistentDiskVolumeSource.create)
    ..aOM<PortworxVolumeSource>(18, _omitFieldNames ? '' : 'portworxVolume', protoName: 'portworxVolume', subBuilder: PortworxVolumeSource.create)
    ..aOM<ScaleIOPersistentVolumeSource>(19, _omitFieldNames ? '' : 'scaleIO', protoName: 'scaleIO', subBuilder: ScaleIOPersistentVolumeSource.create)
    ..aOM<LocalVolumeSource>(20, _omitFieldNames ? '' : 'local', subBuilder: LocalVolumeSource.create)
    ..aOM<StorageOSPersistentVolumeSource>(21, _omitFieldNames ? '' : 'storageos', subBuilder: StorageOSPersistentVolumeSource.create)
    ..aOM<CSIPersistentVolumeSource>(22, _omitFieldNames ? '' : 'csi', subBuilder: CSIPersistentVolumeSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeSource clone() => PersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeSource copyWith(void Function(PersistentVolumeSource) updates) => super.copyWith((message) => updates(message as PersistentVolumeSource)) as PersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeSource create() => PersistentVolumeSource._();
  PersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeSource> createRepeated() => $pb.PbList<PersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeSource>(create);
  static PersistentVolumeSource? _defaultInstance;

  /// gcePersistentDisk represents a GCE Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  @$pb.TagNumber(1)
  GCEPersistentDiskVolumeSource get gcePersistentDisk => $_getN(0);
  @$pb.TagNumber(1)
  set gcePersistentDisk(GCEPersistentDiskVolumeSource v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasGcePersistentDisk() => $_has(0);
  @$pb.TagNumber(1)
  void clearGcePersistentDisk() => clearField(1);
  @$pb.TagNumber(1)
  GCEPersistentDiskVolumeSource ensureGcePersistentDisk() => $_ensure(0);

  /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  @$pb.TagNumber(2)
  AWSElasticBlockStoreVolumeSource get awsElasticBlockStore => $_getN(1);
  @$pb.TagNumber(2)
  set awsElasticBlockStore(AWSElasticBlockStoreVolumeSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasAwsElasticBlockStore() => $_has(1);
  @$pb.TagNumber(2)
  void clearAwsElasticBlockStore() => clearField(2);
  @$pb.TagNumber(2)
  AWSElasticBlockStoreVolumeSource ensureAwsElasticBlockStore() => $_ensure(1);

  /// hostPath represents a directory on the host.
  /// Provisioned by a developer or tester.
  /// This is useful for single-node development and testing only!
  /// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// +optional
  @$pb.TagNumber(3)
  HostPathVolumeSource get hostPath => $_getN(2);
  @$pb.TagNumber(3)
  set hostPath(HostPathVolumeSource v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasHostPath() => $_has(2);
  @$pb.TagNumber(3)
  void clearHostPath() => clearField(3);
  @$pb.TagNumber(3)
  HostPathVolumeSource ensureHostPath() => $_ensure(2);

  /// glusterfs represents a Glusterfs volume that is attached to a host and
  /// exposed to the pod. Provisioned by an admin.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
  /// +optional
  @$pb.TagNumber(4)
  GlusterfsPersistentVolumeSource get glusterfs => $_getN(3);
  @$pb.TagNumber(4)
  set glusterfs(GlusterfsPersistentVolumeSource v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasGlusterfs() => $_has(3);
  @$pb.TagNumber(4)
  void clearGlusterfs() => clearField(4);
  @$pb.TagNumber(4)
  GlusterfsPersistentVolumeSource ensureGlusterfs() => $_ensure(3);

  /// nfs represents an NFS mount on the host. Provisioned by an admin.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  @$pb.TagNumber(5)
  NFSVolumeSource get nfs => $_getN(4);
  @$pb.TagNumber(5)
  set nfs(NFSVolumeSource v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasNfs() => $_has(4);
  @$pb.TagNumber(5)
  void clearNfs() => clearField(5);
  @$pb.TagNumber(5)
  NFSVolumeSource ensureNfs() => $_ensure(4);

  /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md
  /// +optional
  @$pb.TagNumber(6)
  RBDPersistentVolumeSource get rbd => $_getN(5);
  @$pb.TagNumber(6)
  set rbd(RBDPersistentVolumeSource v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasRbd() => $_has(5);
  @$pb.TagNumber(6)
  void clearRbd() => clearField(6);
  @$pb.TagNumber(6)
  RBDPersistentVolumeSource ensureRbd() => $_ensure(5);

  /// iscsi represents an ISCSI Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  /// +optional
  @$pb.TagNumber(7)
  ISCSIPersistentVolumeSource get iscsi => $_getN(6);
  @$pb.TagNumber(7)
  set iscsi(ISCSIPersistentVolumeSource v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasIscsi() => $_has(6);
  @$pb.TagNumber(7)
  void clearIscsi() => clearField(7);
  @$pb.TagNumber(7)
  ISCSIPersistentVolumeSource ensureIscsi() => $_ensure(6);

  /// cinder represents a cinder volume attached and mounted on kubelets host machine.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(8)
  CinderPersistentVolumeSource get cinder => $_getN(7);
  @$pb.TagNumber(8)
  set cinder(CinderPersistentVolumeSource v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasCinder() => $_has(7);
  @$pb.TagNumber(8)
  void clearCinder() => clearField(8);
  @$pb.TagNumber(8)
  CinderPersistentVolumeSource ensureCinder() => $_ensure(7);

  /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  /// +optional
  @$pb.TagNumber(9)
  CephFSPersistentVolumeSource get cephfs => $_getN(8);
  @$pb.TagNumber(9)
  set cephfs(CephFSPersistentVolumeSource v) { setField(9, v); }
  @$pb.TagNumber(9)
  $core.bool hasCephfs() => $_has(8);
  @$pb.TagNumber(9)
  void clearCephfs() => clearField(9);
  @$pb.TagNumber(9)
  CephFSPersistentVolumeSource ensureCephfs() => $_ensure(8);

  /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  /// +optional
  @$pb.TagNumber(10)
  FCVolumeSource get fc => $_getN(9);
  @$pb.TagNumber(10)
  set fc(FCVolumeSource v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasFc() => $_has(9);
  @$pb.TagNumber(10)
  void clearFc() => clearField(10);
  @$pb.TagNumber(10)
  FCVolumeSource ensureFc() => $_ensure(9);

  /// flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  /// +optional
  @$pb.TagNumber(11)
  FlockerVolumeSource get flocker => $_getN(10);
  @$pb.TagNumber(11)
  set flocker(FlockerVolumeSource v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasFlocker() => $_has(10);
  @$pb.TagNumber(11)
  void clearFlocker() => clearField(11);
  @$pb.TagNumber(11)
  FlockerVolumeSource ensureFlocker() => $_ensure(10);

  /// flexVolume represents a generic volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// +optional
  @$pb.TagNumber(12)
  FlexPersistentVolumeSource get flexVolume => $_getN(11);
  @$pb.TagNumber(12)
  set flexVolume(FlexPersistentVolumeSource v) { setField(12, v); }
  @$pb.TagNumber(12)
  $core.bool hasFlexVolume() => $_has(11);
  @$pb.TagNumber(12)
  void clearFlexVolume() => clearField(12);
  @$pb.TagNumber(12)
  FlexPersistentVolumeSource ensureFlexVolume() => $_ensure(11);

  /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// +optional
  @$pb.TagNumber(13)
  AzureFilePersistentVolumeSource get azureFile => $_getN(12);
  @$pb.TagNumber(13)
  set azureFile(AzureFilePersistentVolumeSource v) { setField(13, v); }
  @$pb.TagNumber(13)
  $core.bool hasAzureFile() => $_has(12);
  @$pb.TagNumber(13)
  void clearAzureFile() => clearField(13);
  @$pb.TagNumber(13)
  AzureFilePersistentVolumeSource ensureAzureFile() => $_ensure(12);

  /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  /// +optional
  @$pb.TagNumber(14)
  VsphereVirtualDiskVolumeSource get vsphereVolume => $_getN(13);
  @$pb.TagNumber(14)
  set vsphereVolume(VsphereVirtualDiskVolumeSource v) { setField(14, v); }
  @$pb.TagNumber(14)
  $core.bool hasVsphereVolume() => $_has(13);
  @$pb.TagNumber(14)
  void clearVsphereVolume() => clearField(14);
  @$pb.TagNumber(14)
  VsphereVirtualDiskVolumeSource ensureVsphereVolume() => $_ensure(13);

  /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  /// +optional
  @$pb.TagNumber(15)
  QuobyteVolumeSource get quobyte => $_getN(14);
  @$pb.TagNumber(15)
  set quobyte(QuobyteVolumeSource v) { setField(15, v); }
  @$pb.TagNumber(15)
  $core.bool hasQuobyte() => $_has(14);
  @$pb.TagNumber(15)
  void clearQuobyte() => clearField(15);
  @$pb.TagNumber(15)
  QuobyteVolumeSource ensureQuobyte() => $_ensure(14);

  /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  /// +optional
  @$pb.TagNumber(16)
  AzureDiskVolumeSource get azureDisk => $_getN(15);
  @$pb.TagNumber(16)
  set azureDisk(AzureDiskVolumeSource v) { setField(16, v); }
  @$pb.TagNumber(16)
  $core.bool hasAzureDisk() => $_has(15);
  @$pb.TagNumber(16)
  void clearAzureDisk() => clearField(16);
  @$pb.TagNumber(16)
  AzureDiskVolumeSource ensureAzureDisk() => $_ensure(15);

  /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  @$pb.TagNumber(17)
  PhotonPersistentDiskVolumeSource get photonPersistentDisk => $_getN(16);
  @$pb.TagNumber(17)
  set photonPersistentDisk(PhotonPersistentDiskVolumeSource v) { setField(17, v); }
  @$pb.TagNumber(17)
  $core.bool hasPhotonPersistentDisk() => $_has(16);
  @$pb.TagNumber(17)
  void clearPhotonPersistentDisk() => clearField(17);
  @$pb.TagNumber(17)
  PhotonPersistentDiskVolumeSource ensurePhotonPersistentDisk() => $_ensure(16);

  /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
  /// +optional
  @$pb.TagNumber(18)
  PortworxVolumeSource get portworxVolume => $_getN(17);
  @$pb.TagNumber(18)
  set portworxVolume(PortworxVolumeSource v) { setField(18, v); }
  @$pb.TagNumber(18)
  $core.bool hasPortworxVolume() => $_has(17);
  @$pb.TagNumber(18)
  void clearPortworxVolume() => clearField(18);
  @$pb.TagNumber(18)
  PortworxVolumeSource ensurePortworxVolume() => $_ensure(17);

  /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  /// +optional
  @$pb.TagNumber(19)
  ScaleIOPersistentVolumeSource get scaleIO => $_getN(18);
  @$pb.TagNumber(19)
  set scaleIO(ScaleIOPersistentVolumeSource v) { setField(19, v); }
  @$pb.TagNumber(19)
  $core.bool hasScaleIO() => $_has(18);
  @$pb.TagNumber(19)
  void clearScaleIO() => clearField(19);
  @$pb.TagNumber(19)
  ScaleIOPersistentVolumeSource ensureScaleIO() => $_ensure(18);

  /// local represents directly-attached storage with node affinity
  /// +optional
  @$pb.TagNumber(20)
  LocalVolumeSource get local => $_getN(19);
  @$pb.TagNumber(20)
  set local(LocalVolumeSource v) { setField(20, v); }
  @$pb.TagNumber(20)
  $core.bool hasLocal() => $_has(19);
  @$pb.TagNumber(20)
  void clearLocal() => clearField(20);
  @$pb.TagNumber(20)
  LocalVolumeSource ensureLocal() => $_ensure(19);

  /// storageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
  /// More info: https://examples.k8s.io/volumes/storageos/README.md
  /// +optional
  @$pb.TagNumber(21)
  StorageOSPersistentVolumeSource get storageos => $_getN(20);
  @$pb.TagNumber(21)
  set storageos(StorageOSPersistentVolumeSource v) { setField(21, v); }
  @$pb.TagNumber(21)
  $core.bool hasStorageos() => $_has(20);
  @$pb.TagNumber(21)
  void clearStorageos() => clearField(21);
  @$pb.TagNumber(21)
  StorageOSPersistentVolumeSource ensureStorageos() => $_ensure(20);

  /// csi represents storage that is handled by an external CSI driver (Beta feature).
  /// +optional
  @$pb.TagNumber(22)
  CSIPersistentVolumeSource get csi => $_getN(21);
  @$pb.TagNumber(22)
  set csi(CSIPersistentVolumeSource v) { setField(22, v); }
  @$pb.TagNumber(22)
  $core.bool hasCsi() => $_has(21);
  @$pb.TagNumber(22)
  void clearCsi() => clearField(22);
  @$pb.TagNumber(22)
  CSIPersistentVolumeSource ensureCsi() => $_ensure(21);
}

/// PersistentVolumeSpec is the specification of a persistent volume.
class PersistentVolumeSpec extends $pb.GeneratedMessage {
  factory PersistentVolumeSpec({
    $core.Map<$core.String, $1.Quantity>? capacity,
    PersistentVolumeSource? persistentVolumeSource,
    $core.Iterable<$core.String>? accessModes,
    ObjectReference? claimRef,
    $core.String? persistentVolumeReclaimPolicy,
    $core.String? storageClassName,
    $core.Iterable<$core.String>? mountOptions,
    $core.String? volumeMode,
    VolumeNodeAffinity? nodeAffinity,
    $core.String? volumeAttributesClassName,
  }) {
    final $result = create();
    if (capacity != null) {
      $result.capacity.addAll(capacity);
    }
    if (persistentVolumeSource != null) {
      $result.persistentVolumeSource = persistentVolumeSource;
    }
    if (accessModes != null) {
      $result.accessModes.addAll(accessModes);
    }
    if (claimRef != null) {
      $result.claimRef = claimRef;
    }
    if (persistentVolumeReclaimPolicy != null) {
      $result.persistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
    }
    if (storageClassName != null) {
      $result.storageClassName = storageClassName;
    }
    if (mountOptions != null) {
      $result.mountOptions.addAll(mountOptions);
    }
    if (volumeMode != null) {
      $result.volumeMode = volumeMode;
    }
    if (nodeAffinity != null) {
      $result.nodeAffinity = nodeAffinity;
    }
    if (volumeAttributesClassName != null) {
      $result.volumeAttributesClassName = volumeAttributesClassName;
    }
    return $result;
  }
  PersistentVolumeSpec._() : super();
  factory PersistentVolumeSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'capacity', entryClassName: 'PersistentVolumeSpec.CapacityEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..aOM<PersistentVolumeSource>(2, _omitFieldNames ? '' : 'persistentVolumeSource', protoName: 'persistentVolumeSource', subBuilder: PersistentVolumeSource.create)
    ..pPS(3, _omitFieldNames ? '' : 'accessModes', protoName: 'accessModes')
    ..aOM<ObjectReference>(4, _omitFieldNames ? '' : 'claimRef', protoName: 'claimRef', subBuilder: ObjectReference.create)
    ..aOS(5, _omitFieldNames ? '' : 'persistentVolumeReclaimPolicy', protoName: 'persistentVolumeReclaimPolicy')
    ..aOS(6, _omitFieldNames ? '' : 'storageClassName', protoName: 'storageClassName')
    ..pPS(7, _omitFieldNames ? '' : 'mountOptions', protoName: 'mountOptions')
    ..aOS(8, _omitFieldNames ? '' : 'volumeMode', protoName: 'volumeMode')
    ..aOM<VolumeNodeAffinity>(9, _omitFieldNames ? '' : 'nodeAffinity', protoName: 'nodeAffinity', subBuilder: VolumeNodeAffinity.create)
    ..aOS(10, _omitFieldNames ? '' : 'volumeAttributesClassName', protoName: 'volumeAttributesClassName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeSpec clone() => PersistentVolumeSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeSpec copyWith(void Function(PersistentVolumeSpec) updates) => super.copyWith((message) => updates(message as PersistentVolumeSpec)) as PersistentVolumeSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeSpec create() => PersistentVolumeSpec._();
  PersistentVolumeSpec createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeSpec> createRepeated() => $pb.PbList<PersistentVolumeSpec>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeSpec>(create);
  static PersistentVolumeSpec? _defaultInstance;

  /// capacity is the description of the persistent volume's resources and capacity.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get capacity => $_getMap(0);

  /// persistentVolumeSource is the actual volume backing the persistent volume.
  @$pb.TagNumber(2)
  PersistentVolumeSource get persistentVolumeSource => $_getN(1);
  @$pb.TagNumber(2)
  set persistentVolumeSource(PersistentVolumeSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPersistentVolumeSource() => $_has(1);
  @$pb.TagNumber(2)
  void clearPersistentVolumeSource() => clearField(2);
  @$pb.TagNumber(2)
  PersistentVolumeSource ensurePersistentVolumeSource() => $_ensure(1);

  /// accessModes contains all ways the volume can be mounted.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<$core.String> get accessModes => $_getList(2);

  /// claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
  /// Expected to be non-nil when bound.
  /// claim.VolumeName is the authoritative bind between PV and PVC.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
  /// +optional
  /// +structType=granular
  @$pb.TagNumber(4)
  ObjectReference get claimRef => $_getN(3);
  @$pb.TagNumber(4)
  set claimRef(ObjectReference v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasClaimRef() => $_has(3);
  @$pb.TagNumber(4)
  void clearClaimRef() => clearField(4);
  @$pb.TagNumber(4)
  ObjectReference ensureClaimRef() => $_ensure(3);

  /// persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.
  /// Valid options are Retain (default for manually created PersistentVolumes), Delete (default
  /// for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
  /// Recycle must be supported by the volume plugin underlying this PersistentVolume.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
  /// +optional
  @$pb.TagNumber(5)
  $core.String get persistentVolumeReclaimPolicy => $_getSZ(4);
  @$pb.TagNumber(5)
  set persistentVolumeReclaimPolicy($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasPersistentVolumeReclaimPolicy() => $_has(4);
  @$pb.TagNumber(5)
  void clearPersistentVolumeReclaimPolicy() => clearField(5);

  /// storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value
  /// means that this volume does not belong to any StorageClass.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get storageClassName => $_getSZ(5);
  @$pb.TagNumber(6)
  set storageClassName($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasStorageClassName() => $_has(5);
  @$pb.TagNumber(6)
  void clearStorageClassName() => clearField(6);

  /// mountOptions is the list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
  /// simply fail if one is invalid.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(7)
  $core.List<$core.String> get mountOptions => $_getList(6);

  /// volumeMode defines if a volume is intended to be used with a formatted filesystem
  /// or to remain in raw block state. Value of Filesystem is implied when not included in spec.
  /// +optional
  @$pb.TagNumber(8)
  $core.String get volumeMode => $_getSZ(7);
  @$pb.TagNumber(8)
  set volumeMode($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasVolumeMode() => $_has(7);
  @$pb.TagNumber(8)
  void clearVolumeMode() => clearField(8);

  /// nodeAffinity defines constraints that limit what nodes this volume can be accessed from.
  /// This field influences the scheduling of pods that use this volume.
  /// +optional
  @$pb.TagNumber(9)
  VolumeNodeAffinity get nodeAffinity => $_getN(8);
  @$pb.TagNumber(9)
  set nodeAffinity(VolumeNodeAffinity v) { setField(9, v); }
  @$pb.TagNumber(9)
  $core.bool hasNodeAffinity() => $_has(8);
  @$pb.TagNumber(9)
  void clearNodeAffinity() => clearField(9);
  @$pb.TagNumber(9)
  VolumeNodeAffinity ensureNodeAffinity() => $_ensure(8);

  /// Name of VolumeAttributesClass to which this persistent volume belongs. Empty value
  /// is not allowed. When this field is not set, it indicates that this volume does not belong to any
  /// VolumeAttributesClass. This field is mutable and can be changed by the CSI driver
  /// after a volume has been updated successfully to a new class.
  /// For an unbound PersistentVolume, the volumeAttributesClassName will be matched with unbound
  /// PersistentVolumeClaims during the binding process.
  /// This is an alpha field and requires enabling VolumeAttributesClass feature.
  /// +featureGate=VolumeAttributesClass
  /// +optional
  @$pb.TagNumber(10)
  $core.String get volumeAttributesClassName => $_getSZ(9);
  @$pb.TagNumber(10)
  set volumeAttributesClassName($core.String v) { $_setString(9, v); }
  @$pb.TagNumber(10)
  $core.bool hasVolumeAttributesClassName() => $_has(9);
  @$pb.TagNumber(10)
  void clearVolumeAttributesClassName() => clearField(10);
}

/// PersistentVolumeStatus is the current status of a persistent volume.
class PersistentVolumeStatus extends $pb.GeneratedMessage {
  factory PersistentVolumeStatus({
    $core.String? phase,
    $core.String? message,
    $core.String? reason,
    $0.Time? lastPhaseTransitionTime,
  }) {
    final $result = create();
    if (phase != null) {
      $result.phase = phase;
    }
    if (message != null) {
      $result.message = message;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (lastPhaseTransitionTime != null) {
      $result.lastPhaseTransitionTime = lastPhaseTransitionTime;
    }
    return $result;
  }
  PersistentVolumeStatus._() : super();
  factory PersistentVolumeStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PersistentVolumeStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PersistentVolumeStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'phase')
    ..aOS(2, _omitFieldNames ? '' : 'message')
    ..aOS(3, _omitFieldNames ? '' : 'reason')
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'lastPhaseTransitionTime', protoName: 'lastPhaseTransitionTime', subBuilder: $0.Time.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PersistentVolumeStatus clone() => PersistentVolumeStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PersistentVolumeStatus copyWith(void Function(PersistentVolumeStatus) updates) => super.copyWith((message) => updates(message as PersistentVolumeStatus)) as PersistentVolumeStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PersistentVolumeStatus create() => PersistentVolumeStatus._();
  PersistentVolumeStatus createEmptyInstance() => create();
  static $pb.PbList<PersistentVolumeStatus> createRepeated() => $pb.PbList<PersistentVolumeStatus>();
  @$core.pragma('dart2js:noInline')
  static PersistentVolumeStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PersistentVolumeStatus>(create);
  static PersistentVolumeStatus? _defaultInstance;

  /// phase indicates if a volume is available, bound to a claim, or released by a claim.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
  /// +optional
  @$pb.TagNumber(1)
  $core.String get phase => $_getSZ(0);
  @$pb.TagNumber(1)
  set phase($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPhase() => $_has(0);
  @$pb.TagNumber(1)
  void clearPhase() => clearField(1);

  /// message is a human-readable message indicating details about why the volume is in this state.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get message => $_getSZ(1);
  @$pb.TagNumber(2)
  set message($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasMessage() => $_has(1);
  @$pb.TagNumber(2)
  void clearMessage() => clearField(2);

  /// reason is a brief CamelCase string that describes any failure and is meant
  /// for machine parsing and tidy display in the CLI.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get reason => $_getSZ(2);
  @$pb.TagNumber(3)
  set reason($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReason() => $_has(2);
  @$pb.TagNumber(3)
  void clearReason() => clearField(3);

  /// lastPhaseTransitionTime is the time the phase transitioned from one to another
  /// and automatically resets to current time everytime a volume phase transitions.
  /// This is a beta field and requires the PersistentVolumeLastPhaseTransitionTime feature to be enabled (enabled by default).
  /// +featureGate=PersistentVolumeLastPhaseTransitionTime
  /// +optional
  @$pb.TagNumber(4)
  $0.Time get lastPhaseTransitionTime => $_getN(3);
  @$pb.TagNumber(4)
  set lastPhaseTransitionTime($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLastPhaseTransitionTime() => $_has(3);
  @$pb.TagNumber(4)
  void clearLastPhaseTransitionTime() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureLastPhaseTransitionTime() => $_ensure(3);
}

/// Represents a Photon Controller persistent disk resource.
class PhotonPersistentDiskVolumeSource extends $pb.GeneratedMessage {
  factory PhotonPersistentDiskVolumeSource({
    $core.String? pdID,
    $core.String? fsType,
  }) {
    final $result = create();
    if (pdID != null) {
      $result.pdID = pdID;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    return $result;
  }
  PhotonPersistentDiskVolumeSource._() : super();
  factory PhotonPersistentDiskVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PhotonPersistentDiskVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PhotonPersistentDiskVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'pdID', protoName: 'pdID')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PhotonPersistentDiskVolumeSource clone() => PhotonPersistentDiskVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PhotonPersistentDiskVolumeSource copyWith(void Function(PhotonPersistentDiskVolumeSource) updates) => super.copyWith((message) => updates(message as PhotonPersistentDiskVolumeSource)) as PhotonPersistentDiskVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PhotonPersistentDiskVolumeSource create() => PhotonPersistentDiskVolumeSource._();
  PhotonPersistentDiskVolumeSource createEmptyInstance() => create();
  static $pb.PbList<PhotonPersistentDiskVolumeSource> createRepeated() => $pb.PbList<PhotonPersistentDiskVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static PhotonPersistentDiskVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PhotonPersistentDiskVolumeSource>(create);
  static PhotonPersistentDiskVolumeSource? _defaultInstance;

  /// pdID is the ID that identifies Photon Controller persistent disk
  @$pb.TagNumber(1)
  $core.String get pdID => $_getSZ(0);
  @$pb.TagNumber(1)
  set pdID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPdID() => $_has(0);
  @$pb.TagNumber(1)
  void clearPdID() => clearField(1);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);
}

/// Pod is a collection of containers that can run on a host. This resource is created
/// by clients and scheduled onto hosts.
class Pod extends $pb.GeneratedMessage {
  factory Pod({
    $0.ObjectMeta? metadata,
    PodSpec? spec,
    PodStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  Pod._() : super();
  factory Pod.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Pod.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Pod', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PodSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: PodSpec.create)
    ..aOM<PodStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: PodStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Pod clone() => Pod()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Pod copyWith(void Function(Pod) updates) => super.copyWith((message) => updates(message as Pod)) as Pod;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Pod create() => Pod._();
  Pod createEmptyInstance() => create();
  static $pb.PbList<Pod> createRepeated() => $pb.PbList<Pod>();
  @$core.pragma('dart2js:noInline')
  static Pod getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Pod>(create);
  static Pod? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Specification of the desired behavior of the pod.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  PodSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(PodSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  PodSpec ensureSpec() => $_ensure(1);

  /// Most recently observed status of the pod.
  /// This data may not be up to date.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  PodStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(PodStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  PodStatus ensureStatus() => $_ensure(2);
}

/// Pod affinity is a group of inter pod affinity scheduling rules.
class PodAffinity extends $pb.GeneratedMessage {
  factory PodAffinity({
    $core.Iterable<PodAffinityTerm>? requiredDuringSchedulingIgnoredDuringExecution,
    $core.Iterable<WeightedPodAffinityTerm>? preferredDuringSchedulingIgnoredDuringExecution,
  }) {
    final $result = create();
    if (requiredDuringSchedulingIgnoredDuringExecution != null) {
      $result.requiredDuringSchedulingIgnoredDuringExecution.addAll(requiredDuringSchedulingIgnoredDuringExecution);
    }
    if (preferredDuringSchedulingIgnoredDuringExecution != null) {
      $result.preferredDuringSchedulingIgnoredDuringExecution.addAll(preferredDuringSchedulingIgnoredDuringExecution);
    }
    return $result;
  }
  PodAffinity._() : super();
  factory PodAffinity.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodAffinity.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodAffinity', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<PodAffinityTerm>(1, _omitFieldNames ? '' : 'requiredDuringSchedulingIgnoredDuringExecution', $pb.PbFieldType.PM, protoName: 'requiredDuringSchedulingIgnoredDuringExecution', subBuilder: PodAffinityTerm.create)
    ..pc<WeightedPodAffinityTerm>(2, _omitFieldNames ? '' : 'preferredDuringSchedulingIgnoredDuringExecution', $pb.PbFieldType.PM, protoName: 'preferredDuringSchedulingIgnoredDuringExecution', subBuilder: WeightedPodAffinityTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodAffinity clone() => PodAffinity()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodAffinity copyWith(void Function(PodAffinity) updates) => super.copyWith((message) => updates(message as PodAffinity)) as PodAffinity;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodAffinity create() => PodAffinity._();
  PodAffinity createEmptyInstance() => create();
  static $pb.PbList<PodAffinity> createRepeated() => $pb.PbList<PodAffinity>();
  @$core.pragma('dart2js:noInline')
  static PodAffinity getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodAffinity>(create);
  static PodAffinity? _defaultInstance;

  /// If the affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to a pod label update), the
  /// system may or may not try to eventually evict the pod from its node.
  /// When there are multiple elements, the lists of nodes corresponding to each
  /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<PodAffinityTerm> get requiredDuringSchedulingIgnoredDuringExecution => $_getList(0);

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<WeightedPodAffinityTerm> get preferredDuringSchedulingIgnoredDuringExecution => $_getList(1);
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
class PodAffinityTerm extends $pb.GeneratedMessage {
  factory PodAffinityTerm({
    $0.LabelSelector? labelSelector,
    $core.Iterable<$core.String>? namespaces,
    $core.String? topologyKey,
    $0.LabelSelector? namespaceSelector,
    $core.Iterable<$core.String>? matchLabelKeys,
    $core.Iterable<$core.String>? mismatchLabelKeys,
  }) {
    final $result = create();
    if (labelSelector != null) {
      $result.labelSelector = labelSelector;
    }
    if (namespaces != null) {
      $result.namespaces.addAll(namespaces);
    }
    if (topologyKey != null) {
      $result.topologyKey = topologyKey;
    }
    if (namespaceSelector != null) {
      $result.namespaceSelector = namespaceSelector;
    }
    if (matchLabelKeys != null) {
      $result.matchLabelKeys.addAll(matchLabelKeys);
    }
    if (mismatchLabelKeys != null) {
      $result.mismatchLabelKeys.addAll(mismatchLabelKeys);
    }
    return $result;
  }
  PodAffinityTerm._() : super();
  factory PodAffinityTerm.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodAffinityTerm.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodAffinityTerm', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.LabelSelector>(1, _omitFieldNames ? '' : 'labelSelector', protoName: 'labelSelector', subBuilder: $0.LabelSelector.create)
    ..pPS(2, _omitFieldNames ? '' : 'namespaces')
    ..aOS(3, _omitFieldNames ? '' : 'topologyKey', protoName: 'topologyKey')
    ..aOM<$0.LabelSelector>(4, _omitFieldNames ? '' : 'namespaceSelector', protoName: 'namespaceSelector', subBuilder: $0.LabelSelector.create)
    ..pPS(5, _omitFieldNames ? '' : 'matchLabelKeys', protoName: 'matchLabelKeys')
    ..pPS(6, _omitFieldNames ? '' : 'mismatchLabelKeys', protoName: 'mismatchLabelKeys')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodAffinityTerm clone() => PodAffinityTerm()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodAffinityTerm copyWith(void Function(PodAffinityTerm) updates) => super.copyWith((message) => updates(message as PodAffinityTerm)) as PodAffinityTerm;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodAffinityTerm create() => PodAffinityTerm._();
  PodAffinityTerm createEmptyInstance() => create();
  static $pb.PbList<PodAffinityTerm> createRepeated() => $pb.PbList<PodAffinityTerm>();
  @$core.pragma('dart2js:noInline')
  static PodAffinityTerm getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodAffinityTerm>(create);
  static PodAffinityTerm? _defaultInstance;

  /// A label query over a set of resources, in this case pods.
  /// If it's null, this PodAffinityTerm matches with no Pods.
  /// +optional
  @$pb.TagNumber(1)
  $0.LabelSelector get labelSelector => $_getN(0);
  @$pb.TagNumber(1)
  set labelSelector($0.LabelSelector v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLabelSelector() => $_has(0);
  @$pb.TagNumber(1)
  void clearLabelSelector() => clearField(1);
  @$pb.TagNumber(1)
  $0.LabelSelector ensureLabelSelector() => $_ensure(0);

  /// namespaces specifies a static list of namespace names that the term applies to.
  /// The term is applied to the union of the namespaces listed in this field
  /// and the ones selected by namespaceSelector.
  /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get namespaces => $_getList(1);

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the
  /// selected pods is running.
  /// Empty topologyKey is not allowed.
  @$pb.TagNumber(3)
  $core.String get topologyKey => $_getSZ(2);
  @$pb.TagNumber(3)
  set topologyKey($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasTopologyKey() => $_has(2);
  @$pb.TagNumber(3)
  void clearTopologyKey() => clearField(3);

  /// A label query over the set of namespaces that the term applies to.
  /// The term is applied to the union of the namespaces selected by this field
  /// and the ones listed in the namespaces field.
  /// null selector and null or empty namespaces list means "this pod's namespace".
  /// An empty selector ({}) matches all namespaces.
  /// +optional
  @$pb.TagNumber(4)
  $0.LabelSelector get namespaceSelector => $_getN(3);
  @$pb.TagNumber(4)
  set namespaceSelector($0.LabelSelector v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasNamespaceSelector() => $_has(3);
  @$pb.TagNumber(4)
  void clearNamespaceSelector() => clearField(4);
  @$pb.TagNumber(4)
  $0.LabelSelector ensureNamespaceSelector() => $_ensure(3);

  /// MatchLabelKeys is a set of pod label keys to select which pods will
  /// be taken into consideration. The keys are used to lookup values from the
  /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
  /// to select the group of existing pods which pods will be taken into consideration
  /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
  /// pod labels will be ignored. The default value is empty.
  /// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
  /// Also, matchLabelKeys cannot be set when labelSelector isn't set.
  /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
  /// +listType=atomic
  /// +optional
  @$pb.TagNumber(5)
  $core.List<$core.String> get matchLabelKeys => $_getList(4);

  /// MismatchLabelKeys is a set of pod label keys to select which pods will
  /// be taken into consideration. The keys are used to lookup values from the
  /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
  /// to select the group of existing pods which pods will be taken into consideration
  /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
  /// pod labels will be ignored. The default value is empty.
  /// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
  /// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
  /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
  /// +listType=atomic
  /// +optional
  @$pb.TagNumber(6)
  $core.List<$core.String> get mismatchLabelKeys => $_getList(5);
}

/// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
class PodAntiAffinity extends $pb.GeneratedMessage {
  factory PodAntiAffinity({
    $core.Iterable<PodAffinityTerm>? requiredDuringSchedulingIgnoredDuringExecution,
    $core.Iterable<WeightedPodAffinityTerm>? preferredDuringSchedulingIgnoredDuringExecution,
  }) {
    final $result = create();
    if (requiredDuringSchedulingIgnoredDuringExecution != null) {
      $result.requiredDuringSchedulingIgnoredDuringExecution.addAll(requiredDuringSchedulingIgnoredDuringExecution);
    }
    if (preferredDuringSchedulingIgnoredDuringExecution != null) {
      $result.preferredDuringSchedulingIgnoredDuringExecution.addAll(preferredDuringSchedulingIgnoredDuringExecution);
    }
    return $result;
  }
  PodAntiAffinity._() : super();
  factory PodAntiAffinity.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodAntiAffinity.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodAntiAffinity', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<PodAffinityTerm>(1, _omitFieldNames ? '' : 'requiredDuringSchedulingIgnoredDuringExecution', $pb.PbFieldType.PM, protoName: 'requiredDuringSchedulingIgnoredDuringExecution', subBuilder: PodAffinityTerm.create)
    ..pc<WeightedPodAffinityTerm>(2, _omitFieldNames ? '' : 'preferredDuringSchedulingIgnoredDuringExecution', $pb.PbFieldType.PM, protoName: 'preferredDuringSchedulingIgnoredDuringExecution', subBuilder: WeightedPodAffinityTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodAntiAffinity clone() => PodAntiAffinity()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodAntiAffinity copyWith(void Function(PodAntiAffinity) updates) => super.copyWith((message) => updates(message as PodAntiAffinity)) as PodAntiAffinity;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodAntiAffinity create() => PodAntiAffinity._();
  PodAntiAffinity createEmptyInstance() => create();
  static $pb.PbList<PodAntiAffinity> createRepeated() => $pb.PbList<PodAntiAffinity>();
  @$core.pragma('dart2js:noInline')
  static PodAntiAffinity getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodAntiAffinity>(create);
  static PodAntiAffinity? _defaultInstance;

  /// If the anti-affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the anti-affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to a pod label update), the
  /// system may or may not try to eventually evict the pod from its node.
  /// When there are multiple elements, the lists of nodes corresponding to each
  /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<PodAffinityTerm> get requiredDuringSchedulingIgnoredDuringExecution => $_getList(0);

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the anti-affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling anti-affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<WeightedPodAffinityTerm> get preferredDuringSchedulingIgnoredDuringExecution => $_getList(1);
}

/// PodAttachOptions is the query options to a Pod's remote attach call.
/// ---
/// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
/// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
class PodAttachOptions extends $pb.GeneratedMessage {
  factory PodAttachOptions({
    $core.bool? stdin,
    $core.bool? stdout,
    $core.bool? stderr,
    $core.bool? tty,
    $core.String? container,
  }) {
    final $result = create();
    if (stdin != null) {
      $result.stdin = stdin;
    }
    if (stdout != null) {
      $result.stdout = stdout;
    }
    if (stderr != null) {
      $result.stderr = stderr;
    }
    if (tty != null) {
      $result.tty = tty;
    }
    if (container != null) {
      $result.container = container;
    }
    return $result;
  }
  PodAttachOptions._() : super();
  factory PodAttachOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodAttachOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodAttachOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOB(1, _omitFieldNames ? '' : 'stdin')
    ..aOB(2, _omitFieldNames ? '' : 'stdout')
    ..aOB(3, _omitFieldNames ? '' : 'stderr')
    ..aOB(4, _omitFieldNames ? '' : 'tty')
    ..aOS(5, _omitFieldNames ? '' : 'container')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodAttachOptions clone() => PodAttachOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodAttachOptions copyWith(void Function(PodAttachOptions) updates) => super.copyWith((message) => updates(message as PodAttachOptions)) as PodAttachOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodAttachOptions create() => PodAttachOptions._();
  PodAttachOptions createEmptyInstance() => create();
  static $pb.PbList<PodAttachOptions> createRepeated() => $pb.PbList<PodAttachOptions>();
  @$core.pragma('dart2js:noInline')
  static PodAttachOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodAttachOptions>(create);
  static PodAttachOptions? _defaultInstance;

  /// Stdin if true, redirects the standard input stream of the pod for this call.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(1)
  $core.bool get stdin => $_getBF(0);
  @$pb.TagNumber(1)
  set stdin($core.bool v) { $_setBool(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasStdin() => $_has(0);
  @$pb.TagNumber(1)
  void clearStdin() => clearField(1);

  /// Stdout if true indicates that stdout is to be redirected for the attach call.
  /// Defaults to true.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get stdout => $_getBF(1);
  @$pb.TagNumber(2)
  set stdout($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStdout() => $_has(1);
  @$pb.TagNumber(2)
  void clearStdout() => clearField(2);

  /// Stderr if true indicates that stderr is to be redirected for the attach call.
  /// Defaults to true.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get stderr => $_getBF(2);
  @$pb.TagNumber(3)
  set stderr($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasStderr() => $_has(2);
  @$pb.TagNumber(3)
  void clearStderr() => clearField(3);

  /// TTY if true indicates that a tty will be allocated for the attach call.
  /// This is passed through the container runtime so the tty
  /// is allocated on the worker node by the container runtime.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get tty => $_getBF(3);
  @$pb.TagNumber(4)
  set tty($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasTty() => $_has(3);
  @$pb.TagNumber(4)
  void clearTty() => clearField(4);

  /// The container in which to execute the command.
  /// Defaults to only container if there is only one container in the pod.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get container => $_getSZ(4);
  @$pb.TagNumber(5)
  set container($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasContainer() => $_has(4);
  @$pb.TagNumber(5)
  void clearContainer() => clearField(5);
}

/// PodCondition contains details for the current condition of this pod.
class PodCondition extends $pb.GeneratedMessage {
  factory PodCondition({
    $core.String? type,
    $core.String? status,
    $0.Time? lastProbeTime,
    $0.Time? lastTransitionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (lastProbeTime != null) {
      $result.lastProbeTime = lastProbeTime;
    }
    if (lastTransitionTime != null) {
      $result.lastTransitionTime = lastTransitionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  PodCondition._() : super();
  factory PodCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOM<$0.Time>(3, _omitFieldNames ? '' : 'lastProbeTime', protoName: 'lastProbeTime', subBuilder: $0.Time.create)
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'lastTransitionTime', protoName: 'lastTransitionTime', subBuilder: $0.Time.create)
    ..aOS(5, _omitFieldNames ? '' : 'reason')
    ..aOS(6, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodCondition clone() => PodCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodCondition copyWith(void Function(PodCondition) updates) => super.copyWith((message) => updates(message as PodCondition)) as PodCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodCondition create() => PodCondition._();
  PodCondition createEmptyInstance() => create();
  static $pb.PbList<PodCondition> createRepeated() => $pb.PbList<PodCondition>();
  @$core.pragma('dart2js:noInline')
  static PodCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodCondition>(create);
  static PodCondition? _defaultInstance;

  /// Type is the type of the condition.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Status is the status of the condition.
  /// Can be True, False, Unknown.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// Last time we probed the condition.
  /// +optional
  @$pb.TagNumber(3)
  $0.Time get lastProbeTime => $_getN(2);
  @$pb.TagNumber(3)
  set lastProbeTime($0.Time v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastProbeTime() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastProbeTime() => clearField(3);
  @$pb.TagNumber(3)
  $0.Time ensureLastProbeTime() => $_ensure(2);

  /// Last time the condition transitioned from one status to another.
  /// +optional
  @$pb.TagNumber(4)
  $0.Time get lastTransitionTime => $_getN(3);
  @$pb.TagNumber(4)
  set lastTransitionTime($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLastTransitionTime() => $_has(3);
  @$pb.TagNumber(4)
  void clearLastTransitionTime() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureLastTransitionTime() => $_ensure(3);

  /// Unique, one-word, CamelCase reason for the condition's last transition.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get reason => $_getSZ(4);
  @$pb.TagNumber(5)
  set reason($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasReason() => $_has(4);
  @$pb.TagNumber(5)
  void clearReason() => clearField(5);

  /// Human-readable message indicating details about last transition.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get message => $_getSZ(5);
  @$pb.TagNumber(6)
  set message($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasMessage() => $_has(5);
  @$pb.TagNumber(6)
  void clearMessage() => clearField(6);
}

/// PodDNSConfig defines the DNS parameters of a pod in addition to
/// those generated from DNSPolicy.
class PodDNSConfig extends $pb.GeneratedMessage {
  factory PodDNSConfig({
    $core.Iterable<$core.String>? nameservers,
    $core.Iterable<$core.String>? searches,
    $core.Iterable<PodDNSConfigOption>? options,
  }) {
    final $result = create();
    if (nameservers != null) {
      $result.nameservers.addAll(nameservers);
    }
    if (searches != null) {
      $result.searches.addAll(searches);
    }
    if (options != null) {
      $result.options.addAll(options);
    }
    return $result;
  }
  PodDNSConfig._() : super();
  factory PodDNSConfig.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodDNSConfig.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodDNSConfig', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'nameservers')
    ..pPS(2, _omitFieldNames ? '' : 'searches')
    ..pc<PodDNSConfigOption>(3, _omitFieldNames ? '' : 'options', $pb.PbFieldType.PM, subBuilder: PodDNSConfigOption.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodDNSConfig clone() => PodDNSConfig()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodDNSConfig copyWith(void Function(PodDNSConfig) updates) => super.copyWith((message) => updates(message as PodDNSConfig)) as PodDNSConfig;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodDNSConfig create() => PodDNSConfig._();
  PodDNSConfig createEmptyInstance() => create();
  static $pb.PbList<PodDNSConfig> createRepeated() => $pb.PbList<PodDNSConfig>();
  @$core.pragma('dart2js:noInline')
  static PodDNSConfig getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodDNSConfig>(create);
  static PodDNSConfig? _defaultInstance;

  /// A list of DNS name server IP addresses.
  /// This will be appended to the base nameservers generated from DNSPolicy.
  /// Duplicated nameservers will be removed.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get nameservers => $_getList(0);

  /// A list of DNS search domains for host-name lookup.
  /// This will be appended to the base search paths generated from DNSPolicy.
  /// Duplicated search paths will be removed.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get searches => $_getList(1);

  /// A list of DNS resolver options.
  /// This will be merged with the base options generated from DNSPolicy.
  /// Duplicated entries will be removed. Resolution options given in Options
  /// will override those that appear in the base DNSPolicy.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<PodDNSConfigOption> get options => $_getList(2);
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
class PodDNSConfigOption extends $pb.GeneratedMessage {
  factory PodDNSConfigOption({
    $core.String? name,
    $core.String? value,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (value != null) {
      $result.value = value;
    }
    return $result;
  }
  PodDNSConfigOption._() : super();
  factory PodDNSConfigOption.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodDNSConfigOption.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodDNSConfigOption', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'value')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodDNSConfigOption clone() => PodDNSConfigOption()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodDNSConfigOption copyWith(void Function(PodDNSConfigOption) updates) => super.copyWith((message) => updates(message as PodDNSConfigOption)) as PodDNSConfigOption;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodDNSConfigOption create() => PodDNSConfigOption._();
  PodDNSConfigOption createEmptyInstance() => create();
  static $pb.PbList<PodDNSConfigOption> createRepeated() => $pb.PbList<PodDNSConfigOption>();
  @$core.pragma('dart2js:noInline')
  static PodDNSConfigOption getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodDNSConfigOption>(create);
  static PodDNSConfigOption? _defaultInstance;

  /// Required.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// +optional
  @$pb.TagNumber(2)
  $core.String get value => $_getSZ(1);
  @$pb.TagNumber(2)
  set value($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasValue() => $_has(1);
  @$pb.TagNumber(2)
  void clearValue() => clearField(2);
}

/// PodExecOptions is the query options to a Pod's remote exec call.
/// ---
/// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
/// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
class PodExecOptions extends $pb.GeneratedMessage {
  factory PodExecOptions({
    $core.bool? stdin,
    $core.bool? stdout,
    $core.bool? stderr,
    $core.bool? tty,
    $core.String? container,
    $core.Iterable<$core.String>? command,
  }) {
    final $result = create();
    if (stdin != null) {
      $result.stdin = stdin;
    }
    if (stdout != null) {
      $result.stdout = stdout;
    }
    if (stderr != null) {
      $result.stderr = stderr;
    }
    if (tty != null) {
      $result.tty = tty;
    }
    if (container != null) {
      $result.container = container;
    }
    if (command != null) {
      $result.command.addAll(command);
    }
    return $result;
  }
  PodExecOptions._() : super();
  factory PodExecOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodExecOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodExecOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOB(1, _omitFieldNames ? '' : 'stdin')
    ..aOB(2, _omitFieldNames ? '' : 'stdout')
    ..aOB(3, _omitFieldNames ? '' : 'stderr')
    ..aOB(4, _omitFieldNames ? '' : 'tty')
    ..aOS(5, _omitFieldNames ? '' : 'container')
    ..pPS(6, _omitFieldNames ? '' : 'command')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodExecOptions clone() => PodExecOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodExecOptions copyWith(void Function(PodExecOptions) updates) => super.copyWith((message) => updates(message as PodExecOptions)) as PodExecOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodExecOptions create() => PodExecOptions._();
  PodExecOptions createEmptyInstance() => create();
  static $pb.PbList<PodExecOptions> createRepeated() => $pb.PbList<PodExecOptions>();
  @$core.pragma('dart2js:noInline')
  static PodExecOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodExecOptions>(create);
  static PodExecOptions? _defaultInstance;

  /// Redirect the standard input stream of the pod for this call.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(1)
  $core.bool get stdin => $_getBF(0);
  @$pb.TagNumber(1)
  set stdin($core.bool v) { $_setBool(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasStdin() => $_has(0);
  @$pb.TagNumber(1)
  void clearStdin() => clearField(1);

  /// Redirect the standard output stream of the pod for this call.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get stdout => $_getBF(1);
  @$pb.TagNumber(2)
  set stdout($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStdout() => $_has(1);
  @$pb.TagNumber(2)
  void clearStdout() => clearField(2);

  /// Redirect the standard error stream of the pod for this call.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get stderr => $_getBF(2);
  @$pb.TagNumber(3)
  set stderr($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasStderr() => $_has(2);
  @$pb.TagNumber(3)
  void clearStderr() => clearField(3);

  /// TTY if true indicates that a tty will be allocated for the exec call.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get tty => $_getBF(3);
  @$pb.TagNumber(4)
  set tty($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasTty() => $_has(3);
  @$pb.TagNumber(4)
  void clearTty() => clearField(4);

  /// Container in which to execute the command.
  /// Defaults to only container if there is only one container in the pod.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get container => $_getSZ(4);
  @$pb.TagNumber(5)
  set container($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasContainer() => $_has(4);
  @$pb.TagNumber(5)
  void clearContainer() => clearField(5);

  /// Command is the remote command to execute. argv array. Not executed within a shell.
  /// +listType=atomic
  @$pb.TagNumber(6)
  $core.List<$core.String> get command => $_getList(5);
}

/// PodIP represents a single IP address allocated to the pod.
class PodIP extends $pb.GeneratedMessage {
  factory PodIP({
    $core.String? ip,
  }) {
    final $result = create();
    if (ip != null) {
      $result.ip = ip;
    }
    return $result;
  }
  PodIP._() : super();
  factory PodIP.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodIP.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodIP', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'ip')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodIP clone() => PodIP()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodIP copyWith(void Function(PodIP) updates) => super.copyWith((message) => updates(message as PodIP)) as PodIP;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodIP create() => PodIP._();
  PodIP createEmptyInstance() => create();
  static $pb.PbList<PodIP> createRepeated() => $pb.PbList<PodIP>();
  @$core.pragma('dart2js:noInline')
  static PodIP getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodIP>(create);
  static PodIP? _defaultInstance;

  /// IP is the IP address assigned to the pod
  @$pb.TagNumber(1)
  $core.String get ip => $_getSZ(0);
  @$pb.TagNumber(1)
  set ip($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIp() => $_has(0);
  @$pb.TagNumber(1)
  void clearIp() => clearField(1);
}

/// PodList is a list of Pods.
class PodList extends $pb.GeneratedMessage {
  factory PodList({
    $0.ListMeta? metadata,
    $core.Iterable<Pod>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  PodList._() : super();
  factory PodList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Pod>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Pod.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodList clone() => PodList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodList copyWith(void Function(PodList) updates) => super.copyWith((message) => updates(message as PodList)) as PodList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodList create() => PodList._();
  PodList createEmptyInstance() => create();
  static $pb.PbList<PodList> createRepeated() => $pb.PbList<PodList>();
  @$core.pragma('dart2js:noInline')
  static PodList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodList>(create);
  static PodList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of pods.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
  @$pb.TagNumber(2)
  $core.List<Pod> get items => $_getList(1);
}

/// PodLogOptions is the query options for a Pod's logs REST call.
class PodLogOptions extends $pb.GeneratedMessage {
  factory PodLogOptions({
    $core.String? container,
    $core.bool? follow,
    $core.bool? previous,
    $fixnum.Int64? sinceSeconds,
    $0.Time? sinceTime,
    $core.bool? timestamps,
    $fixnum.Int64? tailLines,
    $fixnum.Int64? limitBytes,
    $core.bool? insecureSkipTLSVerifyBackend,
  }) {
    final $result = create();
    if (container != null) {
      $result.container = container;
    }
    if (follow != null) {
      $result.follow = follow;
    }
    if (previous != null) {
      $result.previous = previous;
    }
    if (sinceSeconds != null) {
      $result.sinceSeconds = sinceSeconds;
    }
    if (sinceTime != null) {
      $result.sinceTime = sinceTime;
    }
    if (timestamps != null) {
      $result.timestamps = timestamps;
    }
    if (tailLines != null) {
      $result.tailLines = tailLines;
    }
    if (limitBytes != null) {
      $result.limitBytes = limitBytes;
    }
    if (insecureSkipTLSVerifyBackend != null) {
      $result.insecureSkipTLSVerifyBackend = insecureSkipTLSVerifyBackend;
    }
    return $result;
  }
  PodLogOptions._() : super();
  factory PodLogOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodLogOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodLogOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'container')
    ..aOB(2, _omitFieldNames ? '' : 'follow')
    ..aOB(3, _omitFieldNames ? '' : 'previous')
    ..aInt64(4, _omitFieldNames ? '' : 'sinceSeconds', protoName: 'sinceSeconds')
    ..aOM<$0.Time>(5, _omitFieldNames ? '' : 'sinceTime', protoName: 'sinceTime', subBuilder: $0.Time.create)
    ..aOB(6, _omitFieldNames ? '' : 'timestamps')
    ..aInt64(7, _omitFieldNames ? '' : 'tailLines', protoName: 'tailLines')
    ..aInt64(8, _omitFieldNames ? '' : 'limitBytes', protoName: 'limitBytes')
    ..aOB(9, _omitFieldNames ? '' : 'insecureSkipTLSVerifyBackend', protoName: 'insecureSkipTLSVerifyBackend')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodLogOptions clone() => PodLogOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodLogOptions copyWith(void Function(PodLogOptions) updates) => super.copyWith((message) => updates(message as PodLogOptions)) as PodLogOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodLogOptions create() => PodLogOptions._();
  PodLogOptions createEmptyInstance() => create();
  static $pb.PbList<PodLogOptions> createRepeated() => $pb.PbList<PodLogOptions>();
  @$core.pragma('dart2js:noInline')
  static PodLogOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodLogOptions>(create);
  static PodLogOptions? _defaultInstance;

  /// The container for which to stream logs. Defaults to only container if there is one container in the pod.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get container => $_getSZ(0);
  @$pb.TagNumber(1)
  set container($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasContainer() => $_has(0);
  @$pb.TagNumber(1)
  void clearContainer() => clearField(1);

  /// Follow the log stream of the pod. Defaults to false.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get follow => $_getBF(1);
  @$pb.TagNumber(2)
  set follow($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFollow() => $_has(1);
  @$pb.TagNumber(2)
  void clearFollow() => clearField(2);

  /// Return previous terminated container logs. Defaults to false.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get previous => $_getBF(2);
  @$pb.TagNumber(3)
  set previous($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPrevious() => $_has(2);
  @$pb.TagNumber(3)
  void clearPrevious() => clearField(3);

  /// A relative time in seconds before the current time from which to show logs. If this value
  /// precedes the time a pod was started, only logs since the pod start will be returned.
  /// If this value is in the future, no logs will be returned.
  /// Only one of sinceSeconds or sinceTime may be specified.
  /// +optional
  @$pb.TagNumber(4)
  $fixnum.Int64 get sinceSeconds => $_getI64(3);
  @$pb.TagNumber(4)
  set sinceSeconds($fixnum.Int64 v) { $_setInt64(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSinceSeconds() => $_has(3);
  @$pb.TagNumber(4)
  void clearSinceSeconds() => clearField(4);

  /// An RFC3339 timestamp from which to show logs. If this value
  /// precedes the time a pod was started, only logs since the pod start will be returned.
  /// If this value is in the future, no logs will be returned.
  /// Only one of sinceSeconds or sinceTime may be specified.
  /// +optional
  @$pb.TagNumber(5)
  $0.Time get sinceTime => $_getN(4);
  @$pb.TagNumber(5)
  set sinceTime($0.Time v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSinceTime() => $_has(4);
  @$pb.TagNumber(5)
  void clearSinceTime() => clearField(5);
  @$pb.TagNumber(5)
  $0.Time ensureSinceTime() => $_ensure(4);

  /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
  /// of log output. Defaults to false.
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get timestamps => $_getBF(5);
  @$pb.TagNumber(6)
  set timestamps($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasTimestamps() => $_has(5);
  @$pb.TagNumber(6)
  void clearTimestamps() => clearField(6);

  /// If set, the number of lines from the end of the logs to show. If not specified,
  /// logs are shown from the creation of the container or sinceSeconds or sinceTime
  /// +optional
  @$pb.TagNumber(7)
  $fixnum.Int64 get tailLines => $_getI64(6);
  @$pb.TagNumber(7)
  set tailLines($fixnum.Int64 v) { $_setInt64(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasTailLines() => $_has(6);
  @$pb.TagNumber(7)
  void clearTailLines() => clearField(7);

  /// If set, the number of bytes to read from the server before terminating the
  /// log output. This may not display a complete final line of logging, and may return
  /// slightly more or slightly less than the specified limit.
  /// +optional
  @$pb.TagNumber(8)
  $fixnum.Int64 get limitBytes => $_getI64(7);
  @$pb.TagNumber(8)
  set limitBytes($fixnum.Int64 v) { $_setInt64(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasLimitBytes() => $_has(7);
  @$pb.TagNumber(8)
  void clearLimitBytes() => clearField(8);

  /// insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
  /// serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
  /// and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
  /// kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
  /// connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
  /// the actual log data coming from the real kubelet).
  /// +optional
  @$pb.TagNumber(9)
  $core.bool get insecureSkipTLSVerifyBackend => $_getBF(8);
  @$pb.TagNumber(9)
  set insecureSkipTLSVerifyBackend($core.bool v) { $_setBool(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasInsecureSkipTLSVerifyBackend() => $_has(8);
  @$pb.TagNumber(9)
  void clearInsecureSkipTLSVerifyBackend() => clearField(9);
}

/// PodOS defines the OS parameters of a pod.
class PodOS extends $pb.GeneratedMessage {
  factory PodOS({
    $core.String? name,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    return $result;
  }
  PodOS._() : super();
  factory PodOS.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodOS.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodOS', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodOS clone() => PodOS()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodOS copyWith(void Function(PodOS) updates) => super.copyWith((message) => updates(message as PodOS)) as PodOS;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodOS create() => PodOS._();
  PodOS createEmptyInstance() => create();
  static $pb.PbList<PodOS> createRepeated() => $pb.PbList<PodOS>();
  @$core.pragma('dart2js:noInline')
  static PodOS getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodOS>(create);
  static PodOS? _defaultInstance;

  /// Name is the name of the operating system. The currently supported values are linux and windows.
  /// Additional value may be defined in future and can be one of:
  /// https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
  /// Clients should expect to handle additional values and treat unrecognized values in this field as os: null
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);
}

/// PodPortForwardOptions is the query options to a Pod's port forward call
/// when using WebSockets.
/// The `port` query parameter must specify the port or
/// ports (comma separated) to forward over.
/// Port forwarding over SPDY does not use these options. It requires the port
/// to be passed in the `port` header as part of request.
class PodPortForwardOptions extends $pb.GeneratedMessage {
  factory PodPortForwardOptions({
    $core.Iterable<$core.int>? ports,
  }) {
    final $result = create();
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    return $result;
  }
  PodPortForwardOptions._() : super();
  factory PodPortForwardOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodPortForwardOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodPortForwardOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..p<$core.int>(1, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.P3)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodPortForwardOptions clone() => PodPortForwardOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodPortForwardOptions copyWith(void Function(PodPortForwardOptions) updates) => super.copyWith((message) => updates(message as PodPortForwardOptions)) as PodPortForwardOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodPortForwardOptions create() => PodPortForwardOptions._();
  PodPortForwardOptions createEmptyInstance() => create();
  static $pb.PbList<PodPortForwardOptions> createRepeated() => $pb.PbList<PodPortForwardOptions>();
  @$core.pragma('dart2js:noInline')
  static PodPortForwardOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodPortForwardOptions>(create);
  static PodPortForwardOptions? _defaultInstance;

  /// List of ports to forward
  /// Required when using WebSockets
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.int> get ports => $_getList(0);
}

/// PodProxyOptions is the query options to a Pod's proxy call.
class PodProxyOptions extends $pb.GeneratedMessage {
  factory PodProxyOptions({
    $core.String? path,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    return $result;
  }
  PodProxyOptions._() : super();
  factory PodProxyOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodProxyOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodProxyOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodProxyOptions clone() => PodProxyOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodProxyOptions copyWith(void Function(PodProxyOptions) updates) => super.copyWith((message) => updates(message as PodProxyOptions)) as PodProxyOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodProxyOptions create() => PodProxyOptions._();
  PodProxyOptions createEmptyInstance() => create();
  static $pb.PbList<PodProxyOptions> createRepeated() => $pb.PbList<PodProxyOptions>();
  @$core.pragma('dart2js:noInline')
  static PodProxyOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodProxyOptions>(create);
  static PodProxyOptions? _defaultInstance;

  /// Path is the URL path to use for the current proxy request to pod.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);
}

/// PodReadinessGate contains the reference to a pod condition
class PodReadinessGate extends $pb.GeneratedMessage {
  factory PodReadinessGate({
    $core.String? conditionType,
  }) {
    final $result = create();
    if (conditionType != null) {
      $result.conditionType = conditionType;
    }
    return $result;
  }
  PodReadinessGate._() : super();
  factory PodReadinessGate.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodReadinessGate.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodReadinessGate', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'conditionType', protoName: 'conditionType')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodReadinessGate clone() => PodReadinessGate()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodReadinessGate copyWith(void Function(PodReadinessGate) updates) => super.copyWith((message) => updates(message as PodReadinessGate)) as PodReadinessGate;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodReadinessGate create() => PodReadinessGate._();
  PodReadinessGate createEmptyInstance() => create();
  static $pb.PbList<PodReadinessGate> createRepeated() => $pb.PbList<PodReadinessGate>();
  @$core.pragma('dart2js:noInline')
  static PodReadinessGate getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodReadinessGate>(create);
  static PodReadinessGate? _defaultInstance;

  /// ConditionType refers to a condition in the pod's condition list with matching type.
  @$pb.TagNumber(1)
  $core.String get conditionType => $_getSZ(0);
  @$pb.TagNumber(1)
  set conditionType($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasConditionType() => $_has(0);
  @$pb.TagNumber(1)
  void clearConditionType() => clearField(1);
}

/// PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
/// It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
/// Containers that need access to the ResourceClaim reference it with this name.
class PodResourceClaim extends $pb.GeneratedMessage {
  factory PodResourceClaim({
    $core.String? name,
    ClaimSource? source,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (source != null) {
      $result.source = source;
    }
    return $result;
  }
  PodResourceClaim._() : super();
  factory PodResourceClaim.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodResourceClaim.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodResourceClaim', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOM<ClaimSource>(2, _omitFieldNames ? '' : 'source', subBuilder: ClaimSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodResourceClaim clone() => PodResourceClaim()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodResourceClaim copyWith(void Function(PodResourceClaim) updates) => super.copyWith((message) => updates(message as PodResourceClaim)) as PodResourceClaim;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodResourceClaim create() => PodResourceClaim._();
  PodResourceClaim createEmptyInstance() => create();
  static $pb.PbList<PodResourceClaim> createRepeated() => $pb.PbList<PodResourceClaim>();
  @$core.pragma('dart2js:noInline')
  static PodResourceClaim getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodResourceClaim>(create);
  static PodResourceClaim? _defaultInstance;

  /// Name uniquely identifies this resource claim inside the pod.
  /// This must be a DNS_LABEL.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Source describes where to find the ResourceClaim.
  @$pb.TagNumber(2)
  ClaimSource get source => $_getN(1);
  @$pb.TagNumber(2)
  set source(ClaimSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSource() => $_has(1);
  @$pb.TagNumber(2)
  void clearSource() => clearField(2);
  @$pb.TagNumber(2)
  ClaimSource ensureSource() => $_ensure(1);
}

/// PodResourceClaimStatus is stored in the PodStatus for each PodResourceClaim
/// which references a ResourceClaimTemplate. It stores the generated name for
/// the corresponding ResourceClaim.
class PodResourceClaimStatus extends $pb.GeneratedMessage {
  factory PodResourceClaimStatus({
    $core.String? name,
    $core.String? resourceClaimName,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (resourceClaimName != null) {
      $result.resourceClaimName = resourceClaimName;
    }
    return $result;
  }
  PodResourceClaimStatus._() : super();
  factory PodResourceClaimStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodResourceClaimStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodResourceClaimStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'resourceClaimName', protoName: 'resourceClaimName')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodResourceClaimStatus clone() => PodResourceClaimStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodResourceClaimStatus copyWith(void Function(PodResourceClaimStatus) updates) => super.copyWith((message) => updates(message as PodResourceClaimStatus)) as PodResourceClaimStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodResourceClaimStatus create() => PodResourceClaimStatus._();
  PodResourceClaimStatus createEmptyInstance() => create();
  static $pb.PbList<PodResourceClaimStatus> createRepeated() => $pb.PbList<PodResourceClaimStatus>();
  @$core.pragma('dart2js:noInline')
  static PodResourceClaimStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodResourceClaimStatus>(create);
  static PodResourceClaimStatus? _defaultInstance;

  /// Name uniquely identifies this resource claim inside the pod.
  /// This must match the name of an entry in pod.spec.resourceClaims,
  /// which implies that the string must be a DNS_LABEL.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  ///  ResourceClaimName is the name of the ResourceClaim that was
  ///  generated for the Pod in the namespace of the Pod. It this is
  ///  unset, then generating a ResourceClaim was not necessary. The
  ///  pod.spec.resourceClaims entry can be ignored in this case.
  ///
  ///  +optional
  @$pb.TagNumber(2)
  $core.String get resourceClaimName => $_getSZ(1);
  @$pb.TagNumber(2)
  set resourceClaimName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasResourceClaimName() => $_has(1);
  @$pb.TagNumber(2)
  void clearResourceClaimName() => clearField(2);
}

/// PodSchedulingGate is associated to a Pod to guard its scheduling.
class PodSchedulingGate extends $pb.GeneratedMessage {
  factory PodSchedulingGate({
    $core.String? name,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    return $result;
  }
  PodSchedulingGate._() : super();
  factory PodSchedulingGate.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodSchedulingGate.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodSchedulingGate', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodSchedulingGate clone() => PodSchedulingGate()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodSchedulingGate copyWith(void Function(PodSchedulingGate) updates) => super.copyWith((message) => updates(message as PodSchedulingGate)) as PodSchedulingGate;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodSchedulingGate create() => PodSchedulingGate._();
  PodSchedulingGate createEmptyInstance() => create();
  static $pb.PbList<PodSchedulingGate> createRepeated() => $pb.PbList<PodSchedulingGate>();
  @$core.pragma('dart2js:noInline')
  static PodSchedulingGate getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodSchedulingGate>(create);
  static PodSchedulingGate? _defaultInstance;

  /// Name of the scheduling gate.
  /// Each scheduling gate must have a unique name field.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);
}

/// PodSecurityContext holds pod-level security attributes and common container settings.
/// Some fields are also present in container.securityContext.  Field values of
/// container.securityContext take precedence over field values of PodSecurityContext.
class PodSecurityContext extends $pb.GeneratedMessage {
  factory PodSecurityContext({
    SELinuxOptions? seLinuxOptions,
    $fixnum.Int64? runAsUser,
    $core.bool? runAsNonRoot,
    $core.Iterable<$fixnum.Int64>? supplementalGroups,
    $fixnum.Int64? fsGroup,
    $fixnum.Int64? runAsGroup,
    $core.Iterable<Sysctl>? sysctls,
    WindowsSecurityContextOptions? windowsOptions,
    $core.String? fsGroupChangePolicy,
    SeccompProfile? seccompProfile,
    AppArmorProfile? appArmorProfile,
  }) {
    final $result = create();
    if (seLinuxOptions != null) {
      $result.seLinuxOptions = seLinuxOptions;
    }
    if (runAsUser != null) {
      $result.runAsUser = runAsUser;
    }
    if (runAsNonRoot != null) {
      $result.runAsNonRoot = runAsNonRoot;
    }
    if (supplementalGroups != null) {
      $result.supplementalGroups.addAll(supplementalGroups);
    }
    if (fsGroup != null) {
      $result.fsGroup = fsGroup;
    }
    if (runAsGroup != null) {
      $result.runAsGroup = runAsGroup;
    }
    if (sysctls != null) {
      $result.sysctls.addAll(sysctls);
    }
    if (windowsOptions != null) {
      $result.windowsOptions = windowsOptions;
    }
    if (fsGroupChangePolicy != null) {
      $result.fsGroupChangePolicy = fsGroupChangePolicy;
    }
    if (seccompProfile != null) {
      $result.seccompProfile = seccompProfile;
    }
    if (appArmorProfile != null) {
      $result.appArmorProfile = appArmorProfile;
    }
    return $result;
  }
  PodSecurityContext._() : super();
  factory PodSecurityContext.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodSecurityContext.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodSecurityContext', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<SELinuxOptions>(1, _omitFieldNames ? '' : 'seLinuxOptions', protoName: 'seLinuxOptions', subBuilder: SELinuxOptions.create)
    ..aInt64(2, _omitFieldNames ? '' : 'runAsUser', protoName: 'runAsUser')
    ..aOB(3, _omitFieldNames ? '' : 'runAsNonRoot', protoName: 'runAsNonRoot')
    ..p<$fixnum.Int64>(4, _omitFieldNames ? '' : 'supplementalGroups', $pb.PbFieldType.P6, protoName: 'supplementalGroups')
    ..aInt64(5, _omitFieldNames ? '' : 'fsGroup', protoName: 'fsGroup')
    ..aInt64(6, _omitFieldNames ? '' : 'runAsGroup', protoName: 'runAsGroup')
    ..pc<Sysctl>(7, _omitFieldNames ? '' : 'sysctls', $pb.PbFieldType.PM, subBuilder: Sysctl.create)
    ..aOM<WindowsSecurityContextOptions>(8, _omitFieldNames ? '' : 'windowsOptions', protoName: 'windowsOptions', subBuilder: WindowsSecurityContextOptions.create)
    ..aOS(9, _omitFieldNames ? '' : 'fsGroupChangePolicy', protoName: 'fsGroupChangePolicy')
    ..aOM<SeccompProfile>(10, _omitFieldNames ? '' : 'seccompProfile', protoName: 'seccompProfile', subBuilder: SeccompProfile.create)
    ..aOM<AppArmorProfile>(11, _omitFieldNames ? '' : 'appArmorProfile', protoName: 'appArmorProfile', subBuilder: AppArmorProfile.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodSecurityContext clone() => PodSecurityContext()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodSecurityContext copyWith(void Function(PodSecurityContext) updates) => super.copyWith((message) => updates(message as PodSecurityContext)) as PodSecurityContext;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodSecurityContext create() => PodSecurityContext._();
  PodSecurityContext createEmptyInstance() => create();
  static $pb.PbList<PodSecurityContext> createRepeated() => $pb.PbList<PodSecurityContext>();
  @$core.pragma('dart2js:noInline')
  static PodSecurityContext getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodSecurityContext>(create);
  static PodSecurityContext? _defaultInstance;

  /// The SELinux context to be applied to all containers.
  /// If unspecified, the container runtime will allocate a random SELinux context for each
  /// container.  May also be set in SecurityContext.  If set in
  /// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  /// takes precedence for that container.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(1)
  SELinuxOptions get seLinuxOptions => $_getN(0);
  @$pb.TagNumber(1)
  set seLinuxOptions(SELinuxOptions v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasSeLinuxOptions() => $_has(0);
  @$pb.TagNumber(1)
  void clearSeLinuxOptions() => clearField(1);
  @$pb.TagNumber(1)
  SELinuxOptions ensureSeLinuxOptions() => $_ensure(0);

  /// The UID to run the entrypoint of the container process.
  /// Defaults to user specified in image metadata if unspecified.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence
  /// for that container.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(2)
  $fixnum.Int64 get runAsUser => $_getI64(1);
  @$pb.TagNumber(2)
  set runAsUser($fixnum.Int64 v) { $_setInt64(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasRunAsUser() => $_has(1);
  @$pb.TagNumber(2)
  void clearRunAsUser() => clearField(2);

  /// Indicates that the container must run as a non-root user.
  /// If true, the Kubelet will validate the image at runtime to ensure that it
  /// does not run as UID 0 (root) and fail to start the container if it does.
  /// If unset or false, no such validation will be performed.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get runAsNonRoot => $_getBF(2);
  @$pb.TagNumber(3)
  set runAsNonRoot($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasRunAsNonRoot() => $_has(2);
  @$pb.TagNumber(3)
  void clearRunAsNonRoot() => clearField(3);

  /// A list of groups applied to the first process run in each container, in addition
  /// to the container's primary GID, the fsGroup (if specified), and group memberships
  /// defined in the container image for the uid of the container process. If unspecified,
  /// no additional groups are added to any container. Note that group memberships
  /// defined in the container image for the uid of the container process are still effective,
  /// even if they are not included in this list.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(4)
  $core.List<$fixnum.Int64> get supplementalGroups => $_getList(3);

  ///  A special supplemental group that applies to all containers in a pod.
  ///  Some volume types allow the Kubelet to change the ownership of that volume
  ///  to be owned by the pod:
  ///
  ///  1. The owning GID will be the FSGroup
  ///  2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  ///  3. The permission bits are OR'd with rw-rw----
  ///
  ///  If unset, the Kubelet will not modify the ownership and permissions of any volume.
  ///  Note that this field cannot be set when spec.os.name is windows.
  ///  +optional
  @$pb.TagNumber(5)
  $fixnum.Int64 get fsGroup => $_getI64(4);
  @$pb.TagNumber(5)
  set fsGroup($fixnum.Int64 v) { $_setInt64(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasFsGroup() => $_has(4);
  @$pb.TagNumber(5)
  void clearFsGroup() => clearField(5);

  /// The GID to run the entrypoint of the container process.
  /// Uses runtime default if unset.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence
  /// for that container.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(6)
  $fixnum.Int64 get runAsGroup => $_getI64(5);
  @$pb.TagNumber(6)
  set runAsGroup($fixnum.Int64 v) { $_setInt64(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasRunAsGroup() => $_has(5);
  @$pb.TagNumber(6)
  void clearRunAsGroup() => clearField(6);

  /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
  /// sysctls (by the container runtime) might fail to launch.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(7)
  $core.List<Sysctl> get sysctls => $_getList(6);

  /// The Windows specific settings applied to all containers.
  /// If unspecified, the options within a container's SecurityContext will be used.
  /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// Note that this field cannot be set when spec.os.name is linux.
  /// +optional
  @$pb.TagNumber(8)
  WindowsSecurityContextOptions get windowsOptions => $_getN(7);
  @$pb.TagNumber(8)
  set windowsOptions(WindowsSecurityContextOptions v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasWindowsOptions() => $_has(7);
  @$pb.TagNumber(8)
  void clearWindowsOptions() => clearField(8);
  @$pb.TagNumber(8)
  WindowsSecurityContextOptions ensureWindowsOptions() => $_ensure(7);

  /// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
  /// before being exposed inside Pod. This field will only apply to
  /// volume types which support fsGroup based ownership(and permissions).
  /// It will have no effect on ephemeral volume types such as: secret, configmaps
  /// and emptydir.
  /// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(9)
  $core.String get fsGroupChangePolicy => $_getSZ(8);
  @$pb.TagNumber(9)
  set fsGroupChangePolicy($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasFsGroupChangePolicy() => $_has(8);
  @$pb.TagNumber(9)
  void clearFsGroupChangePolicy() => clearField(9);

  /// The seccomp options to use by the containers in this pod.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(10)
  SeccompProfile get seccompProfile => $_getN(9);
  @$pb.TagNumber(10)
  set seccompProfile(SeccompProfile v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasSeccompProfile() => $_has(9);
  @$pb.TagNumber(10)
  void clearSeccompProfile() => clearField(10);
  @$pb.TagNumber(10)
  SeccompProfile ensureSeccompProfile() => $_ensure(9);

  /// appArmorProfile is the AppArmor options to use by the containers in this pod.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(11)
  AppArmorProfile get appArmorProfile => $_getN(10);
  @$pb.TagNumber(11)
  set appArmorProfile(AppArmorProfile v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasAppArmorProfile() => $_has(10);
  @$pb.TagNumber(11)
  void clearAppArmorProfile() => clearField(11);
  @$pb.TagNumber(11)
  AppArmorProfile ensureAppArmorProfile() => $_ensure(10);
}

/// Describes the class of pods that should avoid this node.
/// Exactly one field should be set.
class PodSignature extends $pb.GeneratedMessage {
  factory PodSignature({
    $0.OwnerReference? podController,
  }) {
    final $result = create();
    if (podController != null) {
      $result.podController = podController;
    }
    return $result;
  }
  PodSignature._() : super();
  factory PodSignature.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodSignature.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodSignature', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.OwnerReference>(1, _omitFieldNames ? '' : 'podController', protoName: 'podController', subBuilder: $0.OwnerReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodSignature clone() => PodSignature()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodSignature copyWith(void Function(PodSignature) updates) => super.copyWith((message) => updates(message as PodSignature)) as PodSignature;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodSignature create() => PodSignature._();
  PodSignature createEmptyInstance() => create();
  static $pb.PbList<PodSignature> createRepeated() => $pb.PbList<PodSignature>();
  @$core.pragma('dart2js:noInline')
  static PodSignature getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodSignature>(create);
  static PodSignature? _defaultInstance;

  /// Reference to controller whose pods should avoid this node.
  /// +optional
  @$pb.TagNumber(1)
  $0.OwnerReference get podController => $_getN(0);
  @$pb.TagNumber(1)
  set podController($0.OwnerReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasPodController() => $_has(0);
  @$pb.TagNumber(1)
  void clearPodController() => clearField(1);
  @$pb.TagNumber(1)
  $0.OwnerReference ensurePodController() => $_ensure(0);
}

/// PodSpec is a description of a pod.
class PodSpec extends $pb.GeneratedMessage {
  factory PodSpec({
    $core.Iterable<Volume>? volumes,
    $core.Iterable<Container>? containers,
    $core.String? restartPolicy,
    $fixnum.Int64? terminationGracePeriodSeconds,
    $fixnum.Int64? activeDeadlineSeconds,
    $core.String? dnsPolicy,
    $core.Map<$core.String, $core.String>? nodeSelector,
    $core.String? serviceAccountName,
    $core.String? serviceAccount,
    $core.String? nodeName,
    $core.bool? hostNetwork,
    $core.bool? hostPID,
    $core.bool? hostIPC,
    PodSecurityContext? securityContext,
    $core.Iterable<LocalObjectReference>? imagePullSecrets,
    $core.String? hostname,
    $core.String? subdomain,
    Affinity? affinity,
    $core.String? schedulerName,
    $core.Iterable<Container>? initContainers,
    $core.bool? automountServiceAccountToken,
    $core.Iterable<Toleration>? tolerations,
    $core.Iterable<HostAlias>? hostAliases,
    $core.String? priorityClassName,
    $core.int? priority,
    PodDNSConfig? dnsConfig,
    $core.bool? shareProcessNamespace,
    $core.Iterable<PodReadinessGate>? readinessGates,
    $core.String? runtimeClassName,
    $core.bool? enableServiceLinks,
    $core.String? preemptionPolicy,
    $core.Map<$core.String, $1.Quantity>? overhead,
    $core.Iterable<TopologySpreadConstraint>? topologySpreadConstraints,
    $core.Iterable<EphemeralContainer>? ephemeralContainers,
    $core.bool? setHostnameAsFQDN,
    PodOS? os,
    $core.bool? hostUsers,
    $core.Iterable<PodSchedulingGate>? schedulingGates,
    $core.Iterable<PodResourceClaim>? resourceClaims,
  }) {
    final $result = create();
    if (volumes != null) {
      $result.volumes.addAll(volumes);
    }
    if (containers != null) {
      $result.containers.addAll(containers);
    }
    if (restartPolicy != null) {
      $result.restartPolicy = restartPolicy;
    }
    if (terminationGracePeriodSeconds != null) {
      $result.terminationGracePeriodSeconds = terminationGracePeriodSeconds;
    }
    if (activeDeadlineSeconds != null) {
      $result.activeDeadlineSeconds = activeDeadlineSeconds;
    }
    if (dnsPolicy != null) {
      $result.dnsPolicy = dnsPolicy;
    }
    if (nodeSelector != null) {
      $result.nodeSelector.addAll(nodeSelector);
    }
    if (serviceAccountName != null) {
      $result.serviceAccountName = serviceAccountName;
    }
    if (serviceAccount != null) {
      $result.serviceAccount = serviceAccount;
    }
    if (nodeName != null) {
      $result.nodeName = nodeName;
    }
    if (hostNetwork != null) {
      $result.hostNetwork = hostNetwork;
    }
    if (hostPID != null) {
      $result.hostPID = hostPID;
    }
    if (hostIPC != null) {
      $result.hostIPC = hostIPC;
    }
    if (securityContext != null) {
      $result.securityContext = securityContext;
    }
    if (imagePullSecrets != null) {
      $result.imagePullSecrets.addAll(imagePullSecrets);
    }
    if (hostname != null) {
      $result.hostname = hostname;
    }
    if (subdomain != null) {
      $result.subdomain = subdomain;
    }
    if (affinity != null) {
      $result.affinity = affinity;
    }
    if (schedulerName != null) {
      $result.schedulerName = schedulerName;
    }
    if (initContainers != null) {
      $result.initContainers.addAll(initContainers);
    }
    if (automountServiceAccountToken != null) {
      $result.automountServiceAccountToken = automountServiceAccountToken;
    }
    if (tolerations != null) {
      $result.tolerations.addAll(tolerations);
    }
    if (hostAliases != null) {
      $result.hostAliases.addAll(hostAliases);
    }
    if (priorityClassName != null) {
      $result.priorityClassName = priorityClassName;
    }
    if (priority != null) {
      $result.priority = priority;
    }
    if (dnsConfig != null) {
      $result.dnsConfig = dnsConfig;
    }
    if (shareProcessNamespace != null) {
      $result.shareProcessNamespace = shareProcessNamespace;
    }
    if (readinessGates != null) {
      $result.readinessGates.addAll(readinessGates);
    }
    if (runtimeClassName != null) {
      $result.runtimeClassName = runtimeClassName;
    }
    if (enableServiceLinks != null) {
      $result.enableServiceLinks = enableServiceLinks;
    }
    if (preemptionPolicy != null) {
      $result.preemptionPolicy = preemptionPolicy;
    }
    if (overhead != null) {
      $result.overhead.addAll(overhead);
    }
    if (topologySpreadConstraints != null) {
      $result.topologySpreadConstraints.addAll(topologySpreadConstraints);
    }
    if (ephemeralContainers != null) {
      $result.ephemeralContainers.addAll(ephemeralContainers);
    }
    if (setHostnameAsFQDN != null) {
      $result.setHostnameAsFQDN = setHostnameAsFQDN;
    }
    if (os != null) {
      $result.os = os;
    }
    if (hostUsers != null) {
      $result.hostUsers = hostUsers;
    }
    if (schedulingGates != null) {
      $result.schedulingGates.addAll(schedulingGates);
    }
    if (resourceClaims != null) {
      $result.resourceClaims.addAll(resourceClaims);
    }
    return $result;
  }
  PodSpec._() : super();
  factory PodSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<Volume>(1, _omitFieldNames ? '' : 'volumes', $pb.PbFieldType.PM, subBuilder: Volume.create)
    ..pc<Container>(2, _omitFieldNames ? '' : 'containers', $pb.PbFieldType.PM, subBuilder: Container.create)
    ..aOS(3, _omitFieldNames ? '' : 'restartPolicy', protoName: 'restartPolicy')
    ..aInt64(4, _omitFieldNames ? '' : 'terminationGracePeriodSeconds', protoName: 'terminationGracePeriodSeconds')
    ..aInt64(5, _omitFieldNames ? '' : 'activeDeadlineSeconds', protoName: 'activeDeadlineSeconds')
    ..aOS(6, _omitFieldNames ? '' : 'dnsPolicy', protoName: 'dnsPolicy')
    ..m<$core.String, $core.String>(7, _omitFieldNames ? '' : 'nodeSelector', protoName: 'nodeSelector', entryClassName: 'PodSpec.NodeSelectorEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOS(8, _omitFieldNames ? '' : 'serviceAccountName', protoName: 'serviceAccountName')
    ..aOS(9, _omitFieldNames ? '' : 'serviceAccount', protoName: 'serviceAccount')
    ..aOS(10, _omitFieldNames ? '' : 'nodeName', protoName: 'nodeName')
    ..aOB(11, _omitFieldNames ? '' : 'hostNetwork', protoName: 'hostNetwork')
    ..aOB(12, _omitFieldNames ? '' : 'hostPID', protoName: 'hostPID')
    ..aOB(13, _omitFieldNames ? '' : 'hostIPC', protoName: 'hostIPC')
    ..aOM<PodSecurityContext>(14, _omitFieldNames ? '' : 'securityContext', protoName: 'securityContext', subBuilder: PodSecurityContext.create)
    ..pc<LocalObjectReference>(15, _omitFieldNames ? '' : 'imagePullSecrets', $pb.PbFieldType.PM, protoName: 'imagePullSecrets', subBuilder: LocalObjectReference.create)
    ..aOS(16, _omitFieldNames ? '' : 'hostname')
    ..aOS(17, _omitFieldNames ? '' : 'subdomain')
    ..aOM<Affinity>(18, _omitFieldNames ? '' : 'affinity', subBuilder: Affinity.create)
    ..aOS(19, _omitFieldNames ? '' : 'schedulerName', protoName: 'schedulerName')
    ..pc<Container>(20, _omitFieldNames ? '' : 'initContainers', $pb.PbFieldType.PM, protoName: 'initContainers', subBuilder: Container.create)
    ..aOB(21, _omitFieldNames ? '' : 'automountServiceAccountToken', protoName: 'automountServiceAccountToken')
    ..pc<Toleration>(22, _omitFieldNames ? '' : 'tolerations', $pb.PbFieldType.PM, subBuilder: Toleration.create)
    ..pc<HostAlias>(23, _omitFieldNames ? '' : 'hostAliases', $pb.PbFieldType.PM, protoName: 'hostAliases', subBuilder: HostAlias.create)
    ..aOS(24, _omitFieldNames ? '' : 'priorityClassName', protoName: 'priorityClassName')
    ..a<$core.int>(25, _omitFieldNames ? '' : 'priority', $pb.PbFieldType.O3)
    ..aOM<PodDNSConfig>(26, _omitFieldNames ? '' : 'dnsConfig', protoName: 'dnsConfig', subBuilder: PodDNSConfig.create)
    ..aOB(27, _omitFieldNames ? '' : 'shareProcessNamespace', protoName: 'shareProcessNamespace')
    ..pc<PodReadinessGate>(28, _omitFieldNames ? '' : 'readinessGates', $pb.PbFieldType.PM, protoName: 'readinessGates', subBuilder: PodReadinessGate.create)
    ..aOS(29, _omitFieldNames ? '' : 'runtimeClassName', protoName: 'runtimeClassName')
    ..aOB(30, _omitFieldNames ? '' : 'enableServiceLinks', protoName: 'enableServiceLinks')
    ..aOS(31, _omitFieldNames ? '' : 'preemptionPolicy', protoName: 'preemptionPolicy')
    ..m<$core.String, $1.Quantity>(32, _omitFieldNames ? '' : 'overhead', entryClassName: 'PodSpec.OverheadEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..pc<TopologySpreadConstraint>(33, _omitFieldNames ? '' : 'topologySpreadConstraints', $pb.PbFieldType.PM, protoName: 'topologySpreadConstraints', subBuilder: TopologySpreadConstraint.create)
    ..pc<EphemeralContainer>(34, _omitFieldNames ? '' : 'ephemeralContainers', $pb.PbFieldType.PM, protoName: 'ephemeralContainers', subBuilder: EphemeralContainer.create)
    ..aOB(35, _omitFieldNames ? '' : 'setHostnameAsFQDN', protoName: 'setHostnameAsFQDN')
    ..aOM<PodOS>(36, _omitFieldNames ? '' : 'os', subBuilder: PodOS.create)
    ..aOB(37, _omitFieldNames ? '' : 'hostUsers', protoName: 'hostUsers')
    ..pc<PodSchedulingGate>(38, _omitFieldNames ? '' : 'schedulingGates', $pb.PbFieldType.PM, protoName: 'schedulingGates', subBuilder: PodSchedulingGate.create)
    ..pc<PodResourceClaim>(39, _omitFieldNames ? '' : 'resourceClaims', $pb.PbFieldType.PM, protoName: 'resourceClaims', subBuilder: PodResourceClaim.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodSpec clone() => PodSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodSpec copyWith(void Function(PodSpec) updates) => super.copyWith((message) => updates(message as PodSpec)) as PodSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodSpec create() => PodSpec._();
  PodSpec createEmptyInstance() => create();
  static $pb.PbList<PodSpec> createRepeated() => $pb.PbList<PodSpec>();
  @$core.pragma('dart2js:noInline')
  static PodSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodSpec>(create);
  static PodSpec? _defaultInstance;

  /// List of volumes that can be mounted by containers belonging to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge,retainKeys
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(1)
  $core.List<Volume> get volumes => $_getList(0);

  /// List of containers belonging to the pod.
  /// Containers cannot currently be added or removed.
  /// There must be at least one container in a Pod.
  /// Cannot be updated.
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(2)
  $core.List<Container> get containers => $_getList(1);

  /// Restart policy for all containers within the pod.
  /// One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
  /// Default to Always.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  /// +optional
  @$pb.TagNumber(3)
  $core.String get restartPolicy => $_getSZ(2);
  @$pb.TagNumber(3)
  set restartPolicy($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasRestartPolicy() => $_has(2);
  @$pb.TagNumber(3)
  void clearRestartPolicy() => clearField(3);

  /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
  /// Value must be non-negative integer. The value zero indicates stop immediately via
  /// the kill signal (no opportunity to shut down).
  /// If this value is nil, the default grace period will be used instead.
  /// The grace period is the duration in seconds after the processes running in the pod are sent
  /// a termination signal and the time when the processes are forcibly halted with a kill signal.
  /// Set this value longer than the expected cleanup time for your process.
  /// Defaults to 30 seconds.
  /// +optional
  @$pb.TagNumber(4)
  $fixnum.Int64 get terminationGracePeriodSeconds => $_getI64(3);
  @$pb.TagNumber(4)
  set terminationGracePeriodSeconds($fixnum.Int64 v) { $_setInt64(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasTerminationGracePeriodSeconds() => $_has(3);
  @$pb.TagNumber(4)
  void clearTerminationGracePeriodSeconds() => clearField(4);

  /// Optional duration in seconds the pod may be active on the node relative to
  /// StartTime before the system will actively try to mark it failed and kill associated containers.
  /// Value must be a positive integer.
  /// +optional
  @$pb.TagNumber(5)
  $fixnum.Int64 get activeDeadlineSeconds => $_getI64(4);
  @$pb.TagNumber(5)
  set activeDeadlineSeconds($fixnum.Int64 v) { $_setInt64(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasActiveDeadlineSeconds() => $_has(4);
  @$pb.TagNumber(5)
  void clearActiveDeadlineSeconds() => clearField(5);

  /// Set DNS policy for the pod.
  /// Defaults to "ClusterFirst".
  /// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  /// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  /// To have DNS options set along with hostNetwork, you have to specify DNS policy
  /// explicitly to 'ClusterFirstWithHostNet'.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get dnsPolicy => $_getSZ(5);
  @$pb.TagNumber(6)
  set dnsPolicy($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasDnsPolicy() => $_has(5);
  @$pb.TagNumber(6)
  void clearDnsPolicy() => clearField(6);

  /// NodeSelector is a selector which must be true for the pod to fit on a node.
  /// Selector which must match a node's labels for the pod to be scheduled on that node.
  /// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  /// +optional
  /// +mapType=atomic
  @$pb.TagNumber(7)
  $core.Map<$core.String, $core.String> get nodeSelector => $_getMap(6);

  /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  /// +optional
  @$pb.TagNumber(8)
  $core.String get serviceAccountName => $_getSZ(7);
  @$pb.TagNumber(8)
  set serviceAccountName($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasServiceAccountName() => $_has(7);
  @$pb.TagNumber(8)
  void clearServiceAccountName() => clearField(8);

  /// DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
  /// Deprecated: Use serviceAccountName instead.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(9)
  $core.String get serviceAccount => $_getSZ(8);
  @$pb.TagNumber(9)
  set serviceAccount($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasServiceAccount() => $_has(8);
  @$pb.TagNumber(9)
  void clearServiceAccount() => clearField(9);

  /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
  /// the scheduler simply schedules this pod onto that node, assuming that it fits resource
  /// requirements.
  /// +optional
  @$pb.TagNumber(10)
  $core.String get nodeName => $_getSZ(9);
  @$pb.TagNumber(10)
  set nodeName($core.String v) { $_setString(9, v); }
  @$pb.TagNumber(10)
  $core.bool hasNodeName() => $_has(9);
  @$pb.TagNumber(10)
  void clearNodeName() => clearField(10);

  /// Host networking requested for this pod. Use the host's network namespace.
  /// If this option is set, the ports that will be used must be specified.
  /// Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(11)
  $core.bool get hostNetwork => $_getBF(10);
  @$pb.TagNumber(11)
  set hostNetwork($core.bool v) { $_setBool(10, v); }
  @$pb.TagNumber(11)
  $core.bool hasHostNetwork() => $_has(10);
  @$pb.TagNumber(11)
  void clearHostNetwork() => clearField(11);

  /// Use the host's pid namespace.
  /// Optional: Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(12)
  $core.bool get hostPID => $_getBF(11);
  @$pb.TagNumber(12)
  set hostPID($core.bool v) { $_setBool(11, v); }
  @$pb.TagNumber(12)
  $core.bool hasHostPID() => $_has(11);
  @$pb.TagNumber(12)
  void clearHostPID() => clearField(12);

  /// Use the host's ipc namespace.
  /// Optional: Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(13)
  $core.bool get hostIPC => $_getBF(12);
  @$pb.TagNumber(13)
  set hostIPC($core.bool v) { $_setBool(12, v); }
  @$pb.TagNumber(13)
  $core.bool hasHostIPC() => $_has(12);
  @$pb.TagNumber(13)
  void clearHostIPC() => clearField(13);

  /// SecurityContext holds pod-level security attributes and common container settings.
  /// Optional: Defaults to empty.  See type description for default values of each field.
  /// +optional
  @$pb.TagNumber(14)
  PodSecurityContext get securityContext => $_getN(13);
  @$pb.TagNumber(14)
  set securityContext(PodSecurityContext v) { setField(14, v); }
  @$pb.TagNumber(14)
  $core.bool hasSecurityContext() => $_has(13);
  @$pb.TagNumber(14)
  void clearSecurityContext() => clearField(14);
  @$pb.TagNumber(14)
  PodSecurityContext ensureSecurityContext() => $_ensure(13);

  /// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  /// If specified, these secrets will be passed to individual puller implementations for them to use.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(15)
  $core.List<LocalObjectReference> get imagePullSecrets => $_getList(14);

  /// Specifies the hostname of the Pod
  /// If not specified, the pod's hostname will be set to a system-defined value.
  /// +optional
  @$pb.TagNumber(16)
  $core.String get hostname => $_getSZ(15);
  @$pb.TagNumber(16)
  set hostname($core.String v) { $_setString(15, v); }
  @$pb.TagNumber(16)
  $core.bool hasHostname() => $_has(15);
  @$pb.TagNumber(16)
  void clearHostname() => clearField(16);

  /// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
  /// If not specified, the pod will not have a domainname at all.
  /// +optional
  @$pb.TagNumber(17)
  $core.String get subdomain => $_getSZ(16);
  @$pb.TagNumber(17)
  set subdomain($core.String v) { $_setString(16, v); }
  @$pb.TagNumber(17)
  $core.bool hasSubdomain() => $_has(16);
  @$pb.TagNumber(17)
  void clearSubdomain() => clearField(17);

  /// If specified, the pod's scheduling constraints
  /// +optional
  @$pb.TagNumber(18)
  Affinity get affinity => $_getN(17);
  @$pb.TagNumber(18)
  set affinity(Affinity v) { setField(18, v); }
  @$pb.TagNumber(18)
  $core.bool hasAffinity() => $_has(17);
  @$pb.TagNumber(18)
  void clearAffinity() => clearField(18);
  @$pb.TagNumber(18)
  Affinity ensureAffinity() => $_ensure(17);

  /// If specified, the pod will be dispatched by specified scheduler.
  /// If not specified, the pod will be dispatched by default scheduler.
  /// +optional
  @$pb.TagNumber(19)
  $core.String get schedulerName => $_getSZ(18);
  @$pb.TagNumber(19)
  set schedulerName($core.String v) { $_setString(18, v); }
  @$pb.TagNumber(19)
  $core.bool hasSchedulerName() => $_has(18);
  @$pb.TagNumber(19)
  void clearSchedulerName() => clearField(19);

  /// List of initialization containers belonging to the pod.
  /// Init containers are executed in order prior to containers being started. If any
  /// init container fails, the pod is considered to have failed and is handled according
  /// to its restartPolicy. The name for an init container or normal container must be
  /// unique among all containers.
  /// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
  /// The resourceRequirements of an init container are taken into account during scheduling
  /// by finding the highest request/limit for each resource type, and then using the max of
  /// of that value or the sum of the normal containers. Limits are applied to init containers
  /// in a similar fashion.
  /// Init containers cannot currently be added or removed.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(20)
  $core.List<Container> get initContainers => $_getList(19);

  /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  /// +optional
  @$pb.TagNumber(21)
  $core.bool get automountServiceAccountToken => $_getBF(20);
  @$pb.TagNumber(21)
  set automountServiceAccountToken($core.bool v) { $_setBool(20, v); }
  @$pb.TagNumber(21)
  $core.bool hasAutomountServiceAccountToken() => $_has(20);
  @$pb.TagNumber(21)
  void clearAutomountServiceAccountToken() => clearField(21);

  /// If specified, the pod's tolerations.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(22)
  $core.List<Toleration> get tolerations => $_getList(21);

  /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
  /// file if specified.
  /// +optional
  /// +patchMergeKey=ip
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=ip
  @$pb.TagNumber(23)
  $core.List<HostAlias> get hostAliases => $_getList(22);

  /// If specified, indicates the pod's priority. "system-node-critical" and
  /// "system-cluster-critical" are two special keywords which indicate the
  /// highest priorities with the former being the highest priority. Any other
  /// name must be defined by creating a PriorityClass object with that name.
  /// If not specified, the pod priority will be default or zero if there is no
  /// default.
  /// +optional
  @$pb.TagNumber(24)
  $core.String get priorityClassName => $_getSZ(23);
  @$pb.TagNumber(24)
  set priorityClassName($core.String v) { $_setString(23, v); }
  @$pb.TagNumber(24)
  $core.bool hasPriorityClassName() => $_has(23);
  @$pb.TagNumber(24)
  void clearPriorityClassName() => clearField(24);

  /// The priority value. Various system components use this field to find the
  /// priority of the pod. When Priority Admission Controller is enabled, it
  /// prevents users from setting this field. The admission controller populates
  /// this field from PriorityClassName.
  /// The higher the value, the higher the priority.
  /// +optional
  @$pb.TagNumber(25)
  $core.int get priority => $_getIZ(24);
  @$pb.TagNumber(25)
  set priority($core.int v) { $_setSignedInt32(24, v); }
  @$pb.TagNumber(25)
  $core.bool hasPriority() => $_has(24);
  @$pb.TagNumber(25)
  void clearPriority() => clearField(25);

  /// Specifies the DNS parameters of a pod.
  /// Parameters specified here will be merged to the generated DNS
  /// configuration based on DNSPolicy.
  /// +optional
  @$pb.TagNumber(26)
  PodDNSConfig get dnsConfig => $_getN(25);
  @$pb.TagNumber(26)
  set dnsConfig(PodDNSConfig v) { setField(26, v); }
  @$pb.TagNumber(26)
  $core.bool hasDnsConfig() => $_has(25);
  @$pb.TagNumber(26)
  void clearDnsConfig() => clearField(26);
  @$pb.TagNumber(26)
  PodDNSConfig ensureDnsConfig() => $_ensure(25);

  /// Share a single process namespace between all of the containers in a pod.
  /// When this is set containers will be able to view and signal processes from other containers
  /// in the same pod, and the first process in each container will not be assigned PID 1.
  /// HostPID and ShareProcessNamespace cannot both be set.
  /// Optional: Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(27)
  $core.bool get shareProcessNamespace => $_getBF(26);
  @$pb.TagNumber(27)
  set shareProcessNamespace($core.bool v) { $_setBool(26, v); }
  @$pb.TagNumber(27)
  $core.bool hasShareProcessNamespace() => $_has(26);
  @$pb.TagNumber(27)
  void clearShareProcessNamespace() => clearField(27);

  /// If specified, all readiness gates will be evaluated for pod readiness.
  /// A pod is ready when all its containers are ready AND
  /// all conditions specified in the readiness gates have status equal to "True"
  /// More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(28)
  $core.List<PodReadinessGate> get readinessGates => $_getList(27);

  /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  /// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  /// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  /// empty definition that uses the default runtime handler.
  /// More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  /// +optional
  @$pb.TagNumber(29)
  $core.String get runtimeClassName => $_getSZ(28);
  @$pb.TagNumber(29)
  set runtimeClassName($core.String v) { $_setString(28, v); }
  @$pb.TagNumber(29)
  $core.bool hasRuntimeClassName() => $_has(28);
  @$pb.TagNumber(29)
  void clearRuntimeClassName() => clearField(29);

  /// EnableServiceLinks indicates whether information about services should be injected into pod's
  /// environment variables, matching the syntax of Docker links.
  /// Optional: Defaults to true.
  /// +optional
  @$pb.TagNumber(30)
  $core.bool get enableServiceLinks => $_getBF(29);
  @$pb.TagNumber(30)
  set enableServiceLinks($core.bool v) { $_setBool(29, v); }
  @$pb.TagNumber(30)
  $core.bool hasEnableServiceLinks() => $_has(29);
  @$pb.TagNumber(30)
  void clearEnableServiceLinks() => clearField(30);

  /// PreemptionPolicy is the Policy for preempting pods with lower priority.
  /// One of Never, PreemptLowerPriority.
  /// Defaults to PreemptLowerPriority if unset.
  /// +optional
  @$pb.TagNumber(31)
  $core.String get preemptionPolicy => $_getSZ(30);
  @$pb.TagNumber(31)
  set preemptionPolicy($core.String v) { $_setString(30, v); }
  @$pb.TagNumber(31)
  $core.bool hasPreemptionPolicy() => $_has(30);
  @$pb.TagNumber(31)
  void clearPreemptionPolicy() => clearField(31);

  /// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
  /// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
  /// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
  /// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
  /// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
  /// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
  /// More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
  /// +optional
  @$pb.TagNumber(32)
  $core.Map<$core.String, $1.Quantity> get overhead => $_getMap(31);

  /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
  /// domains. Scheduler will schedule pods in a way which abides by the constraints.
  /// All topologySpreadConstraints are ANDed.
  /// +optional
  /// +patchMergeKey=topologyKey
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=topologyKey
  /// +listMapKey=whenUnsatisfiable
  @$pb.TagNumber(33)
  $core.List<TopologySpreadConstraint> get topologySpreadConstraints => $_getList(32);

  /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
  /// pod to perform user-initiated actions such as debugging. This list cannot be specified when
  /// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
  /// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(34)
  $core.List<EphemeralContainer> get ephemeralContainers => $_getList(33);

  /// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
  /// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
  /// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
  /// If a pod does not have FQDN, this has no effect.
  /// Default to false.
  /// +optional
  @$pb.TagNumber(35)
  $core.bool get setHostnameAsFQDN => $_getBF(34);
  @$pb.TagNumber(35)
  set setHostnameAsFQDN($core.bool v) { $_setBool(34, v); }
  @$pb.TagNumber(35)
  $core.bool hasSetHostnameAsFQDN() => $_has(34);
  @$pb.TagNumber(35)
  void clearSetHostnameAsFQDN() => clearField(35);

  ///  Specifies the OS of the containers in the pod.
  ///  Some pod and container fields are restricted if this is set.
  ///
  ///  If the OS field is set to linux, the following fields must be unset:
  ///  -securityContext.windowsOptions
  ///
  ///  If the OS field is set to windows, following fields must be unset:
  ///  - spec.hostPID
  ///  - spec.hostIPC
  ///  - spec.hostUsers
  ///  - spec.securityContext.appArmorProfile
  ///  - spec.securityContext.seLinuxOptions
  ///  - spec.securityContext.seccompProfile
  ///  - spec.securityContext.fsGroup
  ///  - spec.securityContext.fsGroupChangePolicy
  ///  - spec.securityContext.sysctls
  ///  - spec.shareProcessNamespace
  ///  - spec.securityContext.runAsUser
  ///  - spec.securityContext.runAsGroup
  ///  - spec.securityContext.supplementalGroups
  ///  - spec.containers[*].securityContext.appArmorProfile
  ///  - spec.containers[*].securityContext.seLinuxOptions
  ///  - spec.containers[*].securityContext.seccompProfile
  ///  - spec.containers[*].securityContext.capabilities
  ///  - spec.containers[*].securityContext.readOnlyRootFilesystem
  ///  - spec.containers[*].securityContext.privileged
  ///  - spec.containers[*].securityContext.allowPrivilegeEscalation
  ///  - spec.containers[*].securityContext.procMount
  ///  - spec.containers[*].securityContext.runAsUser
  ///  - spec.containers[*].securityContext.runAsGroup
  ///  +optional
  @$pb.TagNumber(36)
  PodOS get os => $_getN(35);
  @$pb.TagNumber(36)
  set os(PodOS v) { setField(36, v); }
  @$pb.TagNumber(36)
  $core.bool hasOs() => $_has(35);
  @$pb.TagNumber(36)
  void clearOs() => clearField(36);
  @$pb.TagNumber(36)
  PodOS ensureOs() => $_ensure(35);

  /// Use the host's user namespace.
  /// Optional: Default to true.
  /// If set to true or not present, the pod will be run in the host user namespace, useful
  /// for when the pod needs a feature only available to the host user namespace, such as
  /// loading a kernel module with CAP_SYS_MODULE.
  /// When set to false, a new userns is created for the pod. Setting false is useful for
  /// mitigating container breakout vulnerabilities even allowing users to run their
  /// containers as root without actually having root privileges on the host.
  /// This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(37)
  $core.bool get hostUsers => $_getBF(36);
  @$pb.TagNumber(37)
  set hostUsers($core.bool v) { $_setBool(36, v); }
  @$pb.TagNumber(37)
  $core.bool hasHostUsers() => $_has(36);
  @$pb.TagNumber(37)
  void clearHostUsers() => clearField(37);

  ///  SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
  ///  If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
  ///  scheduler will not attempt to schedule the pod.
  ///
  ///  SchedulingGates can only be set at pod creation time, and be removed only afterwards.
  ///
  ///  +patchMergeKey=name
  ///  +patchStrategy=merge
  ///  +listType=map
  ///  +listMapKey=name
  ///  +optional
  @$pb.TagNumber(38)
  $core.List<PodSchedulingGate> get schedulingGates => $_getList(37);

  ///  ResourceClaims defines which ResourceClaims must be allocated
  ///  and reserved before the Pod is allowed to start. The resources
  ///  will be made available to those containers which consume them
  ///  by name.
  ///
  ///  This is an alpha field and requires enabling the
  ///  DynamicResourceAllocation feature gate.
  ///
  ///  This field is immutable.
  ///
  ///  +patchMergeKey=name
  ///  +patchStrategy=merge,retainKeys
  ///  +listType=map
  ///  +listMapKey=name
  ///  +featureGate=DynamicResourceAllocation
  ///  +optional
  @$pb.TagNumber(39)
  $core.List<PodResourceClaim> get resourceClaims => $_getList(38);
}

/// PodStatus represents information about the status of a pod. Status may trail the actual
/// state of a system, especially if the node that hosts the pod cannot contact the control
/// plane.
class PodStatus extends $pb.GeneratedMessage {
  factory PodStatus({
    $core.String? phase,
    $core.Iterable<PodCondition>? conditions,
    $core.String? message,
    $core.String? reason,
    $core.String? hostIP,
    $core.String? podIP,
    $0.Time? startTime,
    $core.Iterable<ContainerStatus>? containerStatuses,
    $core.String? qosClass,
    $core.Iterable<ContainerStatus>? initContainerStatuses,
    $core.String? nominatedNodeName,
    $core.Iterable<PodIP>? podIPs,
    $core.Iterable<ContainerStatus>? ephemeralContainerStatuses,
    $core.String? resize,
    $core.Iterable<PodResourceClaimStatus>? resourceClaimStatuses,
    $core.Iterable<HostIP>? hostIPs,
  }) {
    final $result = create();
    if (phase != null) {
      $result.phase = phase;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    if (message != null) {
      $result.message = message;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (hostIP != null) {
      $result.hostIP = hostIP;
    }
    if (podIP != null) {
      $result.podIP = podIP;
    }
    if (startTime != null) {
      $result.startTime = startTime;
    }
    if (containerStatuses != null) {
      $result.containerStatuses.addAll(containerStatuses);
    }
    if (qosClass != null) {
      $result.qosClass = qosClass;
    }
    if (initContainerStatuses != null) {
      $result.initContainerStatuses.addAll(initContainerStatuses);
    }
    if (nominatedNodeName != null) {
      $result.nominatedNodeName = nominatedNodeName;
    }
    if (podIPs != null) {
      $result.podIPs.addAll(podIPs);
    }
    if (ephemeralContainerStatuses != null) {
      $result.ephemeralContainerStatuses.addAll(ephemeralContainerStatuses);
    }
    if (resize != null) {
      $result.resize = resize;
    }
    if (resourceClaimStatuses != null) {
      $result.resourceClaimStatuses.addAll(resourceClaimStatuses);
    }
    if (hostIPs != null) {
      $result.hostIPs.addAll(hostIPs);
    }
    return $result;
  }
  PodStatus._() : super();
  factory PodStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'phase')
    ..pc<PodCondition>(2, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: PodCondition.create)
    ..aOS(3, _omitFieldNames ? '' : 'message')
    ..aOS(4, _omitFieldNames ? '' : 'reason')
    ..aOS(5, _omitFieldNames ? '' : 'hostIP', protoName: 'hostIP')
    ..aOS(6, _omitFieldNames ? '' : 'podIP', protoName: 'podIP')
    ..aOM<$0.Time>(7, _omitFieldNames ? '' : 'startTime', protoName: 'startTime', subBuilder: $0.Time.create)
    ..pc<ContainerStatus>(8, _omitFieldNames ? '' : 'containerStatuses', $pb.PbFieldType.PM, protoName: 'containerStatuses', subBuilder: ContainerStatus.create)
    ..aOS(9, _omitFieldNames ? '' : 'qosClass', protoName: 'qosClass')
    ..pc<ContainerStatus>(10, _omitFieldNames ? '' : 'initContainerStatuses', $pb.PbFieldType.PM, protoName: 'initContainerStatuses', subBuilder: ContainerStatus.create)
    ..aOS(11, _omitFieldNames ? '' : 'nominatedNodeName', protoName: 'nominatedNodeName')
    ..pc<PodIP>(12, _omitFieldNames ? '' : 'podIPs', $pb.PbFieldType.PM, protoName: 'podIPs', subBuilder: PodIP.create)
    ..pc<ContainerStatus>(13, _omitFieldNames ? '' : 'ephemeralContainerStatuses', $pb.PbFieldType.PM, protoName: 'ephemeralContainerStatuses', subBuilder: ContainerStatus.create)
    ..aOS(14, _omitFieldNames ? '' : 'resize')
    ..pc<PodResourceClaimStatus>(15, _omitFieldNames ? '' : 'resourceClaimStatuses', $pb.PbFieldType.PM, protoName: 'resourceClaimStatuses', subBuilder: PodResourceClaimStatus.create)
    ..pc<HostIP>(16, _omitFieldNames ? '' : 'hostIPs', $pb.PbFieldType.PM, protoName: 'hostIPs', subBuilder: HostIP.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodStatus clone() => PodStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodStatus copyWith(void Function(PodStatus) updates) => super.copyWith((message) => updates(message as PodStatus)) as PodStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodStatus create() => PodStatus._();
  PodStatus createEmptyInstance() => create();
  static $pb.PbList<PodStatus> createRepeated() => $pb.PbList<PodStatus>();
  @$core.pragma('dart2js:noInline')
  static PodStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodStatus>(create);
  static PodStatus? _defaultInstance;

  ///  The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
  ///  The conditions array, the reason and message fields, and the individual container status
  ///  arrays contain more detail about the pod's status.
  ///  There are five possible phase values:
  ///
  ///  Pending: The pod has been accepted by the Kubernetes system, but one or more of the
  ///  container images has not been created. This includes time before being scheduled as
  ///  well as time spent downloading images over the network, which could take a while.
  ///  Running: The pod has been bound to a node, and all of the containers have been created.
  ///  At least one container is still running, or is in the process of starting or restarting.
  ///  Succeeded: All containers in the pod have terminated in success, and will not be restarted.
  ///  Failed: All containers in the pod have terminated, and at least one container has
  ///  terminated in failure. The container either exited with non-zero status or was terminated
  ///  by the system.
  ///  Unknown: For some reason the state of the pod could not be obtained, typically due to an
  ///  error in communicating with the host of the pod.
  ///
  ///  More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
  ///  +optional
  @$pb.TagNumber(1)
  $core.String get phase => $_getSZ(0);
  @$pb.TagNumber(1)
  set phase($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPhase() => $_has(0);
  @$pb.TagNumber(1)
  void clearPhase() => clearField(1);

  /// Current service state of pod.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(2)
  $core.List<PodCondition> get conditions => $_getList(1);

  /// A human readable message indicating details about why the pod is in this condition.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get message => $_getSZ(2);
  @$pb.TagNumber(3)
  set message($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasMessage() => $_has(2);
  @$pb.TagNumber(3)
  void clearMessage() => clearField(3);

  /// A brief CamelCase message indicating details about why the pod is in this state.
  /// e.g. 'Evicted'
  /// +optional
  @$pb.TagNumber(4)
  $core.String get reason => $_getSZ(3);
  @$pb.TagNumber(4)
  set reason($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReason() => $_has(3);
  @$pb.TagNumber(4)
  void clearReason() => clearField(4);

  /// hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
  /// A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
  /// not be updated even if there is a node is assigned to pod
  /// +optional
  @$pb.TagNumber(5)
  $core.String get hostIP => $_getSZ(4);
  @$pb.TagNumber(5)
  set hostIP($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasHostIP() => $_has(4);
  @$pb.TagNumber(5)
  void clearHostIP() => clearField(5);

  /// podIP address allocated to the pod. Routable at least within the cluster.
  /// Empty if not yet allocated.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get podIP => $_getSZ(5);
  @$pb.TagNumber(6)
  set podIP($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasPodIP() => $_has(5);
  @$pb.TagNumber(6)
  void clearPodIP() => clearField(6);

  /// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
  /// This is before the Kubelet pulled the container image(s) for the pod.
  /// +optional
  @$pb.TagNumber(7)
  $0.Time get startTime => $_getN(6);
  @$pb.TagNumber(7)
  set startTime($0.Time v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasStartTime() => $_has(6);
  @$pb.TagNumber(7)
  void clearStartTime() => clearField(7);
  @$pb.TagNumber(7)
  $0.Time ensureStartTime() => $_ensure(6);

  /// The list has one entry per container in the manifest.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(8)
  $core.List<ContainerStatus> get containerStatuses => $_getList(7);

  /// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
  /// See PodQOSClass type for available QOS classes
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
  /// +optional
  @$pb.TagNumber(9)
  $core.String get qosClass => $_getSZ(8);
  @$pb.TagNumber(9)
  set qosClass($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasQosClass() => $_has(8);
  @$pb.TagNumber(9)
  void clearQosClass() => clearField(9);

  /// The list has one entry per init container in the manifest. The most recent successful
  /// init container will have ready = true, the most recently started container will have
  /// startTime set.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  /// +listType=atomic
  @$pb.TagNumber(10)
  $core.List<ContainerStatus> get initContainerStatuses => $_getList(9);

  /// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
  /// scheduled right away as preemption victims receive their graceful termination periods.
  /// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
  /// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
  /// give the resources on this node to a higher priority pod that is created after preemption.
  /// As a result, this field may be different than PodSpec.nodeName when the pod is
  /// scheduled.
  /// +optional
  @$pb.TagNumber(11)
  $core.String get nominatedNodeName => $_getSZ(10);
  @$pb.TagNumber(11)
  set nominatedNodeName($core.String v) { $_setString(10, v); }
  @$pb.TagNumber(11)
  $core.bool hasNominatedNodeName() => $_has(10);
  @$pb.TagNumber(11)
  void clearNominatedNodeName() => clearField(11);

  /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
  /// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
  /// is empty if no IPs have been allocated yet.
  /// +optional
  /// +patchStrategy=merge
  /// +patchMergeKey=ip
  /// +listType=map
  /// +listMapKey=ip
  @$pb.TagNumber(12)
  $core.List<PodIP> get podIPs => $_getList(11);

  /// Status for any ephemeral containers that have run in this pod.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(13)
  $core.List<ContainerStatus> get ephemeralContainerStatuses => $_getList(12);

  /// Status of resources resize desired for pod's containers.
  /// It is empty if no resources resize is pending.
  /// Any changes to container resources will automatically set this to "Proposed"
  /// +featureGate=InPlacePodVerticalScaling
  /// +optional
  @$pb.TagNumber(14)
  $core.String get resize => $_getSZ(13);
  @$pb.TagNumber(14)
  set resize($core.String v) { $_setString(13, v); }
  @$pb.TagNumber(14)
  $core.bool hasResize() => $_has(13);
  @$pb.TagNumber(14)
  void clearResize() => clearField(14);

  /// Status of resource claims.
  /// +patchMergeKey=name
  /// +patchStrategy=merge,retainKeys
  /// +listType=map
  /// +listMapKey=name
  /// +featureGate=DynamicResourceAllocation
  /// +optional
  @$pb.TagNumber(15)
  $core.List<PodResourceClaimStatus> get resourceClaimStatuses => $_getList(14);

  /// hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
  /// match the hostIP field. This list is empty if the pod has not started yet.
  /// A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
  /// not be updated even if there is a node is assigned to this pod.
  /// +optional
  /// +patchStrategy=merge
  /// +patchMergeKey=ip
  /// +listType=atomic
  @$pb.TagNumber(16)
  $core.List<HostIP> get hostIPs => $_getList(15);
}

/// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
class PodStatusResult extends $pb.GeneratedMessage {
  factory PodStatusResult({
    $0.ObjectMeta? metadata,
    PodStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  PodStatusResult._() : super();
  factory PodStatusResult.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodStatusResult.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodStatusResult', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PodStatus>(2, _omitFieldNames ? '' : 'status', subBuilder: PodStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodStatusResult clone() => PodStatusResult()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodStatusResult copyWith(void Function(PodStatusResult) updates) => super.copyWith((message) => updates(message as PodStatusResult)) as PodStatusResult;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodStatusResult create() => PodStatusResult._();
  PodStatusResult createEmptyInstance() => create();
  static $pb.PbList<PodStatusResult> createRepeated() => $pb.PbList<PodStatusResult>();
  @$core.pragma('dart2js:noInline')
  static PodStatusResult getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodStatusResult>(create);
  static PodStatusResult? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Most recently observed status of the pod.
  /// This data may not be up to date.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  PodStatus get status => $_getN(1);
  @$pb.TagNumber(2)
  set status(PodStatus v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);
  @$pb.TagNumber(2)
  PodStatus ensureStatus() => $_ensure(1);
}

/// PodTemplate describes a template for creating copies of a predefined pod.
class PodTemplate extends $pb.GeneratedMessage {
  factory PodTemplate({
    $0.ObjectMeta? metadata,
    PodTemplateSpec? template,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (template != null) {
      $result.template = template;
    }
    return $result;
  }
  PodTemplate._() : super();
  factory PodTemplate.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodTemplate.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodTemplate', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PodTemplateSpec>(2, _omitFieldNames ? '' : 'template', subBuilder: PodTemplateSpec.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodTemplate clone() => PodTemplate()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodTemplate copyWith(void Function(PodTemplate) updates) => super.copyWith((message) => updates(message as PodTemplate)) as PodTemplate;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodTemplate create() => PodTemplate._();
  PodTemplate createEmptyInstance() => create();
  static $pb.PbList<PodTemplate> createRepeated() => $pb.PbList<PodTemplate>();
  @$core.pragma('dart2js:noInline')
  static PodTemplate getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodTemplate>(create);
  static PodTemplate? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Template defines the pods that will be created from this pod template.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  PodTemplateSpec get template => $_getN(1);
  @$pb.TagNumber(2)
  set template(PodTemplateSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasTemplate() => $_has(1);
  @$pb.TagNumber(2)
  void clearTemplate() => clearField(2);
  @$pb.TagNumber(2)
  PodTemplateSpec ensureTemplate() => $_ensure(1);
}

/// PodTemplateList is a list of PodTemplates.
class PodTemplateList extends $pb.GeneratedMessage {
  factory PodTemplateList({
    $0.ListMeta? metadata,
    $core.Iterable<PodTemplate>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  PodTemplateList._() : super();
  factory PodTemplateList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodTemplateList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodTemplateList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<PodTemplate>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: PodTemplate.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodTemplateList clone() => PodTemplateList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodTemplateList copyWith(void Function(PodTemplateList) updates) => super.copyWith((message) => updates(message as PodTemplateList)) as PodTemplateList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodTemplateList create() => PodTemplateList._();
  PodTemplateList createEmptyInstance() => create();
  static $pb.PbList<PodTemplateList> createRepeated() => $pb.PbList<PodTemplateList>();
  @$core.pragma('dart2js:noInline')
  static PodTemplateList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodTemplateList>(create);
  static PodTemplateList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of pod templates
  @$pb.TagNumber(2)
  $core.List<PodTemplate> get items => $_getList(1);
}

/// PodTemplateSpec describes the data a pod should have when created from a template
class PodTemplateSpec extends $pb.GeneratedMessage {
  factory PodTemplateSpec({
    $0.ObjectMeta? metadata,
    PodSpec? spec,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    return $result;
  }
  PodTemplateSpec._() : super();
  factory PodTemplateSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PodTemplateSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PodTemplateSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<PodSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: PodSpec.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PodTemplateSpec clone() => PodTemplateSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PodTemplateSpec copyWith(void Function(PodTemplateSpec) updates) => super.copyWith((message) => updates(message as PodTemplateSpec)) as PodTemplateSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PodTemplateSpec create() => PodTemplateSpec._();
  PodTemplateSpec createEmptyInstance() => create();
  static $pb.PbList<PodTemplateSpec> createRepeated() => $pb.PbList<PodTemplateSpec>();
  @$core.pragma('dart2js:noInline')
  static PodTemplateSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PodTemplateSpec>(create);
  static PodTemplateSpec? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Specification of the desired behavior of the pod.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  PodSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(PodSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  PodSpec ensureSpec() => $_ensure(1);
}

class PortStatus extends $pb.GeneratedMessage {
  factory PortStatus({
    $core.int? port,
    $core.String? protocol,
    $core.String? error,
  }) {
    final $result = create();
    if (port != null) {
      $result.port = port;
    }
    if (protocol != null) {
      $result.protocol = protocol;
    }
    if (error != null) {
      $result.error = error;
    }
    return $result;
  }
  PortStatus._() : super();
  factory PortStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PortStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PortStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'port', $pb.PbFieldType.O3)
    ..aOS(2, _omitFieldNames ? '' : 'protocol')
    ..aOS(3, _omitFieldNames ? '' : 'error')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PortStatus clone() => PortStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PortStatus copyWith(void Function(PortStatus) updates) => super.copyWith((message) => updates(message as PortStatus)) as PortStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PortStatus create() => PortStatus._();
  PortStatus createEmptyInstance() => create();
  static $pb.PbList<PortStatus> createRepeated() => $pb.PbList<PortStatus>();
  @$core.pragma('dart2js:noInline')
  static PortStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PortStatus>(create);
  static PortStatus? _defaultInstance;

  /// Port is the port number of the service port of which status is recorded here
  @$pb.TagNumber(1)
  $core.int get port => $_getIZ(0);
  @$pb.TagNumber(1)
  set port($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPort() => $_has(0);
  @$pb.TagNumber(1)
  void clearPort() => clearField(1);

  /// Protocol is the protocol of the service port of which status is recorded here
  /// The supported values are: "TCP", "UDP", "SCTP"
  @$pb.TagNumber(2)
  $core.String get protocol => $_getSZ(1);
  @$pb.TagNumber(2)
  set protocol($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasProtocol() => $_has(1);
  @$pb.TagNumber(2)
  void clearProtocol() => clearField(2);

  /// Error is to record the problem with the service port
  /// The format of the error shall comply with the following rules:
  /// - built-in error values shall be specified in this file and those shall use
  ///   CamelCase names
  /// - cloud provider specific error values must have names that comply with the
  ///   format foo.example.com/CamelCase.
  /// ---
  /// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
  /// +optional
  /// +kubebuilder:validation:Required
  /// +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
  /// +kubebuilder:validation:MaxLength=316
  @$pb.TagNumber(3)
  $core.String get error => $_getSZ(2);
  @$pb.TagNumber(3)
  set error($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasError() => $_has(2);
  @$pb.TagNumber(3)
  void clearError() => clearField(3);
}

/// PortworxVolumeSource represents a Portworx volume resource.
class PortworxVolumeSource extends $pb.GeneratedMessage {
  factory PortworxVolumeSource({
    $core.String? volumeID,
    $core.String? fsType,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (volumeID != null) {
      $result.volumeID = volumeID;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  PortworxVolumeSource._() : super();
  factory PortworxVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PortworxVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PortworxVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeID', protoName: 'volumeID')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PortworxVolumeSource clone() => PortworxVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PortworxVolumeSource copyWith(void Function(PortworxVolumeSource) updates) => super.copyWith((message) => updates(message as PortworxVolumeSource)) as PortworxVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PortworxVolumeSource create() => PortworxVolumeSource._();
  PortworxVolumeSource createEmptyInstance() => create();
  static $pb.PbList<PortworxVolumeSource> createRepeated() => $pb.PbList<PortworxVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static PortworxVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PortworxVolumeSource>(create);
  static PortworxVolumeSource? _defaultInstance;

  /// volumeID uniquely identifies a Portworx volume
  @$pb.TagNumber(1)
  $core.String get volumeID => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeID($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeID() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeID() => clearField(1);

  /// fSType represents the filesystem type to mount
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);
}

/// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
/// +k8s:openapi-gen=false
class Preconditions extends $pb.GeneratedMessage {
  factory Preconditions({
    $core.String? uid,
  }) {
    final $result = create();
    if (uid != null) {
      $result.uid = uid;
    }
    return $result;
  }
  Preconditions._() : super();
  factory Preconditions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Preconditions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Preconditions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'uid')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Preconditions clone() => Preconditions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Preconditions copyWith(void Function(Preconditions) updates) => super.copyWith((message) => updates(message as Preconditions)) as Preconditions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Preconditions create() => Preconditions._();
  Preconditions createEmptyInstance() => create();
  static $pb.PbList<Preconditions> createRepeated() => $pb.PbList<Preconditions>();
  @$core.pragma('dart2js:noInline')
  static Preconditions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Preconditions>(create);
  static Preconditions? _defaultInstance;

  /// Specifies the target UID.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get uid => $_getSZ(0);
  @$pb.TagNumber(1)
  set uid($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasUid() => $_has(0);
  @$pb.TagNumber(1)
  void clearUid() => clearField(1);
}

/// Describes a class of pods that should avoid this node.
class PreferAvoidPodsEntry extends $pb.GeneratedMessage {
  factory PreferAvoidPodsEntry({
    PodSignature? podSignature,
    $0.Time? evictionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (podSignature != null) {
      $result.podSignature = podSignature;
    }
    if (evictionTime != null) {
      $result.evictionTime = evictionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  PreferAvoidPodsEntry._() : super();
  factory PreferAvoidPodsEntry.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PreferAvoidPodsEntry.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PreferAvoidPodsEntry', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<PodSignature>(1, _omitFieldNames ? '' : 'podSignature', protoName: 'podSignature', subBuilder: PodSignature.create)
    ..aOM<$0.Time>(2, _omitFieldNames ? '' : 'evictionTime', protoName: 'evictionTime', subBuilder: $0.Time.create)
    ..aOS(3, _omitFieldNames ? '' : 'reason')
    ..aOS(4, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PreferAvoidPodsEntry clone() => PreferAvoidPodsEntry()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PreferAvoidPodsEntry copyWith(void Function(PreferAvoidPodsEntry) updates) => super.copyWith((message) => updates(message as PreferAvoidPodsEntry)) as PreferAvoidPodsEntry;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PreferAvoidPodsEntry create() => PreferAvoidPodsEntry._();
  PreferAvoidPodsEntry createEmptyInstance() => create();
  static $pb.PbList<PreferAvoidPodsEntry> createRepeated() => $pb.PbList<PreferAvoidPodsEntry>();
  @$core.pragma('dart2js:noInline')
  static PreferAvoidPodsEntry getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PreferAvoidPodsEntry>(create);
  static PreferAvoidPodsEntry? _defaultInstance;

  /// The class of pods.
  @$pb.TagNumber(1)
  PodSignature get podSignature => $_getN(0);
  @$pb.TagNumber(1)
  set podSignature(PodSignature v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasPodSignature() => $_has(0);
  @$pb.TagNumber(1)
  void clearPodSignature() => clearField(1);
  @$pb.TagNumber(1)
  PodSignature ensurePodSignature() => $_ensure(0);

  /// Time at which this entry was added to the list.
  /// +optional
  @$pb.TagNumber(2)
  $0.Time get evictionTime => $_getN(1);
  @$pb.TagNumber(2)
  set evictionTime($0.Time v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasEvictionTime() => $_has(1);
  @$pb.TagNumber(2)
  void clearEvictionTime() => clearField(2);
  @$pb.TagNumber(2)
  $0.Time ensureEvictionTime() => $_ensure(1);

  /// (brief) reason why this entry was added to the list.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get reason => $_getSZ(2);
  @$pb.TagNumber(3)
  set reason($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReason() => $_has(2);
  @$pb.TagNumber(3)
  void clearReason() => clearField(3);

  /// Human readable message indicating why this entry was added to the list.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get message => $_getSZ(3);
  @$pb.TagNumber(4)
  set message($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasMessage() => $_has(3);
  @$pb.TagNumber(4)
  void clearMessage() => clearField(4);
}

/// An empty preferred scheduling term matches all objects with implicit weight 0
/// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
class PreferredSchedulingTerm extends $pb.GeneratedMessage {
  factory PreferredSchedulingTerm({
    $core.int? weight,
    NodeSelectorTerm? preference,
  }) {
    final $result = create();
    if (weight != null) {
      $result.weight = weight;
    }
    if (preference != null) {
      $result.preference = preference;
    }
    return $result;
  }
  PreferredSchedulingTerm._() : super();
  factory PreferredSchedulingTerm.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory PreferredSchedulingTerm.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'PreferredSchedulingTerm', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'weight', $pb.PbFieldType.O3)
    ..aOM<NodeSelectorTerm>(2, _omitFieldNames ? '' : 'preference', subBuilder: NodeSelectorTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  PreferredSchedulingTerm clone() => PreferredSchedulingTerm()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  PreferredSchedulingTerm copyWith(void Function(PreferredSchedulingTerm) updates) => super.copyWith((message) => updates(message as PreferredSchedulingTerm)) as PreferredSchedulingTerm;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PreferredSchedulingTerm create() => PreferredSchedulingTerm._();
  PreferredSchedulingTerm createEmptyInstance() => create();
  static $pb.PbList<PreferredSchedulingTerm> createRepeated() => $pb.PbList<PreferredSchedulingTerm>();
  @$core.pragma('dart2js:noInline')
  static PreferredSchedulingTerm getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<PreferredSchedulingTerm>(create);
  static PreferredSchedulingTerm? _defaultInstance;

  /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  @$pb.TagNumber(1)
  $core.int get weight => $_getIZ(0);
  @$pb.TagNumber(1)
  set weight($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasWeight() => $_has(0);
  @$pb.TagNumber(1)
  void clearWeight() => clearField(1);

  /// A node selector term, associated with the corresponding weight.
  @$pb.TagNumber(2)
  NodeSelectorTerm get preference => $_getN(1);
  @$pb.TagNumber(2)
  set preference(NodeSelectorTerm v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPreference() => $_has(1);
  @$pb.TagNumber(2)
  void clearPreference() => clearField(2);
  @$pb.TagNumber(2)
  NodeSelectorTerm ensurePreference() => $_ensure(1);
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
class Probe extends $pb.GeneratedMessage {
  factory Probe({
    ProbeHandler? handler,
    $core.int? initialDelaySeconds,
    $core.int? timeoutSeconds,
    $core.int? periodSeconds,
    $core.int? successThreshold,
    $core.int? failureThreshold,
    $fixnum.Int64? terminationGracePeriodSeconds,
  }) {
    final $result = create();
    if (handler != null) {
      $result.handler = handler;
    }
    if (initialDelaySeconds != null) {
      $result.initialDelaySeconds = initialDelaySeconds;
    }
    if (timeoutSeconds != null) {
      $result.timeoutSeconds = timeoutSeconds;
    }
    if (periodSeconds != null) {
      $result.periodSeconds = periodSeconds;
    }
    if (successThreshold != null) {
      $result.successThreshold = successThreshold;
    }
    if (failureThreshold != null) {
      $result.failureThreshold = failureThreshold;
    }
    if (terminationGracePeriodSeconds != null) {
      $result.terminationGracePeriodSeconds = terminationGracePeriodSeconds;
    }
    return $result;
  }
  Probe._() : super();
  factory Probe.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Probe.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Probe', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ProbeHandler>(1, _omitFieldNames ? '' : 'handler', subBuilder: ProbeHandler.create)
    ..a<$core.int>(2, _omitFieldNames ? '' : 'initialDelaySeconds', $pb.PbFieldType.O3, protoName: 'initialDelaySeconds')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'timeoutSeconds', $pb.PbFieldType.O3, protoName: 'timeoutSeconds')
    ..a<$core.int>(4, _omitFieldNames ? '' : 'periodSeconds', $pb.PbFieldType.O3, protoName: 'periodSeconds')
    ..a<$core.int>(5, _omitFieldNames ? '' : 'successThreshold', $pb.PbFieldType.O3, protoName: 'successThreshold')
    ..a<$core.int>(6, _omitFieldNames ? '' : 'failureThreshold', $pb.PbFieldType.O3, protoName: 'failureThreshold')
    ..aInt64(7, _omitFieldNames ? '' : 'terminationGracePeriodSeconds', protoName: 'terminationGracePeriodSeconds')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Probe clone() => Probe()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Probe copyWith(void Function(Probe) updates) => super.copyWith((message) => updates(message as Probe)) as Probe;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Probe create() => Probe._();
  Probe createEmptyInstance() => create();
  static $pb.PbList<Probe> createRepeated() => $pb.PbList<Probe>();
  @$core.pragma('dart2js:noInline')
  static Probe getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Probe>(create);
  static Probe? _defaultInstance;

  /// The action taken to determine the health of a container
  @$pb.TagNumber(1)
  ProbeHandler get handler => $_getN(0);
  @$pb.TagNumber(1)
  set handler(ProbeHandler v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasHandler() => $_has(0);
  @$pb.TagNumber(1)
  void clearHandler() => clearField(1);
  @$pb.TagNumber(1)
  ProbeHandler ensureHandler() => $_ensure(0);

  /// Number of seconds after the container has started before liveness probes are initiated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  @$pb.TagNumber(2)
  $core.int get initialDelaySeconds => $_getIZ(1);
  @$pb.TagNumber(2)
  set initialDelaySeconds($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasInitialDelaySeconds() => $_has(1);
  @$pb.TagNumber(2)
  void clearInitialDelaySeconds() => clearField(2);

  /// Number of seconds after which the probe times out.
  /// Defaults to 1 second. Minimum value is 1.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  @$pb.TagNumber(3)
  $core.int get timeoutSeconds => $_getIZ(2);
  @$pb.TagNumber(3)
  set timeoutSeconds($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasTimeoutSeconds() => $_has(2);
  @$pb.TagNumber(3)
  void clearTimeoutSeconds() => clearField(3);

  /// How often (in seconds) to perform the probe.
  /// Default to 10 seconds. Minimum value is 1.
  /// +optional
  @$pb.TagNumber(4)
  $core.int get periodSeconds => $_getIZ(3);
  @$pb.TagNumber(4)
  set periodSeconds($core.int v) { $_setSignedInt32(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasPeriodSeconds() => $_has(3);
  @$pb.TagNumber(4)
  void clearPeriodSeconds() => clearField(4);

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  /// +optional
  @$pb.TagNumber(5)
  $core.int get successThreshold => $_getIZ(4);
  @$pb.TagNumber(5)
  set successThreshold($core.int v) { $_setSignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasSuccessThreshold() => $_has(4);
  @$pb.TagNumber(5)
  void clearSuccessThreshold() => clearField(5);

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
  /// Defaults to 3. Minimum value is 1.
  /// +optional
  @$pb.TagNumber(6)
  $core.int get failureThreshold => $_getIZ(5);
  @$pb.TagNumber(6)
  set failureThreshold($core.int v) { $_setSignedInt32(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasFailureThreshold() => $_has(5);
  @$pb.TagNumber(6)
  void clearFailureThreshold() => clearField(6);

  /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
  /// The grace period is the duration in seconds after the processes running in the pod are sent
  /// a termination signal and the time when the processes are forcibly halted with a kill signal.
  /// Set this value longer than the expected cleanup time for your process.
  /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
  /// value overrides the value provided by the pod spec.
  /// Value must be non-negative integer. The value zero indicates stop immediately via
  /// the kill signal (no opportunity to shut down).
  /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
  /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
  /// +optional
  @$pb.TagNumber(7)
  $fixnum.Int64 get terminationGracePeriodSeconds => $_getI64(6);
  @$pb.TagNumber(7)
  set terminationGracePeriodSeconds($fixnum.Int64 v) { $_setInt64(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasTerminationGracePeriodSeconds() => $_has(6);
  @$pb.TagNumber(7)
  void clearTerminationGracePeriodSeconds() => clearField(7);
}

/// ProbeHandler defines a specific action that should be taken in a probe.
/// One and only one of the fields must be specified.
class ProbeHandler extends $pb.GeneratedMessage {
  factory ProbeHandler({
    ExecAction? exec,
    HTTPGetAction? httpGet,
    TCPSocketAction? tcpSocket,
    GRPCAction? grpc,
  }) {
    final $result = create();
    if (exec != null) {
      $result.exec = exec;
    }
    if (httpGet != null) {
      $result.httpGet = httpGet;
    }
    if (tcpSocket != null) {
      $result.tcpSocket = tcpSocket;
    }
    if (grpc != null) {
      $result.grpc = grpc;
    }
    return $result;
  }
  ProbeHandler._() : super();
  factory ProbeHandler.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ProbeHandler.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ProbeHandler', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ExecAction>(1, _omitFieldNames ? '' : 'exec', subBuilder: ExecAction.create)
    ..aOM<HTTPGetAction>(2, _omitFieldNames ? '' : 'httpGet', protoName: 'httpGet', subBuilder: HTTPGetAction.create)
    ..aOM<TCPSocketAction>(3, _omitFieldNames ? '' : 'tcpSocket', protoName: 'tcpSocket', subBuilder: TCPSocketAction.create)
    ..aOM<GRPCAction>(4, _omitFieldNames ? '' : 'grpc', subBuilder: GRPCAction.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ProbeHandler clone() => ProbeHandler()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ProbeHandler copyWith(void Function(ProbeHandler) updates) => super.copyWith((message) => updates(message as ProbeHandler)) as ProbeHandler;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ProbeHandler create() => ProbeHandler._();
  ProbeHandler createEmptyInstance() => create();
  static $pb.PbList<ProbeHandler> createRepeated() => $pb.PbList<ProbeHandler>();
  @$core.pragma('dart2js:noInline')
  static ProbeHandler getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ProbeHandler>(create);
  static ProbeHandler? _defaultInstance;

  /// Exec specifies the action to take.
  /// +optional
  @$pb.TagNumber(1)
  ExecAction get exec => $_getN(0);
  @$pb.TagNumber(1)
  set exec(ExecAction v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasExec() => $_has(0);
  @$pb.TagNumber(1)
  void clearExec() => clearField(1);
  @$pb.TagNumber(1)
  ExecAction ensureExec() => $_ensure(0);

  /// HTTPGet specifies the http request to perform.
  /// +optional
  @$pb.TagNumber(2)
  HTTPGetAction get httpGet => $_getN(1);
  @$pb.TagNumber(2)
  set httpGet(HTTPGetAction v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasHttpGet() => $_has(1);
  @$pb.TagNumber(2)
  void clearHttpGet() => clearField(2);
  @$pb.TagNumber(2)
  HTTPGetAction ensureHttpGet() => $_ensure(1);

  /// TCPSocket specifies an action involving a TCP port.
  /// +optional
  @$pb.TagNumber(3)
  TCPSocketAction get tcpSocket => $_getN(2);
  @$pb.TagNumber(3)
  set tcpSocket(TCPSocketAction v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasTcpSocket() => $_has(2);
  @$pb.TagNumber(3)
  void clearTcpSocket() => clearField(3);
  @$pb.TagNumber(3)
  TCPSocketAction ensureTcpSocket() => $_ensure(2);

  /// GRPC specifies an action involving a GRPC port.
  /// +optional
  @$pb.TagNumber(4)
  GRPCAction get grpc => $_getN(3);
  @$pb.TagNumber(4)
  set grpc(GRPCAction v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasGrpc() => $_has(3);
  @$pb.TagNumber(4)
  void clearGrpc() => clearField(4);
  @$pb.TagNumber(4)
  GRPCAction ensureGrpc() => $_ensure(3);
}

/// Represents a projected volume source
class ProjectedVolumeSource extends $pb.GeneratedMessage {
  factory ProjectedVolumeSource({
    $core.Iterable<VolumeProjection>? sources,
    $core.int? defaultMode,
  }) {
    final $result = create();
    if (sources != null) {
      $result.sources.addAll(sources);
    }
    if (defaultMode != null) {
      $result.defaultMode = defaultMode;
    }
    return $result;
  }
  ProjectedVolumeSource._() : super();
  factory ProjectedVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ProjectedVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ProjectedVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<VolumeProjection>(1, _omitFieldNames ? '' : 'sources', $pb.PbFieldType.PM, subBuilder: VolumeProjection.create)
    ..a<$core.int>(2, _omitFieldNames ? '' : 'defaultMode', $pb.PbFieldType.O3, protoName: 'defaultMode')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ProjectedVolumeSource clone() => ProjectedVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ProjectedVolumeSource copyWith(void Function(ProjectedVolumeSource) updates) => super.copyWith((message) => updates(message as ProjectedVolumeSource)) as ProjectedVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ProjectedVolumeSource create() => ProjectedVolumeSource._();
  ProjectedVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ProjectedVolumeSource> createRepeated() => $pb.PbList<ProjectedVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ProjectedVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ProjectedVolumeSource>(create);
  static ProjectedVolumeSource? _defaultInstance;

  /// sources is the list of volume projections
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<VolumeProjection> get sources => $_getList(0);

  /// defaultMode are the mode bits used to set permissions on created files by default.
  /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(2)
  $core.int get defaultMode => $_getIZ(1);
  @$pb.TagNumber(2)
  set defaultMode($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDefaultMode() => $_has(1);
  @$pb.TagNumber(2)
  void clearDefaultMode() => clearField(2);
}

/// Represents a Quobyte mount that lasts the lifetime of a pod.
/// Quobyte volumes do not support ownership management or SELinux relabeling.
class QuobyteVolumeSource extends $pb.GeneratedMessage {
  factory QuobyteVolumeSource({
    $core.String? registry,
    $core.String? volume,
    $core.bool? readOnly,
    $core.String? user,
    $core.String? group,
    $core.String? tenant,
  }) {
    final $result = create();
    if (registry != null) {
      $result.registry = registry;
    }
    if (volume != null) {
      $result.volume = volume;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (user != null) {
      $result.user = user;
    }
    if (group != null) {
      $result.group = group;
    }
    if (tenant != null) {
      $result.tenant = tenant;
    }
    return $result;
  }
  QuobyteVolumeSource._() : super();
  factory QuobyteVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory QuobyteVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'QuobyteVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'registry')
    ..aOS(2, _omitFieldNames ? '' : 'volume')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(4, _omitFieldNames ? '' : 'user')
    ..aOS(5, _omitFieldNames ? '' : 'group')
    ..aOS(6, _omitFieldNames ? '' : 'tenant')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  QuobyteVolumeSource clone() => QuobyteVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  QuobyteVolumeSource copyWith(void Function(QuobyteVolumeSource) updates) => super.copyWith((message) => updates(message as QuobyteVolumeSource)) as QuobyteVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static QuobyteVolumeSource create() => QuobyteVolumeSource._();
  QuobyteVolumeSource createEmptyInstance() => create();
  static $pb.PbList<QuobyteVolumeSource> createRepeated() => $pb.PbList<QuobyteVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static QuobyteVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<QuobyteVolumeSource>(create);
  static QuobyteVolumeSource? _defaultInstance;

  /// registry represents a single or multiple Quobyte Registry services
  /// specified as a string as host:port pair (multiple entries are separated with commas)
  /// which acts as the central registry for volumes
  @$pb.TagNumber(1)
  $core.String get registry => $_getSZ(0);
  @$pb.TagNumber(1)
  set registry($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasRegistry() => $_has(0);
  @$pb.TagNumber(1)
  void clearRegistry() => clearField(1);

  /// volume is a string that references an already created Quobyte volume by name.
  @$pb.TagNumber(2)
  $core.String get volume => $_getSZ(1);
  @$pb.TagNumber(2)
  set volume($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasVolume() => $_has(1);
  @$pb.TagNumber(2)
  void clearVolume() => clearField(2);

  /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// user to map volume access to
  /// Defaults to serivceaccount user
  /// +optional
  @$pb.TagNumber(4)
  $core.String get user => $_getSZ(3);
  @$pb.TagNumber(4)
  set user($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasUser() => $_has(3);
  @$pb.TagNumber(4)
  void clearUser() => clearField(4);

  /// group to map volume access to
  /// Default is no group
  /// +optional
  @$pb.TagNumber(5)
  $core.String get group => $_getSZ(4);
  @$pb.TagNumber(5)
  set group($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasGroup() => $_has(4);
  @$pb.TagNumber(5)
  void clearGroup() => clearField(5);

  /// tenant owning the given Quobyte volume in the Backend
  /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
  /// +optional
  @$pb.TagNumber(6)
  $core.String get tenant => $_getSZ(5);
  @$pb.TagNumber(6)
  set tenant($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasTenant() => $_has(5);
  @$pb.TagNumber(6)
  void clearTenant() => clearField(6);
}

/// Represents a Rados Block Device mount that lasts the lifetime of a pod.
/// RBD volumes support ownership management and SELinux relabeling.
class RBDPersistentVolumeSource extends $pb.GeneratedMessage {
  factory RBDPersistentVolumeSource({
    $core.Iterable<$core.String>? monitors,
    $core.String? image,
    $core.String? fsType,
    $core.String? pool,
    $core.String? user,
    $core.String? keyring,
    SecretReference? secretRef,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (monitors != null) {
      $result.monitors.addAll(monitors);
    }
    if (image != null) {
      $result.image = image;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (pool != null) {
      $result.pool = pool;
    }
    if (user != null) {
      $result.user = user;
    }
    if (keyring != null) {
      $result.keyring = keyring;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  RBDPersistentVolumeSource._() : super();
  factory RBDPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory RBDPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'RBDPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'monitors')
    ..aOS(2, _omitFieldNames ? '' : 'image')
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOS(4, _omitFieldNames ? '' : 'pool')
    ..aOS(5, _omitFieldNames ? '' : 'user')
    ..aOS(6, _omitFieldNames ? '' : 'keyring')
    ..aOM<SecretReference>(7, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..aOB(8, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  RBDPersistentVolumeSource clone() => RBDPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  RBDPersistentVolumeSource copyWith(void Function(RBDPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as RBDPersistentVolumeSource)) as RBDPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static RBDPersistentVolumeSource create() => RBDPersistentVolumeSource._();
  RBDPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<RBDPersistentVolumeSource> createRepeated() => $pb.PbList<RBDPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static RBDPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<RBDPersistentVolumeSource>(create);
  static RBDPersistentVolumeSource? _defaultInstance;

  /// monitors is a collection of Ceph monitors.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get monitors => $_getList(0);

  /// image is the rados image name.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  @$pb.TagNumber(2)
  $core.String get image => $_getSZ(1);
  @$pb.TagNumber(2)
  set image($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasImage() => $_has(1);
  @$pb.TagNumber(2)
  void clearImage() => clearField(2);

  /// fsType is the filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// pool is the rados pool name.
  /// Default is rbd.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(4)
  $core.String get pool => $_getSZ(3);
  @$pb.TagNumber(4)
  set pool($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasPool() => $_has(3);
  @$pb.TagNumber(4)
  void clearPool() => clearField(4);

  /// user is the rados user name.
  /// Default is admin.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(5)
  $core.String get user => $_getSZ(4);
  @$pb.TagNumber(5)
  set user($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasUser() => $_has(4);
  @$pb.TagNumber(5)
  void clearUser() => clearField(5);

  /// keyring is the path to key ring for RBDUser.
  /// Default is /etc/ceph/keyring.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(6)
  $core.String get keyring => $_getSZ(5);
  @$pb.TagNumber(6)
  set keyring($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasKeyring() => $_has(5);
  @$pb.TagNumber(6)
  void clearKeyring() => clearField(6);

  /// secretRef is name of the authentication secret for RBDUser. If provided
  /// overrides keyring.
  /// Default is nil.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(7)
  SecretReference get secretRef => $_getN(6);
  @$pb.TagNumber(7)
  set secretRef(SecretReference v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasSecretRef() => $_has(6);
  @$pb.TagNumber(7)
  void clearSecretRef() => clearField(7);
  @$pb.TagNumber(7)
  SecretReference ensureSecretRef() => $_ensure(6);

  /// readOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(8)
  $core.bool get readOnly => $_getBF(7);
  @$pb.TagNumber(8)
  set readOnly($core.bool v) { $_setBool(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasReadOnly() => $_has(7);
  @$pb.TagNumber(8)
  void clearReadOnly() => clearField(8);
}

/// Represents a Rados Block Device mount that lasts the lifetime of a pod.
/// RBD volumes support ownership management and SELinux relabeling.
class RBDVolumeSource extends $pb.GeneratedMessage {
  factory RBDVolumeSource({
    $core.Iterable<$core.String>? monitors,
    $core.String? image,
    $core.String? fsType,
    $core.String? pool,
    $core.String? user,
    $core.String? keyring,
    LocalObjectReference? secretRef,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (monitors != null) {
      $result.monitors.addAll(monitors);
    }
    if (image != null) {
      $result.image = image;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (pool != null) {
      $result.pool = pool;
    }
    if (user != null) {
      $result.user = user;
    }
    if (keyring != null) {
      $result.keyring = keyring;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  RBDVolumeSource._() : super();
  factory RBDVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory RBDVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'RBDVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pPS(1, _omitFieldNames ? '' : 'monitors')
    ..aOS(2, _omitFieldNames ? '' : 'image')
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOS(4, _omitFieldNames ? '' : 'pool')
    ..aOS(5, _omitFieldNames ? '' : 'user')
    ..aOS(6, _omitFieldNames ? '' : 'keyring')
    ..aOM<LocalObjectReference>(7, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..aOB(8, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  RBDVolumeSource clone() => RBDVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  RBDVolumeSource copyWith(void Function(RBDVolumeSource) updates) => super.copyWith((message) => updates(message as RBDVolumeSource)) as RBDVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static RBDVolumeSource create() => RBDVolumeSource._();
  RBDVolumeSource createEmptyInstance() => create();
  static $pb.PbList<RBDVolumeSource> createRepeated() => $pb.PbList<RBDVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static RBDVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<RBDVolumeSource>(create);
  static RBDVolumeSource? _defaultInstance;

  /// monitors is a collection of Ceph monitors.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<$core.String> get monitors => $_getList(0);

  /// image is the rados image name.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  @$pb.TagNumber(2)
  $core.String get image => $_getSZ(1);
  @$pb.TagNumber(2)
  set image($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasImage() => $_has(1);
  @$pb.TagNumber(2)
  void clearImage() => clearField(2);

  /// fsType is the filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// pool is the rados pool name.
  /// Default is rbd.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(4)
  $core.String get pool => $_getSZ(3);
  @$pb.TagNumber(4)
  set pool($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasPool() => $_has(3);
  @$pb.TagNumber(4)
  void clearPool() => clearField(4);

  /// user is the rados user name.
  /// Default is admin.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(5)
  $core.String get user => $_getSZ(4);
  @$pb.TagNumber(5)
  set user($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasUser() => $_has(4);
  @$pb.TagNumber(5)
  void clearUser() => clearField(5);

  /// keyring is the path to key ring for RBDUser.
  /// Default is /etc/ceph/keyring.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(6)
  $core.String get keyring => $_getSZ(5);
  @$pb.TagNumber(6)
  set keyring($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasKeyring() => $_has(5);
  @$pb.TagNumber(6)
  void clearKeyring() => clearField(6);

  /// secretRef is name of the authentication secret for RBDUser. If provided
  /// overrides keyring.
  /// Default is nil.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(7)
  LocalObjectReference get secretRef => $_getN(6);
  @$pb.TagNumber(7)
  set secretRef(LocalObjectReference v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasSecretRef() => $_has(6);
  @$pb.TagNumber(7)
  void clearSecretRef() => clearField(7);
  @$pb.TagNumber(7)
  LocalObjectReference ensureSecretRef() => $_ensure(6);

  /// readOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  @$pb.TagNumber(8)
  $core.bool get readOnly => $_getBF(7);
  @$pb.TagNumber(8)
  set readOnly($core.bool v) { $_setBool(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasReadOnly() => $_has(7);
  @$pb.TagNumber(8)
  void clearReadOnly() => clearField(8);
}

/// RangeAllocation is not a public type.
class RangeAllocation extends $pb.GeneratedMessage {
  factory RangeAllocation({
    $0.ObjectMeta? metadata,
    $core.String? range,
    $core.List<$core.int>? data,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (range != null) {
      $result.range = range;
    }
    if (data != null) {
      $result.data = data;
    }
    return $result;
  }
  RangeAllocation._() : super();
  factory RangeAllocation.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory RangeAllocation.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'RangeAllocation', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOS(2, _omitFieldNames ? '' : 'range')
    ..a<$core.List<$core.int>>(3, _omitFieldNames ? '' : 'data', $pb.PbFieldType.OY)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  RangeAllocation clone() => RangeAllocation()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  RangeAllocation copyWith(void Function(RangeAllocation) updates) => super.copyWith((message) => updates(message as RangeAllocation)) as RangeAllocation;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static RangeAllocation create() => RangeAllocation._();
  RangeAllocation createEmptyInstance() => create();
  static $pb.PbList<RangeAllocation> createRepeated() => $pb.PbList<RangeAllocation>();
  @$core.pragma('dart2js:noInline')
  static RangeAllocation getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<RangeAllocation>(create);
  static RangeAllocation? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Range is string that identifies the range represented by 'data'.
  @$pb.TagNumber(2)
  $core.String get range => $_getSZ(1);
  @$pb.TagNumber(2)
  set range($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasRange() => $_has(1);
  @$pb.TagNumber(2)
  void clearRange() => clearField(2);

  /// Data is a bit array containing all allocated addresses in the previous segment.
  @$pb.TagNumber(3)
  $core.List<$core.int> get data => $_getN(2);
  @$pb.TagNumber(3)
  set data($core.List<$core.int> v) { $_setBytes(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasData() => $_has(2);
  @$pb.TagNumber(3)
  void clearData() => clearField(3);
}

/// ReplicationController represents the configuration of a replication controller.
class ReplicationController extends $pb.GeneratedMessage {
  factory ReplicationController({
    $0.ObjectMeta? metadata,
    ReplicationControllerSpec? spec,
    ReplicationControllerStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  ReplicationController._() : super();
  factory ReplicationController.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ReplicationController.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ReplicationController', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<ReplicationControllerSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: ReplicationControllerSpec.create)
    ..aOM<ReplicationControllerStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: ReplicationControllerStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ReplicationController clone() => ReplicationController()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ReplicationController copyWith(void Function(ReplicationController) updates) => super.copyWith((message) => updates(message as ReplicationController)) as ReplicationController;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ReplicationController create() => ReplicationController._();
  ReplicationController createEmptyInstance() => create();
  static $pb.PbList<ReplicationController> createRepeated() => $pb.PbList<ReplicationController>();
  @$core.pragma('dart2js:noInline')
  static ReplicationController getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ReplicationController>(create);
  static ReplicationController? _defaultInstance;

  /// If the Labels of a ReplicationController are empty, they are defaulted to
  /// be the same as the Pod(s) that the replication controller manages.
  /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the specification of the desired behavior of the replication controller.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  ReplicationControllerSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(ReplicationControllerSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  ReplicationControllerSpec ensureSpec() => $_ensure(1);

  /// Status is the most recently observed status of the replication controller.
  /// This data may be out of date by some window of time.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  ReplicationControllerStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(ReplicationControllerStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  ReplicationControllerStatus ensureStatus() => $_ensure(2);
}

/// ReplicationControllerCondition describes the state of a replication controller at a certain point.
class ReplicationControllerCondition extends $pb.GeneratedMessage {
  factory ReplicationControllerCondition({
    $core.String? type,
    $core.String? status,
    $0.Time? lastTransitionTime,
    $core.String? reason,
    $core.String? message,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (status != null) {
      $result.status = status;
    }
    if (lastTransitionTime != null) {
      $result.lastTransitionTime = lastTransitionTime;
    }
    if (reason != null) {
      $result.reason = reason;
    }
    if (message != null) {
      $result.message = message;
    }
    return $result;
  }
  ReplicationControllerCondition._() : super();
  factory ReplicationControllerCondition.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ReplicationControllerCondition.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ReplicationControllerCondition', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'status')
    ..aOM<$0.Time>(3, _omitFieldNames ? '' : 'lastTransitionTime', protoName: 'lastTransitionTime', subBuilder: $0.Time.create)
    ..aOS(4, _omitFieldNames ? '' : 'reason')
    ..aOS(5, _omitFieldNames ? '' : 'message')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ReplicationControllerCondition clone() => ReplicationControllerCondition()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ReplicationControllerCondition copyWith(void Function(ReplicationControllerCondition) updates) => super.copyWith((message) => updates(message as ReplicationControllerCondition)) as ReplicationControllerCondition;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ReplicationControllerCondition create() => ReplicationControllerCondition._();
  ReplicationControllerCondition createEmptyInstance() => create();
  static $pb.PbList<ReplicationControllerCondition> createRepeated() => $pb.PbList<ReplicationControllerCondition>();
  @$core.pragma('dart2js:noInline')
  static ReplicationControllerCondition getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ReplicationControllerCondition>(create);
  static ReplicationControllerCondition? _defaultInstance;

  /// Type of replication controller condition.
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Status of the condition, one of True, False, Unknown.
  @$pb.TagNumber(2)
  $core.String get status => $_getSZ(1);
  @$pb.TagNumber(2)
  set status($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasStatus() => $_has(1);
  @$pb.TagNumber(2)
  void clearStatus() => clearField(2);

  /// The last time the condition transitioned from one status to another.
  /// +optional
  @$pb.TagNumber(3)
  $0.Time get lastTransitionTime => $_getN(2);
  @$pb.TagNumber(3)
  set lastTransitionTime($0.Time v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasLastTransitionTime() => $_has(2);
  @$pb.TagNumber(3)
  void clearLastTransitionTime() => clearField(3);
  @$pb.TagNumber(3)
  $0.Time ensureLastTransitionTime() => $_ensure(2);

  /// The reason for the condition's last transition.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get reason => $_getSZ(3);
  @$pb.TagNumber(4)
  set reason($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReason() => $_has(3);
  @$pb.TagNumber(4)
  void clearReason() => clearField(4);

  /// A human readable message indicating details about the transition.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get message => $_getSZ(4);
  @$pb.TagNumber(5)
  set message($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasMessage() => $_has(4);
  @$pb.TagNumber(5)
  void clearMessage() => clearField(5);
}

/// ReplicationControllerList is a collection of replication controllers.
class ReplicationControllerList extends $pb.GeneratedMessage {
  factory ReplicationControllerList({
    $0.ListMeta? metadata,
    $core.Iterable<ReplicationController>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ReplicationControllerList._() : super();
  factory ReplicationControllerList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ReplicationControllerList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ReplicationControllerList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<ReplicationController>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: ReplicationController.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ReplicationControllerList clone() => ReplicationControllerList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ReplicationControllerList copyWith(void Function(ReplicationControllerList) updates) => super.copyWith((message) => updates(message as ReplicationControllerList)) as ReplicationControllerList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ReplicationControllerList create() => ReplicationControllerList._();
  ReplicationControllerList createEmptyInstance() => create();
  static $pb.PbList<ReplicationControllerList> createRepeated() => $pb.PbList<ReplicationControllerList>();
  @$core.pragma('dart2js:noInline')
  static ReplicationControllerList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ReplicationControllerList>(create);
  static ReplicationControllerList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of replication controllers.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
  @$pb.TagNumber(2)
  $core.List<ReplicationController> get items => $_getList(1);
}

/// ReplicationControllerSpec is the specification of a replication controller.
class ReplicationControllerSpec extends $pb.GeneratedMessage {
  factory ReplicationControllerSpec({
    $core.int? replicas,
    $core.Map<$core.String, $core.String>? selector,
    PodTemplateSpec? template,
    $core.int? minReadySeconds,
  }) {
    final $result = create();
    if (replicas != null) {
      $result.replicas = replicas;
    }
    if (selector != null) {
      $result.selector.addAll(selector);
    }
    if (template != null) {
      $result.template = template;
    }
    if (minReadySeconds != null) {
      $result.minReadySeconds = minReadySeconds;
    }
    return $result;
  }
  ReplicationControllerSpec._() : super();
  factory ReplicationControllerSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ReplicationControllerSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ReplicationControllerSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'replicas', $pb.PbFieldType.O3)
    ..m<$core.String, $core.String>(2, _omitFieldNames ? '' : 'selector', entryClassName: 'ReplicationControllerSpec.SelectorEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOM<PodTemplateSpec>(3, _omitFieldNames ? '' : 'template', subBuilder: PodTemplateSpec.create)
    ..a<$core.int>(4, _omitFieldNames ? '' : 'minReadySeconds', $pb.PbFieldType.O3, protoName: 'minReadySeconds')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ReplicationControllerSpec clone() => ReplicationControllerSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ReplicationControllerSpec copyWith(void Function(ReplicationControllerSpec) updates) => super.copyWith((message) => updates(message as ReplicationControllerSpec)) as ReplicationControllerSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ReplicationControllerSpec create() => ReplicationControllerSpec._();
  ReplicationControllerSpec createEmptyInstance() => create();
  static $pb.PbList<ReplicationControllerSpec> createRepeated() => $pb.PbList<ReplicationControllerSpec>();
  @$core.pragma('dart2js:noInline')
  static ReplicationControllerSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ReplicationControllerSpec>(create);
  static ReplicationControllerSpec? _defaultInstance;

  /// Replicas is the number of desired replicas.
  /// This is a pointer to distinguish between explicit zero and unspecified.
  /// Defaults to 1.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  /// +optional
  @$pb.TagNumber(1)
  $core.int get replicas => $_getIZ(0);
  @$pb.TagNumber(1)
  set replicas($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasReplicas() => $_has(0);
  @$pb.TagNumber(1)
  void clearReplicas() => clearField(1);

  /// Selector is a label query over pods that should match the Replicas count.
  /// If Selector is empty, it is defaulted to the labels present on the Pod template.
  /// Label keys and values that must match in order to be controlled by this replication
  /// controller, if empty defaulted to labels on Pod template.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  /// +mapType=atomic
  @$pb.TagNumber(2)
  $core.Map<$core.String, $core.String> get selector => $_getMap(1);

  /// Template is the object that describes the pod that will be created if
  /// insufficient replicas are detected. This takes precedence over a TemplateRef.
  /// The only allowed template.spec.restartPolicy value is "Always".
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  /// +optional
  @$pb.TagNumber(3)
  PodTemplateSpec get template => $_getN(2);
  @$pb.TagNumber(3)
  set template(PodTemplateSpec v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasTemplate() => $_has(2);
  @$pb.TagNumber(3)
  void clearTemplate() => clearField(3);
  @$pb.TagNumber(3)
  PodTemplateSpec ensureTemplate() => $_ensure(2);

  /// Minimum number of seconds for which a newly created pod should be ready
  /// without any of its container crashing, for it to be considered available.
  /// Defaults to 0 (pod will be considered available as soon as it is ready)
  /// +optional
  @$pb.TagNumber(4)
  $core.int get minReadySeconds => $_getIZ(3);
  @$pb.TagNumber(4)
  set minReadySeconds($core.int v) { $_setSignedInt32(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasMinReadySeconds() => $_has(3);
  @$pb.TagNumber(4)
  void clearMinReadySeconds() => clearField(4);
}

/// ReplicationControllerStatus represents the current status of a replication
/// controller.
class ReplicationControllerStatus extends $pb.GeneratedMessage {
  factory ReplicationControllerStatus({
    $core.int? replicas,
    $core.int? fullyLabeledReplicas,
    $fixnum.Int64? observedGeneration,
    $core.int? readyReplicas,
    $core.int? availableReplicas,
    $core.Iterable<ReplicationControllerCondition>? conditions,
  }) {
    final $result = create();
    if (replicas != null) {
      $result.replicas = replicas;
    }
    if (fullyLabeledReplicas != null) {
      $result.fullyLabeledReplicas = fullyLabeledReplicas;
    }
    if (observedGeneration != null) {
      $result.observedGeneration = observedGeneration;
    }
    if (readyReplicas != null) {
      $result.readyReplicas = readyReplicas;
    }
    if (availableReplicas != null) {
      $result.availableReplicas = availableReplicas;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    return $result;
  }
  ReplicationControllerStatus._() : super();
  factory ReplicationControllerStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ReplicationControllerStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ReplicationControllerStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'replicas', $pb.PbFieldType.O3)
    ..a<$core.int>(2, _omitFieldNames ? '' : 'fullyLabeledReplicas', $pb.PbFieldType.O3, protoName: 'fullyLabeledReplicas')
    ..aInt64(3, _omitFieldNames ? '' : 'observedGeneration', protoName: 'observedGeneration')
    ..a<$core.int>(4, _omitFieldNames ? '' : 'readyReplicas', $pb.PbFieldType.O3, protoName: 'readyReplicas')
    ..a<$core.int>(5, _omitFieldNames ? '' : 'availableReplicas', $pb.PbFieldType.O3, protoName: 'availableReplicas')
    ..pc<ReplicationControllerCondition>(6, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: ReplicationControllerCondition.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ReplicationControllerStatus clone() => ReplicationControllerStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ReplicationControllerStatus copyWith(void Function(ReplicationControllerStatus) updates) => super.copyWith((message) => updates(message as ReplicationControllerStatus)) as ReplicationControllerStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ReplicationControllerStatus create() => ReplicationControllerStatus._();
  ReplicationControllerStatus createEmptyInstance() => create();
  static $pb.PbList<ReplicationControllerStatus> createRepeated() => $pb.PbList<ReplicationControllerStatus>();
  @$core.pragma('dart2js:noInline')
  static ReplicationControllerStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ReplicationControllerStatus>(create);
  static ReplicationControllerStatus? _defaultInstance;

  /// Replicas is the most recently observed number of replicas.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  @$pb.TagNumber(1)
  $core.int get replicas => $_getIZ(0);
  @$pb.TagNumber(1)
  set replicas($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasReplicas() => $_has(0);
  @$pb.TagNumber(1)
  void clearReplicas() => clearField(1);

  /// The number of pods that have labels matching the labels of the pod template of the replication controller.
  /// +optional
  @$pb.TagNumber(2)
  $core.int get fullyLabeledReplicas => $_getIZ(1);
  @$pb.TagNumber(2)
  set fullyLabeledReplicas($core.int v) { $_setSignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFullyLabeledReplicas() => $_has(1);
  @$pb.TagNumber(2)
  void clearFullyLabeledReplicas() => clearField(2);

  /// ObservedGeneration reflects the generation of the most recently observed replication controller.
  /// +optional
  @$pb.TagNumber(3)
  $fixnum.Int64 get observedGeneration => $_getI64(2);
  @$pb.TagNumber(3)
  set observedGeneration($fixnum.Int64 v) { $_setInt64(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasObservedGeneration() => $_has(2);
  @$pb.TagNumber(3)
  void clearObservedGeneration() => clearField(3);

  /// The number of ready replicas for this replication controller.
  /// +optional
  @$pb.TagNumber(4)
  $core.int get readyReplicas => $_getIZ(3);
  @$pb.TagNumber(4)
  set readyReplicas($core.int v) { $_setSignedInt32(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadyReplicas() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadyReplicas() => clearField(4);

  /// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
  /// +optional
  @$pb.TagNumber(5)
  $core.int get availableReplicas => $_getIZ(4);
  @$pb.TagNumber(5)
  set availableReplicas($core.int v) { $_setSignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasAvailableReplicas() => $_has(4);
  @$pb.TagNumber(5)
  void clearAvailableReplicas() => clearField(5);

  /// Represents the latest available observations of a replication controller's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(6)
  $core.List<ReplicationControllerCondition> get conditions => $_getList(5);
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
class ResourceClaim extends $pb.GeneratedMessage {
  factory ResourceClaim({
    $core.String? name,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    return $result;
  }
  ResourceClaim._() : super();
  factory ResourceClaim.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceClaim.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceClaim', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceClaim clone() => ResourceClaim()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceClaim copyWith(void Function(ResourceClaim) updates) => super.copyWith((message) => updates(message as ResourceClaim)) as ResourceClaim;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceClaim create() => ResourceClaim._();
  ResourceClaim createEmptyInstance() => create();
  static $pb.PbList<ResourceClaim> createRepeated() => $pb.PbList<ResourceClaim>();
  @$core.pragma('dart2js:noInline')
  static ResourceClaim getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceClaim>(create);
  static ResourceClaim? _defaultInstance;

  /// Name must match the name of one entry in pod.spec.resourceClaims of
  /// the Pod where this field is used. It makes that resource available
  /// inside a container.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);
}

/// ResourceFieldSelector represents container resources (cpu, memory) and their output format
/// +structType=atomic
class ResourceFieldSelector extends $pb.GeneratedMessage {
  factory ResourceFieldSelector({
    $core.String? containerName,
    $core.String? resource,
    $1.Quantity? divisor,
  }) {
    final $result = create();
    if (containerName != null) {
      $result.containerName = containerName;
    }
    if (resource != null) {
      $result.resource = resource;
    }
    if (divisor != null) {
      $result.divisor = divisor;
    }
    return $result;
  }
  ResourceFieldSelector._() : super();
  factory ResourceFieldSelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceFieldSelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceFieldSelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'containerName', protoName: 'containerName')
    ..aOS(2, _omitFieldNames ? '' : 'resource')
    ..aOM<$1.Quantity>(3, _omitFieldNames ? '' : 'divisor', subBuilder: $1.Quantity.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceFieldSelector clone() => ResourceFieldSelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceFieldSelector copyWith(void Function(ResourceFieldSelector) updates) => super.copyWith((message) => updates(message as ResourceFieldSelector)) as ResourceFieldSelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceFieldSelector create() => ResourceFieldSelector._();
  ResourceFieldSelector createEmptyInstance() => create();
  static $pb.PbList<ResourceFieldSelector> createRepeated() => $pb.PbList<ResourceFieldSelector>();
  @$core.pragma('dart2js:noInline')
  static ResourceFieldSelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceFieldSelector>(create);
  static ResourceFieldSelector? _defaultInstance;

  /// Container name: required for volumes, optional for env vars
  /// +optional
  @$pb.TagNumber(1)
  $core.String get containerName => $_getSZ(0);
  @$pb.TagNumber(1)
  set containerName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasContainerName() => $_has(0);
  @$pb.TagNumber(1)
  void clearContainerName() => clearField(1);

  /// Required: resource to select
  @$pb.TagNumber(2)
  $core.String get resource => $_getSZ(1);
  @$pb.TagNumber(2)
  set resource($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasResource() => $_has(1);
  @$pb.TagNumber(2)
  void clearResource() => clearField(2);

  /// Specifies the output format of the exposed resources, defaults to "1"
  /// +optional
  @$pb.TagNumber(3)
  $1.Quantity get divisor => $_getN(2);
  @$pb.TagNumber(3)
  set divisor($1.Quantity v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasDivisor() => $_has(2);
  @$pb.TagNumber(3)
  void clearDivisor() => clearField(3);
  @$pb.TagNumber(3)
  $1.Quantity ensureDivisor() => $_ensure(2);
}

/// ResourceQuota sets aggregate quota restrictions enforced per namespace
class ResourceQuota extends $pb.GeneratedMessage {
  factory ResourceQuota({
    $0.ObjectMeta? metadata,
    ResourceQuotaSpec? spec,
    ResourceQuotaStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  ResourceQuota._() : super();
  factory ResourceQuota.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceQuota.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceQuota', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<ResourceQuotaSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: ResourceQuotaSpec.create)
    ..aOM<ResourceQuotaStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: ResourceQuotaStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceQuota clone() => ResourceQuota()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceQuota copyWith(void Function(ResourceQuota) updates) => super.copyWith((message) => updates(message as ResourceQuota)) as ResourceQuota;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceQuota create() => ResourceQuota._();
  ResourceQuota createEmptyInstance() => create();
  static $pb.PbList<ResourceQuota> createRepeated() => $pb.PbList<ResourceQuota>();
  @$core.pragma('dart2js:noInline')
  static ResourceQuota getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceQuota>(create);
  static ResourceQuota? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the desired quota.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  ResourceQuotaSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(ResourceQuotaSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  ResourceQuotaSpec ensureSpec() => $_ensure(1);

  /// Status defines the actual enforced quota and its current usage.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  ResourceQuotaStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(ResourceQuotaStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  ResourceQuotaStatus ensureStatus() => $_ensure(2);
}

/// ResourceQuotaList is a list of ResourceQuota items.
class ResourceQuotaList extends $pb.GeneratedMessage {
  factory ResourceQuotaList({
    $0.ListMeta? metadata,
    $core.Iterable<ResourceQuota>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ResourceQuotaList._() : super();
  factory ResourceQuotaList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceQuotaList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceQuotaList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<ResourceQuota>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: ResourceQuota.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceQuotaList clone() => ResourceQuotaList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceQuotaList copyWith(void Function(ResourceQuotaList) updates) => super.copyWith((message) => updates(message as ResourceQuotaList)) as ResourceQuotaList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceQuotaList create() => ResourceQuotaList._();
  ResourceQuotaList createEmptyInstance() => create();
  static $pb.PbList<ResourceQuotaList> createRepeated() => $pb.PbList<ResourceQuotaList>();
  @$core.pragma('dart2js:noInline')
  static ResourceQuotaList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceQuotaList>(create);
  static ResourceQuotaList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// Items is a list of ResourceQuota objects.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  @$pb.TagNumber(2)
  $core.List<ResourceQuota> get items => $_getList(1);
}

/// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
class ResourceQuotaSpec extends $pb.GeneratedMessage {
  factory ResourceQuotaSpec({
    $core.Map<$core.String, $1.Quantity>? hard,
    $core.Iterable<$core.String>? scopes,
    ScopeSelector? scopeSelector,
  }) {
    final $result = create();
    if (hard != null) {
      $result.hard.addAll(hard);
    }
    if (scopes != null) {
      $result.scopes.addAll(scopes);
    }
    if (scopeSelector != null) {
      $result.scopeSelector = scopeSelector;
    }
    return $result;
  }
  ResourceQuotaSpec._() : super();
  factory ResourceQuotaSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceQuotaSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceQuotaSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'hard', entryClassName: 'ResourceQuotaSpec.HardEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..pPS(2, _omitFieldNames ? '' : 'scopes')
    ..aOM<ScopeSelector>(3, _omitFieldNames ? '' : 'scopeSelector', protoName: 'scopeSelector', subBuilder: ScopeSelector.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceQuotaSpec clone() => ResourceQuotaSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceQuotaSpec copyWith(void Function(ResourceQuotaSpec) updates) => super.copyWith((message) => updates(message as ResourceQuotaSpec)) as ResourceQuotaSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceQuotaSpec create() => ResourceQuotaSpec._();
  ResourceQuotaSpec createEmptyInstance() => create();
  static $pb.PbList<ResourceQuotaSpec> createRepeated() => $pb.PbList<ResourceQuotaSpec>();
  @$core.pragma('dart2js:noInline')
  static ResourceQuotaSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceQuotaSpec>(create);
  static ResourceQuotaSpec? _defaultInstance;

  /// hard is the set of desired hard limits for each named resource.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get hard => $_getMap(0);

  /// A collection of filters that must match each object tracked by a quota.
  /// If not specified, the quota matches all objects.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get scopes => $_getList(1);

  /// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
  /// but expressed using ScopeSelectorOperator in combination with possible values.
  /// For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
  /// +optional
  @$pb.TagNumber(3)
  ScopeSelector get scopeSelector => $_getN(2);
  @$pb.TagNumber(3)
  set scopeSelector(ScopeSelector v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasScopeSelector() => $_has(2);
  @$pb.TagNumber(3)
  void clearScopeSelector() => clearField(3);
  @$pb.TagNumber(3)
  ScopeSelector ensureScopeSelector() => $_ensure(2);
}

/// ResourceQuotaStatus defines the enforced hard limits and observed use.
class ResourceQuotaStatus extends $pb.GeneratedMessage {
  factory ResourceQuotaStatus({
    $core.Map<$core.String, $1.Quantity>? hard,
    $core.Map<$core.String, $1.Quantity>? used,
  }) {
    final $result = create();
    if (hard != null) {
      $result.hard.addAll(hard);
    }
    if (used != null) {
      $result.used.addAll(used);
    }
    return $result;
  }
  ResourceQuotaStatus._() : super();
  factory ResourceQuotaStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceQuotaStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceQuotaStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'hard', entryClassName: 'ResourceQuotaStatus.HardEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(2, _omitFieldNames ? '' : 'used', entryClassName: 'ResourceQuotaStatus.UsedEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceQuotaStatus clone() => ResourceQuotaStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceQuotaStatus copyWith(void Function(ResourceQuotaStatus) updates) => super.copyWith((message) => updates(message as ResourceQuotaStatus)) as ResourceQuotaStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceQuotaStatus create() => ResourceQuotaStatus._();
  ResourceQuotaStatus createEmptyInstance() => create();
  static $pb.PbList<ResourceQuotaStatus> createRepeated() => $pb.PbList<ResourceQuotaStatus>();
  @$core.pragma('dart2js:noInline')
  static ResourceQuotaStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceQuotaStatus>(create);
  static ResourceQuotaStatus? _defaultInstance;

  /// Hard is the set of enforced hard limits for each named resource.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get hard => $_getMap(0);

  /// Used is the current observed total usage of the resource in the namespace.
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $1.Quantity> get used => $_getMap(1);
}

/// ResourceRequirements describes the compute resource requirements.
class ResourceRequirements extends $pb.GeneratedMessage {
  factory ResourceRequirements({
    $core.Map<$core.String, $1.Quantity>? limits,
    $core.Map<$core.String, $1.Quantity>? requests,
    $core.Iterable<ResourceClaim>? claims,
  }) {
    final $result = create();
    if (limits != null) {
      $result.limits.addAll(limits);
    }
    if (requests != null) {
      $result.requests.addAll(requests);
    }
    if (claims != null) {
      $result.claims.addAll(claims);
    }
    return $result;
  }
  ResourceRequirements._() : super();
  factory ResourceRequirements.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ResourceRequirements.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ResourceRequirements', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'limits', entryClassName: 'ResourceRequirements.LimitsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(2, _omitFieldNames ? '' : 'requests', entryClassName: 'ResourceRequirements.RequestsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..pc<ResourceClaim>(3, _omitFieldNames ? '' : 'claims', $pb.PbFieldType.PM, subBuilder: ResourceClaim.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ResourceRequirements clone() => ResourceRequirements()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ResourceRequirements copyWith(void Function(ResourceRequirements) updates) => super.copyWith((message) => updates(message as ResourceRequirements)) as ResourceRequirements;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ResourceRequirements create() => ResourceRequirements._();
  ResourceRequirements createEmptyInstance() => create();
  static $pb.PbList<ResourceRequirements> createRepeated() => $pb.PbList<ResourceRequirements>();
  @$core.pragma('dart2js:noInline')
  static ResourceRequirements getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ResourceRequirements>(create);
  static ResourceRequirements? _defaultInstance;

  /// Limits describes the maximum amount of compute resources allowed.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get limits => $_getMap(0);

  /// Requests describes the minimum amount of compute resources required.
  /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $1.Quantity> get requests => $_getMap(1);

  ///  Claims lists the names of resources, defined in spec.resourceClaims,
  ///  that are used by this container.
  ///
  ///  This is an alpha field and requires enabling the
  ///  DynamicResourceAllocation feature gate.
  ///
  ///  This field is immutable. It can only be set for containers.
  ///
  ///  +listType=map
  ///  +listMapKey=name
  ///  +featureGate=DynamicResourceAllocation
  ///  +optional
  @$pb.TagNumber(3)
  $core.List<ResourceClaim> get claims => $_getList(2);
}

/// SELinuxOptions are the labels to be applied to the container
class SELinuxOptions extends $pb.GeneratedMessage {
  factory SELinuxOptions({
    $core.String? user,
    $core.String? role,
    $core.String? type,
    $core.String? level,
  }) {
    final $result = create();
    if (user != null) {
      $result.user = user;
    }
    if (role != null) {
      $result.role = role;
    }
    if (type != null) {
      $result.type = type;
    }
    if (level != null) {
      $result.level = level;
    }
    return $result;
  }
  SELinuxOptions._() : super();
  factory SELinuxOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SELinuxOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SELinuxOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'user')
    ..aOS(2, _omitFieldNames ? '' : 'role')
    ..aOS(3, _omitFieldNames ? '' : 'type')
    ..aOS(4, _omitFieldNames ? '' : 'level')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SELinuxOptions clone() => SELinuxOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SELinuxOptions copyWith(void Function(SELinuxOptions) updates) => super.copyWith((message) => updates(message as SELinuxOptions)) as SELinuxOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SELinuxOptions create() => SELinuxOptions._();
  SELinuxOptions createEmptyInstance() => create();
  static $pb.PbList<SELinuxOptions> createRepeated() => $pb.PbList<SELinuxOptions>();
  @$core.pragma('dart2js:noInline')
  static SELinuxOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SELinuxOptions>(create);
  static SELinuxOptions? _defaultInstance;

  /// User is a SELinux user label that applies to the container.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get user => $_getSZ(0);
  @$pb.TagNumber(1)
  set user($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasUser() => $_has(0);
  @$pb.TagNumber(1)
  void clearUser() => clearField(1);

  /// Role is a SELinux role label that applies to the container.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get role => $_getSZ(1);
  @$pb.TagNumber(2)
  set role($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasRole() => $_has(1);
  @$pb.TagNumber(2)
  void clearRole() => clearField(2);

  /// Type is a SELinux type label that applies to the container.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get type => $_getSZ(2);
  @$pb.TagNumber(3)
  set type($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasType() => $_has(2);
  @$pb.TagNumber(3)
  void clearType() => clearField(3);

  /// Level is SELinux level label that applies to the container.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get level => $_getSZ(3);
  @$pb.TagNumber(4)
  set level($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasLevel() => $_has(3);
  @$pb.TagNumber(4)
  void clearLevel() => clearField(4);
}

/// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
class ScaleIOPersistentVolumeSource extends $pb.GeneratedMessage {
  factory ScaleIOPersistentVolumeSource({
    $core.String? gateway,
    $core.String? system,
    SecretReference? secretRef,
    $core.bool? sslEnabled,
    $core.String? protectionDomain,
    $core.String? storagePool,
    $core.String? storageMode,
    $core.String? volumeName,
    $core.String? fsType,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (gateway != null) {
      $result.gateway = gateway;
    }
    if (system != null) {
      $result.system = system;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (sslEnabled != null) {
      $result.sslEnabled = sslEnabled;
    }
    if (protectionDomain != null) {
      $result.protectionDomain = protectionDomain;
    }
    if (storagePool != null) {
      $result.storagePool = storagePool;
    }
    if (storageMode != null) {
      $result.storageMode = storageMode;
    }
    if (volumeName != null) {
      $result.volumeName = volumeName;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  ScaleIOPersistentVolumeSource._() : super();
  factory ScaleIOPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ScaleIOPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ScaleIOPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'gateway')
    ..aOS(2, _omitFieldNames ? '' : 'system')
    ..aOM<SecretReference>(3, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: SecretReference.create)
    ..aOB(4, _omitFieldNames ? '' : 'sslEnabled', protoName: 'sslEnabled')
    ..aOS(5, _omitFieldNames ? '' : 'protectionDomain', protoName: 'protectionDomain')
    ..aOS(6, _omitFieldNames ? '' : 'storagePool', protoName: 'storagePool')
    ..aOS(7, _omitFieldNames ? '' : 'storageMode', protoName: 'storageMode')
    ..aOS(8, _omitFieldNames ? '' : 'volumeName', protoName: 'volumeName')
    ..aOS(9, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(10, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ScaleIOPersistentVolumeSource clone() => ScaleIOPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ScaleIOPersistentVolumeSource copyWith(void Function(ScaleIOPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as ScaleIOPersistentVolumeSource)) as ScaleIOPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ScaleIOPersistentVolumeSource create() => ScaleIOPersistentVolumeSource._();
  ScaleIOPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ScaleIOPersistentVolumeSource> createRepeated() => $pb.PbList<ScaleIOPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ScaleIOPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ScaleIOPersistentVolumeSource>(create);
  static ScaleIOPersistentVolumeSource? _defaultInstance;

  /// gateway is the host address of the ScaleIO API Gateway.
  @$pb.TagNumber(1)
  $core.String get gateway => $_getSZ(0);
  @$pb.TagNumber(1)
  set gateway($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasGateway() => $_has(0);
  @$pb.TagNumber(1)
  void clearGateway() => clearField(1);

  /// system is the name of the storage system as configured in ScaleIO.
  @$pb.TagNumber(2)
  $core.String get system => $_getSZ(1);
  @$pb.TagNumber(2)
  set system($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSystem() => $_has(1);
  @$pb.TagNumber(2)
  void clearSystem() => clearField(2);

  /// secretRef references to the secret for ScaleIO user and other
  /// sensitive information. If this is not provided, Login operation will fail.
  @$pb.TagNumber(3)
  SecretReference get secretRef => $_getN(2);
  @$pb.TagNumber(3)
  set secretRef(SecretReference v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSecretRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearSecretRef() => clearField(3);
  @$pb.TagNumber(3)
  SecretReference ensureSecretRef() => $_ensure(2);

  /// sslEnabled is the flag to enable/disable SSL communication with Gateway, default false
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get sslEnabled => $_getBF(3);
  @$pb.TagNumber(4)
  set sslEnabled($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSslEnabled() => $_has(3);
  @$pb.TagNumber(4)
  void clearSslEnabled() => clearField(4);

  /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get protectionDomain => $_getSZ(4);
  @$pb.TagNumber(5)
  set protectionDomain($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasProtectionDomain() => $_has(4);
  @$pb.TagNumber(5)
  void clearProtectionDomain() => clearField(5);

  /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get storagePool => $_getSZ(5);
  @$pb.TagNumber(6)
  set storagePool($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasStoragePool() => $_has(5);
  @$pb.TagNumber(6)
  void clearStoragePool() => clearField(6);

  /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  /// Default is ThinProvisioned.
  /// +optional
  @$pb.TagNumber(7)
  $core.String get storageMode => $_getSZ(6);
  @$pb.TagNumber(7)
  set storageMode($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasStorageMode() => $_has(6);
  @$pb.TagNumber(7)
  void clearStorageMode() => clearField(7);

  /// volumeName is the name of a volume already created in the ScaleIO system
  /// that is associated with this volume source.
  @$pb.TagNumber(8)
  $core.String get volumeName => $_getSZ(7);
  @$pb.TagNumber(8)
  set volumeName($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasVolumeName() => $_has(7);
  @$pb.TagNumber(8)
  void clearVolumeName() => clearField(8);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// Default is "xfs"
  /// +optional
  @$pb.TagNumber(9)
  $core.String get fsType => $_getSZ(8);
  @$pb.TagNumber(9)
  set fsType($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasFsType() => $_has(8);
  @$pb.TagNumber(9)
  void clearFsType() => clearField(9);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(10)
  $core.bool get readOnly => $_getBF(9);
  @$pb.TagNumber(10)
  set readOnly($core.bool v) { $_setBool(9, v); }
  @$pb.TagNumber(10)
  $core.bool hasReadOnly() => $_has(9);
  @$pb.TagNumber(10)
  void clearReadOnly() => clearField(10);
}

/// ScaleIOVolumeSource represents a persistent ScaleIO volume
class ScaleIOVolumeSource extends $pb.GeneratedMessage {
  factory ScaleIOVolumeSource({
    $core.String? gateway,
    $core.String? system,
    LocalObjectReference? secretRef,
    $core.bool? sslEnabled,
    $core.String? protectionDomain,
    $core.String? storagePool,
    $core.String? storageMode,
    $core.String? volumeName,
    $core.String? fsType,
    $core.bool? readOnly,
  }) {
    final $result = create();
    if (gateway != null) {
      $result.gateway = gateway;
    }
    if (system != null) {
      $result.system = system;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    if (sslEnabled != null) {
      $result.sslEnabled = sslEnabled;
    }
    if (protectionDomain != null) {
      $result.protectionDomain = protectionDomain;
    }
    if (storagePool != null) {
      $result.storagePool = storagePool;
    }
    if (storageMode != null) {
      $result.storageMode = storageMode;
    }
    if (volumeName != null) {
      $result.volumeName = volumeName;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    return $result;
  }
  ScaleIOVolumeSource._() : super();
  factory ScaleIOVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ScaleIOVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ScaleIOVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'gateway')
    ..aOS(2, _omitFieldNames ? '' : 'system')
    ..aOM<LocalObjectReference>(3, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..aOB(4, _omitFieldNames ? '' : 'sslEnabled', protoName: 'sslEnabled')
    ..aOS(5, _omitFieldNames ? '' : 'protectionDomain', protoName: 'protectionDomain')
    ..aOS(6, _omitFieldNames ? '' : 'storagePool', protoName: 'storagePool')
    ..aOS(7, _omitFieldNames ? '' : 'storageMode', protoName: 'storageMode')
    ..aOS(8, _omitFieldNames ? '' : 'volumeName', protoName: 'volumeName')
    ..aOS(9, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(10, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ScaleIOVolumeSource clone() => ScaleIOVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ScaleIOVolumeSource copyWith(void Function(ScaleIOVolumeSource) updates) => super.copyWith((message) => updates(message as ScaleIOVolumeSource)) as ScaleIOVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ScaleIOVolumeSource create() => ScaleIOVolumeSource._();
  ScaleIOVolumeSource createEmptyInstance() => create();
  static $pb.PbList<ScaleIOVolumeSource> createRepeated() => $pb.PbList<ScaleIOVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static ScaleIOVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ScaleIOVolumeSource>(create);
  static ScaleIOVolumeSource? _defaultInstance;

  /// gateway is the host address of the ScaleIO API Gateway.
  @$pb.TagNumber(1)
  $core.String get gateway => $_getSZ(0);
  @$pb.TagNumber(1)
  set gateway($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasGateway() => $_has(0);
  @$pb.TagNumber(1)
  void clearGateway() => clearField(1);

  /// system is the name of the storage system as configured in ScaleIO.
  @$pb.TagNumber(2)
  $core.String get system => $_getSZ(1);
  @$pb.TagNumber(2)
  set system($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasSystem() => $_has(1);
  @$pb.TagNumber(2)
  void clearSystem() => clearField(2);

  /// secretRef references to the secret for ScaleIO user and other
  /// sensitive information. If this is not provided, Login operation will fail.
  @$pb.TagNumber(3)
  LocalObjectReference get secretRef => $_getN(2);
  @$pb.TagNumber(3)
  set secretRef(LocalObjectReference v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSecretRef() => $_has(2);
  @$pb.TagNumber(3)
  void clearSecretRef() => clearField(3);
  @$pb.TagNumber(3)
  LocalObjectReference ensureSecretRef() => $_ensure(2);

  /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get sslEnabled => $_getBF(3);
  @$pb.TagNumber(4)
  set sslEnabled($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSslEnabled() => $_has(3);
  @$pb.TagNumber(4)
  void clearSslEnabled() => clearField(4);

  /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
  /// +optional
  @$pb.TagNumber(5)
  $core.String get protectionDomain => $_getSZ(4);
  @$pb.TagNumber(5)
  set protectionDomain($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasProtectionDomain() => $_has(4);
  @$pb.TagNumber(5)
  void clearProtectionDomain() => clearField(5);

  /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get storagePool => $_getSZ(5);
  @$pb.TagNumber(6)
  set storagePool($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasStoragePool() => $_has(5);
  @$pb.TagNumber(6)
  void clearStoragePool() => clearField(6);

  /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  /// Default is ThinProvisioned.
  /// +optional
  @$pb.TagNumber(7)
  $core.String get storageMode => $_getSZ(6);
  @$pb.TagNumber(7)
  set storageMode($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasStorageMode() => $_has(6);
  @$pb.TagNumber(7)
  void clearStorageMode() => clearField(7);

  /// volumeName is the name of a volume already created in the ScaleIO system
  /// that is associated with this volume source.
  @$pb.TagNumber(8)
  $core.String get volumeName => $_getSZ(7);
  @$pb.TagNumber(8)
  set volumeName($core.String v) { $_setString(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasVolumeName() => $_has(7);
  @$pb.TagNumber(8)
  void clearVolumeName() => clearField(8);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// Default is "xfs".
  /// +optional
  @$pb.TagNumber(9)
  $core.String get fsType => $_getSZ(8);
  @$pb.TagNumber(9)
  set fsType($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasFsType() => $_has(8);
  @$pb.TagNumber(9)
  void clearFsType() => clearField(9);

  /// readOnly Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(10)
  $core.bool get readOnly => $_getBF(9);
  @$pb.TagNumber(10)
  set readOnly($core.bool v) { $_setBool(9, v); }
  @$pb.TagNumber(10)
  $core.bool hasReadOnly() => $_has(9);
  @$pb.TagNumber(10)
  void clearReadOnly() => clearField(10);
}

/// A scope selector represents the AND of the selectors represented
/// by the scoped-resource selector requirements.
/// +structType=atomic
class ScopeSelector extends $pb.GeneratedMessage {
  factory ScopeSelector({
    $core.Iterable<ScopedResourceSelectorRequirement>? matchExpressions,
  }) {
    final $result = create();
    if (matchExpressions != null) {
      $result.matchExpressions.addAll(matchExpressions);
    }
    return $result;
  }
  ScopeSelector._() : super();
  factory ScopeSelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ScopeSelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ScopeSelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<ScopedResourceSelectorRequirement>(1, _omitFieldNames ? '' : 'matchExpressions', $pb.PbFieldType.PM, protoName: 'matchExpressions', subBuilder: ScopedResourceSelectorRequirement.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ScopeSelector clone() => ScopeSelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ScopeSelector copyWith(void Function(ScopeSelector) updates) => super.copyWith((message) => updates(message as ScopeSelector)) as ScopeSelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ScopeSelector create() => ScopeSelector._();
  ScopeSelector createEmptyInstance() => create();
  static $pb.PbList<ScopeSelector> createRepeated() => $pb.PbList<ScopeSelector>();
  @$core.pragma('dart2js:noInline')
  static ScopeSelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ScopeSelector>(create);
  static ScopeSelector? _defaultInstance;

  /// A list of scope selector requirements by scope of the resources.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<ScopedResourceSelectorRequirement> get matchExpressions => $_getList(0);
}

/// A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
/// that relates the scope name and values.
class ScopedResourceSelectorRequirement extends $pb.GeneratedMessage {
  factory ScopedResourceSelectorRequirement({
    $core.String? scopeName,
    $core.String? operator,
    $core.Iterable<$core.String>? values,
  }) {
    final $result = create();
    if (scopeName != null) {
      $result.scopeName = scopeName;
    }
    if (operator != null) {
      $result.operator = operator;
    }
    if (values != null) {
      $result.values.addAll(values);
    }
    return $result;
  }
  ScopedResourceSelectorRequirement._() : super();
  factory ScopedResourceSelectorRequirement.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ScopedResourceSelectorRequirement.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ScopedResourceSelectorRequirement', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'scopeName', protoName: 'scopeName')
    ..aOS(2, _omitFieldNames ? '' : 'operator')
    ..pPS(3, _omitFieldNames ? '' : 'values')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ScopedResourceSelectorRequirement clone() => ScopedResourceSelectorRequirement()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ScopedResourceSelectorRequirement copyWith(void Function(ScopedResourceSelectorRequirement) updates) => super.copyWith((message) => updates(message as ScopedResourceSelectorRequirement)) as ScopedResourceSelectorRequirement;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ScopedResourceSelectorRequirement create() => ScopedResourceSelectorRequirement._();
  ScopedResourceSelectorRequirement createEmptyInstance() => create();
  static $pb.PbList<ScopedResourceSelectorRequirement> createRepeated() => $pb.PbList<ScopedResourceSelectorRequirement>();
  @$core.pragma('dart2js:noInline')
  static ScopedResourceSelectorRequirement getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ScopedResourceSelectorRequirement>(create);
  static ScopedResourceSelectorRequirement? _defaultInstance;

  /// The name of the scope that the selector applies to.
  @$pb.TagNumber(1)
  $core.String get scopeName => $_getSZ(0);
  @$pb.TagNumber(1)
  set scopeName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasScopeName() => $_has(0);
  @$pb.TagNumber(1)
  void clearScopeName() => clearField(1);

  /// Represents a scope's relationship to a set of values.
  /// Valid operators are In, NotIn, Exists, DoesNotExist.
  @$pb.TagNumber(2)
  $core.String get operator => $_getSZ(1);
  @$pb.TagNumber(2)
  set operator($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasOperator() => $_has(1);
  @$pb.TagNumber(2)
  void clearOperator() => clearField(2);

  /// An array of string values. If the operator is In or NotIn,
  /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
  /// the values array must be empty.
  /// This array is replaced during a strategic merge patch.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<$core.String> get values => $_getList(2);
}

/// SeccompProfile defines a pod/container's seccomp profile settings.
/// Only one profile source may be set.
/// +union
class SeccompProfile extends $pb.GeneratedMessage {
  factory SeccompProfile({
    $core.String? type,
    $core.String? localhostProfile,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (localhostProfile != null) {
      $result.localhostProfile = localhostProfile;
    }
    return $result;
  }
  SeccompProfile._() : super();
  factory SeccompProfile.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SeccompProfile.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SeccompProfile', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aOS(2, _omitFieldNames ? '' : 'localhostProfile', protoName: 'localhostProfile')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SeccompProfile clone() => SeccompProfile()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SeccompProfile copyWith(void Function(SeccompProfile) updates) => super.copyWith((message) => updates(message as SeccompProfile)) as SeccompProfile;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SeccompProfile create() => SeccompProfile._();
  SeccompProfile createEmptyInstance() => create();
  static $pb.PbList<SeccompProfile> createRepeated() => $pb.PbList<SeccompProfile>();
  @$core.pragma('dart2js:noInline')
  static SeccompProfile getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SeccompProfile>(create);
  static SeccompProfile? _defaultInstance;

  ///  type indicates which kind of seccomp profile will be applied.
  ///  Valid options are:
  ///
  ///  Localhost - a profile defined in a file on the node should be used.
  ///  RuntimeDefault - the container runtime default profile should be used.
  ///  Unconfined - no profile should be applied.
  ///  +unionDiscriminator
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// localhostProfile indicates a profile defined in a file on the node should be used.
  /// The profile must be preconfigured on the node to work.
  /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
  /// Must be set if type is "Localhost". Must NOT be set for any other type.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get localhostProfile => $_getSZ(1);
  @$pb.TagNumber(2)
  set localhostProfile($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasLocalhostProfile() => $_has(1);
  @$pb.TagNumber(2)
  void clearLocalhostProfile() => clearField(2);
}

/// Secret holds secret data of a certain type. The total bytes of the values in
/// the Data field must be less than MaxSecretSize bytes.
class Secret extends $pb.GeneratedMessage {
  factory Secret({
    $0.ObjectMeta? metadata,
    $core.Map<$core.String, $core.List<$core.int>>? data,
    $core.String? type,
    $core.Map<$core.String, $core.String>? stringData,
    $core.bool? immutable,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (data != null) {
      $result.data.addAll(data);
    }
    if (type != null) {
      $result.type = type;
    }
    if (stringData != null) {
      $result.stringData.addAll(stringData);
    }
    if (immutable != null) {
      $result.immutable = immutable;
    }
    return $result;
  }
  Secret._() : super();
  factory Secret.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Secret.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Secret', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..m<$core.String, $core.List<$core.int>>(2, _omitFieldNames ? '' : 'data', entryClassName: 'Secret.DataEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OY, packageName: const $pb.PackageName('api.core.v1'))
    ..aOS(3, _omitFieldNames ? '' : 'type')
    ..m<$core.String, $core.String>(4, _omitFieldNames ? '' : 'stringData', protoName: 'stringData', entryClassName: 'Secret.StringDataEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOB(5, _omitFieldNames ? '' : 'immutable')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Secret clone() => Secret()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Secret copyWith(void Function(Secret) updates) => super.copyWith((message) => updates(message as Secret)) as Secret;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Secret create() => Secret._();
  Secret createEmptyInstance() => create();
  static $pb.PbList<Secret> createRepeated() => $pb.PbList<Secret>();
  @$core.pragma('dart2js:noInline')
  static Secret getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Secret>(create);
  static Secret? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Data contains the secret data. Each key must consist of alphanumeric
  /// characters, '-', '_' or '.'. The serialized form of the secret data is a
  /// base64 encoded string, representing the arbitrary (possibly non-string)
  /// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $core.List<$core.int>> get data => $_getMap(1);

  /// Used to facilitate programmatic handling of secret data.
  /// More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
  /// +optional
  @$pb.TagNumber(3)
  $core.String get type => $_getSZ(2);
  @$pb.TagNumber(3)
  set type($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasType() => $_has(2);
  @$pb.TagNumber(3)
  void clearType() => clearField(3);

  /// stringData allows specifying non-binary secret data in string form.
  /// It is provided as a write-only input field for convenience.
  /// All keys and values are merged into the data field on write, overwriting any existing values.
  /// The stringData field is never output when reading from the API.
  /// +k8s:conversion-gen=false
  /// +optional
  @$pb.TagNumber(4)
  $core.Map<$core.String, $core.String> get stringData => $_getMap(3);

  /// Immutable, if set to true, ensures that data stored in the Secret cannot
  /// be updated (only object metadata can be modified).
  /// If not set to true, the field can be modified at any time.
  /// Defaulted to nil.
  /// +optional
  @$pb.TagNumber(5)
  $core.bool get immutable => $_getBF(4);
  @$pb.TagNumber(5)
  set immutable($core.bool v) { $_setBool(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasImmutable() => $_has(4);
  @$pb.TagNumber(5)
  void clearImmutable() => clearField(5);
}

///  SecretEnvSource selects a Secret to populate the environment
///  variables with.
///
///  The contents of the target Secret's Data field will represent the
///  key-value pairs as environment variables.
class SecretEnvSource extends $pb.GeneratedMessage {
  factory SecretEnvSource({
    LocalObjectReference? localObjectReference,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  SecretEnvSource._() : super();
  factory SecretEnvSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretEnvSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretEnvSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..aOB(2, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretEnvSource clone() => SecretEnvSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretEnvSource copyWith(void Function(SecretEnvSource) updates) => super.copyWith((message) => updates(message as SecretEnvSource)) as SecretEnvSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretEnvSource create() => SecretEnvSource._();
  SecretEnvSource createEmptyInstance() => create();
  static $pb.PbList<SecretEnvSource> createRepeated() => $pb.PbList<SecretEnvSource>();
  @$core.pragma('dart2js:noInline')
  static SecretEnvSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretEnvSource>(create);
  static SecretEnvSource? _defaultInstance;

  /// The Secret to select from.
  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// Specify whether the Secret must be defined
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get optional => $_getBF(1);
  @$pb.TagNumber(2)
  set optional($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasOptional() => $_has(1);
  @$pb.TagNumber(2)
  void clearOptional() => clearField(2);
}

/// SecretKeySelector selects a key of a Secret.
/// +structType=atomic
class SecretKeySelector extends $pb.GeneratedMessage {
  factory SecretKeySelector({
    LocalObjectReference? localObjectReference,
    $core.String? key,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (key != null) {
      $result.key = key;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  SecretKeySelector._() : super();
  factory SecretKeySelector.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretKeySelector.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretKeySelector', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..aOS(2, _omitFieldNames ? '' : 'key')
    ..aOB(3, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretKeySelector clone() => SecretKeySelector()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretKeySelector copyWith(void Function(SecretKeySelector) updates) => super.copyWith((message) => updates(message as SecretKeySelector)) as SecretKeySelector;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretKeySelector create() => SecretKeySelector._();
  SecretKeySelector createEmptyInstance() => create();
  static $pb.PbList<SecretKeySelector> createRepeated() => $pb.PbList<SecretKeySelector>();
  @$core.pragma('dart2js:noInline')
  static SecretKeySelector getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretKeySelector>(create);
  static SecretKeySelector? _defaultInstance;

  /// The name of the secret in the pod's namespace to select from.
  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// The key of the secret to select from.  Must be a valid secret key.
  @$pb.TagNumber(2)
  $core.String get key => $_getSZ(1);
  @$pb.TagNumber(2)
  set key($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasKey() => $_has(1);
  @$pb.TagNumber(2)
  void clearKey() => clearField(2);

  /// Specify whether the Secret or its key must be defined
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get optional => $_getBF(2);
  @$pb.TagNumber(3)
  set optional($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasOptional() => $_has(2);
  @$pb.TagNumber(3)
  void clearOptional() => clearField(3);
}

/// SecretList is a list of Secret.
class SecretList extends $pb.GeneratedMessage {
  factory SecretList({
    $0.ListMeta? metadata,
    $core.Iterable<Secret>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  SecretList._() : super();
  factory SecretList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Secret>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Secret.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretList clone() => SecretList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretList copyWith(void Function(SecretList) updates) => super.copyWith((message) => updates(message as SecretList)) as SecretList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretList create() => SecretList._();
  SecretList createEmptyInstance() => create();
  static $pb.PbList<SecretList> createRepeated() => $pb.PbList<SecretList>();
  @$core.pragma('dart2js:noInline')
  static SecretList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretList>(create);
  static SecretList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// Items is a list of secret objects.
  /// More info: https://kubernetes.io/docs/concepts/configuration/secret
  @$pb.TagNumber(2)
  $core.List<Secret> get items => $_getList(1);
}

///  Adapts a secret into a projected volume.
///
///  The contents of the target Secret's Data field will be presented in a
///  projected volume as files using the keys in the Data field as the file names.
///  Note that this is identical to a secret volume source without the default
///  mode.
class SecretProjection extends $pb.GeneratedMessage {
  factory SecretProjection({
    LocalObjectReference? localObjectReference,
    $core.Iterable<KeyToPath>? items,
    $core.bool? optional,
  }) {
    final $result = create();
    if (localObjectReference != null) {
      $result.localObjectReference = localObjectReference;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  SecretProjection._() : super();
  factory SecretProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LocalObjectReference>(1, _omitFieldNames ? '' : 'localObjectReference', protoName: 'localObjectReference', subBuilder: LocalObjectReference.create)
    ..pc<KeyToPath>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: KeyToPath.create)
    ..aOB(4, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretProjection clone() => SecretProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretProjection copyWith(void Function(SecretProjection) updates) => super.copyWith((message) => updates(message as SecretProjection)) as SecretProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretProjection create() => SecretProjection._();
  SecretProjection createEmptyInstance() => create();
  static $pb.PbList<SecretProjection> createRepeated() => $pb.PbList<SecretProjection>();
  @$core.pragma('dart2js:noInline')
  static SecretProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretProjection>(create);
  static SecretProjection? _defaultInstance;

  @$pb.TagNumber(1)
  LocalObjectReference get localObjectReference => $_getN(0);
  @$pb.TagNumber(1)
  set localObjectReference(LocalObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLocalObjectReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearLocalObjectReference() => clearField(1);
  @$pb.TagNumber(1)
  LocalObjectReference ensureLocalObjectReference() => $_ensure(0);

  /// items if unspecified, each key-value pair in the Data field of the referenced
  /// Secret will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the Secret,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<KeyToPath> get items => $_getList(1);

  /// optional field specify whether the Secret or its key must be defined
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get optional => $_getBF(2);
  @$pb.TagNumber(4)
  set optional($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(4)
  $core.bool hasOptional() => $_has(2);
  @$pb.TagNumber(4)
  void clearOptional() => clearField(4);
}

/// SecretReference represents a Secret Reference. It has enough information to retrieve secret
/// in any namespace
/// +structType=atomic
class SecretReference extends $pb.GeneratedMessage {
  factory SecretReference({
    $core.String? name,
    $core.String? namespace,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (namespace != null) {
      $result.namespace = namespace;
    }
    return $result;
  }
  SecretReference._() : super();
  factory SecretReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'namespace')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretReference clone() => SecretReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretReference copyWith(void Function(SecretReference) updates) => super.copyWith((message) => updates(message as SecretReference)) as SecretReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretReference create() => SecretReference._();
  SecretReference createEmptyInstance() => create();
  static $pb.PbList<SecretReference> createRepeated() => $pb.PbList<SecretReference>();
  @$core.pragma('dart2js:noInline')
  static SecretReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretReference>(create);
  static SecretReference? _defaultInstance;

  /// name is unique within a namespace to reference a secret resource.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// namespace defines the space within which the secret name must be unique.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get namespace => $_getSZ(1);
  @$pb.TagNumber(2)
  set namespace($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasNamespace() => $_has(1);
  @$pb.TagNumber(2)
  void clearNamespace() => clearField(2);
}

///  Adapts a Secret into a volume.
///
///  The contents of the target Secret's Data field will be presented in a volume
///  as files using the keys in the Data field as the file names.
///  Secret volumes support ownership management and SELinux relabeling.
class SecretVolumeSource extends $pb.GeneratedMessage {
  factory SecretVolumeSource({
    $core.String? secretName,
    $core.Iterable<KeyToPath>? items,
    $core.int? defaultMode,
    $core.bool? optional,
  }) {
    final $result = create();
    if (secretName != null) {
      $result.secretName = secretName;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    if (defaultMode != null) {
      $result.defaultMode = defaultMode;
    }
    if (optional != null) {
      $result.optional = optional;
    }
    return $result;
  }
  SecretVolumeSource._() : super();
  factory SecretVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecretVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecretVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'secretName', protoName: 'secretName')
    ..pc<KeyToPath>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: KeyToPath.create)
    ..a<$core.int>(3, _omitFieldNames ? '' : 'defaultMode', $pb.PbFieldType.O3, protoName: 'defaultMode')
    ..aOB(4, _omitFieldNames ? '' : 'optional')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecretVolumeSource clone() => SecretVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecretVolumeSource copyWith(void Function(SecretVolumeSource) updates) => super.copyWith((message) => updates(message as SecretVolumeSource)) as SecretVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecretVolumeSource create() => SecretVolumeSource._();
  SecretVolumeSource createEmptyInstance() => create();
  static $pb.PbList<SecretVolumeSource> createRepeated() => $pb.PbList<SecretVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static SecretVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecretVolumeSource>(create);
  static SecretVolumeSource? _defaultInstance;

  /// secretName is the name of the secret in the pod's namespace to use.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  /// +optional
  @$pb.TagNumber(1)
  $core.String get secretName => $_getSZ(0);
  @$pb.TagNumber(1)
  set secretName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasSecretName() => $_has(0);
  @$pb.TagNumber(1)
  void clearSecretName() => clearField(1);

  /// items If unspecified, each key-value pair in the Data field of the referenced
  /// Secret will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the Secret,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<KeyToPath> get items => $_getList(1);

  /// defaultMode is Optional: mode bits used to set permissions on created files by default.
  /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  /// YAML accepts both octal and decimal values, JSON requires decimal values
  /// for mode bits. Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  @$pb.TagNumber(3)
  $core.int get defaultMode => $_getIZ(2);
  @$pb.TagNumber(3)
  set defaultMode($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasDefaultMode() => $_has(2);
  @$pb.TagNumber(3)
  void clearDefaultMode() => clearField(3);

  /// optional field specify whether the Secret or its keys must be defined
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get optional => $_getBF(3);
  @$pb.TagNumber(4)
  set optional($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasOptional() => $_has(3);
  @$pb.TagNumber(4)
  void clearOptional() => clearField(4);
}

/// SecurityContext holds security configuration that will be applied to a container.
/// Some fields are present in both SecurityContext and PodSecurityContext.  When both
/// are set, the values in SecurityContext take precedence.
class SecurityContext extends $pb.GeneratedMessage {
  factory SecurityContext({
    Capabilities? capabilities,
    $core.bool? privileged,
    SELinuxOptions? seLinuxOptions,
    $fixnum.Int64? runAsUser,
    $core.bool? runAsNonRoot,
    $core.bool? readOnlyRootFilesystem,
    $core.bool? allowPrivilegeEscalation,
    $fixnum.Int64? runAsGroup,
    $core.String? procMount,
    WindowsSecurityContextOptions? windowsOptions,
    SeccompProfile? seccompProfile,
    AppArmorProfile? appArmorProfile,
  }) {
    final $result = create();
    if (capabilities != null) {
      $result.capabilities = capabilities;
    }
    if (privileged != null) {
      $result.privileged = privileged;
    }
    if (seLinuxOptions != null) {
      $result.seLinuxOptions = seLinuxOptions;
    }
    if (runAsUser != null) {
      $result.runAsUser = runAsUser;
    }
    if (runAsNonRoot != null) {
      $result.runAsNonRoot = runAsNonRoot;
    }
    if (readOnlyRootFilesystem != null) {
      $result.readOnlyRootFilesystem = readOnlyRootFilesystem;
    }
    if (allowPrivilegeEscalation != null) {
      $result.allowPrivilegeEscalation = allowPrivilegeEscalation;
    }
    if (runAsGroup != null) {
      $result.runAsGroup = runAsGroup;
    }
    if (procMount != null) {
      $result.procMount = procMount;
    }
    if (windowsOptions != null) {
      $result.windowsOptions = windowsOptions;
    }
    if (seccompProfile != null) {
      $result.seccompProfile = seccompProfile;
    }
    if (appArmorProfile != null) {
      $result.appArmorProfile = appArmorProfile;
    }
    return $result;
  }
  SecurityContext._() : super();
  factory SecurityContext.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SecurityContext.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SecurityContext', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<Capabilities>(1, _omitFieldNames ? '' : 'capabilities', subBuilder: Capabilities.create)
    ..aOB(2, _omitFieldNames ? '' : 'privileged')
    ..aOM<SELinuxOptions>(3, _omitFieldNames ? '' : 'seLinuxOptions', protoName: 'seLinuxOptions', subBuilder: SELinuxOptions.create)
    ..aInt64(4, _omitFieldNames ? '' : 'runAsUser', protoName: 'runAsUser')
    ..aOB(5, _omitFieldNames ? '' : 'runAsNonRoot', protoName: 'runAsNonRoot')
    ..aOB(6, _omitFieldNames ? '' : 'readOnlyRootFilesystem', protoName: 'readOnlyRootFilesystem')
    ..aOB(7, _omitFieldNames ? '' : 'allowPrivilegeEscalation', protoName: 'allowPrivilegeEscalation')
    ..aInt64(8, _omitFieldNames ? '' : 'runAsGroup', protoName: 'runAsGroup')
    ..aOS(9, _omitFieldNames ? '' : 'procMount', protoName: 'procMount')
    ..aOM<WindowsSecurityContextOptions>(10, _omitFieldNames ? '' : 'windowsOptions', protoName: 'windowsOptions', subBuilder: WindowsSecurityContextOptions.create)
    ..aOM<SeccompProfile>(11, _omitFieldNames ? '' : 'seccompProfile', protoName: 'seccompProfile', subBuilder: SeccompProfile.create)
    ..aOM<AppArmorProfile>(12, _omitFieldNames ? '' : 'appArmorProfile', protoName: 'appArmorProfile', subBuilder: AppArmorProfile.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SecurityContext clone() => SecurityContext()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SecurityContext copyWith(void Function(SecurityContext) updates) => super.copyWith((message) => updates(message as SecurityContext)) as SecurityContext;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SecurityContext create() => SecurityContext._();
  SecurityContext createEmptyInstance() => create();
  static $pb.PbList<SecurityContext> createRepeated() => $pb.PbList<SecurityContext>();
  @$core.pragma('dart2js:noInline')
  static SecurityContext getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SecurityContext>(create);
  static SecurityContext? _defaultInstance;

  /// The capabilities to add/drop when running containers.
  /// Defaults to the default set of capabilities granted by the container runtime.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(1)
  Capabilities get capabilities => $_getN(0);
  @$pb.TagNumber(1)
  set capabilities(Capabilities v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasCapabilities() => $_has(0);
  @$pb.TagNumber(1)
  void clearCapabilities() => clearField(1);
  @$pb.TagNumber(1)
  Capabilities ensureCapabilities() => $_ensure(0);

  /// Run container in privileged mode.
  /// Processes in privileged containers are essentially equivalent to root on the host.
  /// Defaults to false.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get privileged => $_getBF(1);
  @$pb.TagNumber(2)
  set privileged($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPrivileged() => $_has(1);
  @$pb.TagNumber(2)
  void clearPrivileged() => clearField(2);

  /// The SELinux context to be applied to the container.
  /// If unspecified, the container runtime will allocate a random SELinux context for each
  /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(3)
  SELinuxOptions get seLinuxOptions => $_getN(2);
  @$pb.TagNumber(3)
  set seLinuxOptions(SELinuxOptions v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasSeLinuxOptions() => $_has(2);
  @$pb.TagNumber(3)
  void clearSeLinuxOptions() => clearField(3);
  @$pb.TagNumber(3)
  SELinuxOptions ensureSeLinuxOptions() => $_ensure(2);

  /// The UID to run the entrypoint of the container process.
  /// Defaults to user specified in image metadata if unspecified.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(4)
  $fixnum.Int64 get runAsUser => $_getI64(3);
  @$pb.TagNumber(4)
  set runAsUser($fixnum.Int64 v) { $_setInt64(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasRunAsUser() => $_has(3);
  @$pb.TagNumber(4)
  void clearRunAsUser() => clearField(4);

  /// Indicates that the container must run as a non-root user.
  /// If true, the Kubelet will validate the image at runtime to ensure that it
  /// does not run as UID 0 (root) and fail to start the container if it does.
  /// If unset or false, no such validation will be performed.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  @$pb.TagNumber(5)
  $core.bool get runAsNonRoot => $_getBF(4);
  @$pb.TagNumber(5)
  set runAsNonRoot($core.bool v) { $_setBool(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasRunAsNonRoot() => $_has(4);
  @$pb.TagNumber(5)
  void clearRunAsNonRoot() => clearField(5);

  /// Whether this container has a read-only root filesystem.
  /// Default is false.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(6)
  $core.bool get readOnlyRootFilesystem => $_getBF(5);
  @$pb.TagNumber(6)
  set readOnlyRootFilesystem($core.bool v) { $_setBool(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasReadOnlyRootFilesystem() => $_has(5);
  @$pb.TagNumber(6)
  void clearReadOnlyRootFilesystem() => clearField(6);

  /// AllowPrivilegeEscalation controls whether a process can gain more
  /// privileges than its parent process. This bool directly controls if
  /// the no_new_privs flag will be set on the container process.
  /// AllowPrivilegeEscalation is true always when the container is:
  /// 1) run as Privileged
  /// 2) has CAP_SYS_ADMIN
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(7)
  $core.bool get allowPrivilegeEscalation => $_getBF(6);
  @$pb.TagNumber(7)
  set allowPrivilegeEscalation($core.bool v) { $_setBool(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasAllowPrivilegeEscalation() => $_has(6);
  @$pb.TagNumber(7)
  void clearAllowPrivilegeEscalation() => clearField(7);

  /// The GID to run the entrypoint of the container process.
  /// Uses runtime default if unset.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(8)
  $fixnum.Int64 get runAsGroup => $_getI64(7);
  @$pb.TagNumber(8)
  set runAsGroup($fixnum.Int64 v) { $_setInt64(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasRunAsGroup() => $_has(7);
  @$pb.TagNumber(8)
  void clearRunAsGroup() => clearField(8);

  /// procMount denotes the type of proc mount to use for the containers.
  /// The default is DefaultProcMount which uses the container runtime defaults for
  /// readonly paths and masked paths.
  /// This requires the ProcMountType feature flag to be enabled.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(9)
  $core.String get procMount => $_getSZ(8);
  @$pb.TagNumber(9)
  set procMount($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasProcMount() => $_has(8);
  @$pb.TagNumber(9)
  void clearProcMount() => clearField(9);

  /// The Windows specific settings applied to all containers.
  /// If unspecified, the options from the PodSecurityContext will be used.
  /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// Note that this field cannot be set when spec.os.name is linux.
  /// +optional
  @$pb.TagNumber(10)
  WindowsSecurityContextOptions get windowsOptions => $_getN(9);
  @$pb.TagNumber(10)
  set windowsOptions(WindowsSecurityContextOptions v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasWindowsOptions() => $_has(9);
  @$pb.TagNumber(10)
  void clearWindowsOptions() => clearField(10);
  @$pb.TagNumber(10)
  WindowsSecurityContextOptions ensureWindowsOptions() => $_ensure(9);

  /// The seccomp options to use by this container. If seccomp options are
  /// provided at both the pod & container level, the container options
  /// override the pod options.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(11)
  SeccompProfile get seccompProfile => $_getN(10);
  @$pb.TagNumber(11)
  set seccompProfile(SeccompProfile v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasSeccompProfile() => $_has(10);
  @$pb.TagNumber(11)
  void clearSeccompProfile() => clearField(11);
  @$pb.TagNumber(11)
  SeccompProfile ensureSeccompProfile() => $_ensure(10);

  /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
  /// overrides the pod's appArmorProfile.
  /// Note that this field cannot be set when spec.os.name is windows.
  /// +optional
  @$pb.TagNumber(12)
  AppArmorProfile get appArmorProfile => $_getN(11);
  @$pb.TagNumber(12)
  set appArmorProfile(AppArmorProfile v) { setField(12, v); }
  @$pb.TagNumber(12)
  $core.bool hasAppArmorProfile() => $_has(11);
  @$pb.TagNumber(12)
  void clearAppArmorProfile() => clearField(12);
  @$pb.TagNumber(12)
  AppArmorProfile ensureAppArmorProfile() => $_ensure(11);
}

/// SerializedReference is a reference to serialized object.
class SerializedReference extends $pb.GeneratedMessage {
  factory SerializedReference({
    ObjectReference? reference,
  }) {
    final $result = create();
    if (reference != null) {
      $result.reference = reference;
    }
    return $result;
  }
  SerializedReference._() : super();
  factory SerializedReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SerializedReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SerializedReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ObjectReference>(1, _omitFieldNames ? '' : 'reference', subBuilder: ObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SerializedReference clone() => SerializedReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SerializedReference copyWith(void Function(SerializedReference) updates) => super.copyWith((message) => updates(message as SerializedReference)) as SerializedReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SerializedReference create() => SerializedReference._();
  SerializedReference createEmptyInstance() => create();
  static $pb.PbList<SerializedReference> createRepeated() => $pb.PbList<SerializedReference>();
  @$core.pragma('dart2js:noInline')
  static SerializedReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SerializedReference>(create);
  static SerializedReference? _defaultInstance;

  /// The reference to an object in the system.
  /// +optional
  @$pb.TagNumber(1)
  ObjectReference get reference => $_getN(0);
  @$pb.TagNumber(1)
  set reference(ObjectReference v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasReference() => $_has(0);
  @$pb.TagNumber(1)
  void clearReference() => clearField(1);
  @$pb.TagNumber(1)
  ObjectReference ensureReference() => $_ensure(0);
}

/// Service is a named abstraction of software service (for example, mysql) consisting of local port
/// (for example 3306) that the proxy listens on, and the selector that determines which pods
/// will answer requests sent through the proxy.
class Service extends $pb.GeneratedMessage {
  factory Service({
    $0.ObjectMeta? metadata,
    ServiceSpec? spec,
    ServiceStatus? status,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (spec != null) {
      $result.spec = spec;
    }
    if (status != null) {
      $result.status = status;
    }
    return $result;
  }
  Service._() : super();
  factory Service.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Service.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Service', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..aOM<ServiceSpec>(2, _omitFieldNames ? '' : 'spec', subBuilder: ServiceSpec.create)
    ..aOM<ServiceStatus>(3, _omitFieldNames ? '' : 'status', subBuilder: ServiceStatus.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Service clone() => Service()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Service copyWith(void Function(Service) updates) => super.copyWith((message) => updates(message as Service)) as Service;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Service create() => Service._();
  Service createEmptyInstance() => create();
  static $pb.PbList<Service> createRepeated() => $pb.PbList<Service>();
  @$core.pragma('dart2js:noInline')
  static Service getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Service>(create);
  static Service? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Spec defines the behavior of a service.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(2)
  ServiceSpec get spec => $_getN(1);
  @$pb.TagNumber(2)
  set spec(ServiceSpec v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearSpec() => clearField(2);
  @$pb.TagNumber(2)
  ServiceSpec ensureSpec() => $_ensure(1);

  /// Most recently observed status of the service.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  @$pb.TagNumber(3)
  ServiceStatus get status => $_getN(2);
  @$pb.TagNumber(3)
  set status(ServiceStatus v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasStatus() => $_has(2);
  @$pb.TagNumber(3)
  void clearStatus() => clearField(3);
  @$pb.TagNumber(3)
  ServiceStatus ensureStatus() => $_ensure(2);
}

/// ServiceAccount binds together:
/// * a name, understood by users, and perhaps by peripheral systems, for an identity
/// * a principal that can be authenticated and authorized
/// * a set of secrets
class ServiceAccount extends $pb.GeneratedMessage {
  factory ServiceAccount({
    $0.ObjectMeta? metadata,
    $core.Iterable<ObjectReference>? secrets,
    $core.Iterable<LocalObjectReference>? imagePullSecrets,
    $core.bool? automountServiceAccountToken,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (secrets != null) {
      $result.secrets.addAll(secrets);
    }
    if (imagePullSecrets != null) {
      $result.imagePullSecrets.addAll(imagePullSecrets);
    }
    if (automountServiceAccountToken != null) {
      $result.automountServiceAccountToken = automountServiceAccountToken;
    }
    return $result;
  }
  ServiceAccount._() : super();
  factory ServiceAccount.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceAccount.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceAccount', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ObjectMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ObjectMeta.create)
    ..pc<ObjectReference>(2, _omitFieldNames ? '' : 'secrets', $pb.PbFieldType.PM, subBuilder: ObjectReference.create)
    ..pc<LocalObjectReference>(3, _omitFieldNames ? '' : 'imagePullSecrets', $pb.PbFieldType.PM, protoName: 'imagePullSecrets', subBuilder: LocalObjectReference.create)
    ..aOB(4, _omitFieldNames ? '' : 'automountServiceAccountToken', protoName: 'automountServiceAccountToken')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceAccount clone() => ServiceAccount()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceAccount copyWith(void Function(ServiceAccount) updates) => super.copyWith((message) => updates(message as ServiceAccount)) as ServiceAccount;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceAccount create() => ServiceAccount._();
  ServiceAccount createEmptyInstance() => create();
  static $pb.PbList<ServiceAccount> createRepeated() => $pb.PbList<ServiceAccount>();
  @$core.pragma('dart2js:noInline')
  static ServiceAccount getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceAccount>(create);
  static ServiceAccount? _defaultInstance;

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  @$pb.TagNumber(1)
  $0.ObjectMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ObjectMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ObjectMeta ensureMetadata() => $_ensure(0);

  /// Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use.
  /// Pods are only limited to this list if this service account has a "kubernetes.io/enforce-mountable-secrets" annotation set to "true".
  /// This field should not be used to find auto-generated service account token secrets for use outside of pods.
  /// Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created.
  /// More info: https://kubernetes.io/docs/concepts/configuration/secret
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=name
  @$pb.TagNumber(2)
  $core.List<ObjectReference> get secrets => $_getList(1);

  /// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
  /// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
  /// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
  /// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(3)
  $core.List<LocalObjectReference> get imagePullSecrets => $_getList(2);

  /// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
  /// Can be overridden at the pod level.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get automountServiceAccountToken => $_getBF(3);
  @$pb.TagNumber(4)
  set automountServiceAccountToken($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasAutomountServiceAccountToken() => $_has(3);
  @$pb.TagNumber(4)
  void clearAutomountServiceAccountToken() => clearField(4);
}

/// ServiceAccountList is a list of ServiceAccount objects
class ServiceAccountList extends $pb.GeneratedMessage {
  factory ServiceAccountList({
    $0.ListMeta? metadata,
    $core.Iterable<ServiceAccount>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ServiceAccountList._() : super();
  factory ServiceAccountList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceAccountList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceAccountList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<ServiceAccount>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: ServiceAccount.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceAccountList clone() => ServiceAccountList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceAccountList copyWith(void Function(ServiceAccountList) updates) => super.copyWith((message) => updates(message as ServiceAccountList)) as ServiceAccountList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceAccountList create() => ServiceAccountList._();
  ServiceAccountList createEmptyInstance() => create();
  static $pb.PbList<ServiceAccountList> createRepeated() => $pb.PbList<ServiceAccountList>();
  @$core.pragma('dart2js:noInline')
  static ServiceAccountList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceAccountList>(create);
  static ServiceAccountList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of ServiceAccounts.
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  @$pb.TagNumber(2)
  $core.List<ServiceAccount> get items => $_getList(1);
}

/// ServiceAccountTokenProjection represents a projected service account token
/// volume. This projection can be used to insert a service account token into
/// the pods runtime filesystem for use against APIs (Kubernetes API Server or
/// otherwise).
class ServiceAccountTokenProjection extends $pb.GeneratedMessage {
  factory ServiceAccountTokenProjection({
    $core.String? audience,
    $fixnum.Int64? expirationSeconds,
    $core.String? path,
  }) {
    final $result = create();
    if (audience != null) {
      $result.audience = audience;
    }
    if (expirationSeconds != null) {
      $result.expirationSeconds = expirationSeconds;
    }
    if (path != null) {
      $result.path = path;
    }
    return $result;
  }
  ServiceAccountTokenProjection._() : super();
  factory ServiceAccountTokenProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceAccountTokenProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceAccountTokenProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'audience')
    ..aInt64(2, _omitFieldNames ? '' : 'expirationSeconds', protoName: 'expirationSeconds')
    ..aOS(3, _omitFieldNames ? '' : 'path')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceAccountTokenProjection clone() => ServiceAccountTokenProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceAccountTokenProjection copyWith(void Function(ServiceAccountTokenProjection) updates) => super.copyWith((message) => updates(message as ServiceAccountTokenProjection)) as ServiceAccountTokenProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceAccountTokenProjection create() => ServiceAccountTokenProjection._();
  ServiceAccountTokenProjection createEmptyInstance() => create();
  static $pb.PbList<ServiceAccountTokenProjection> createRepeated() => $pb.PbList<ServiceAccountTokenProjection>();
  @$core.pragma('dart2js:noInline')
  static ServiceAccountTokenProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceAccountTokenProjection>(create);
  static ServiceAccountTokenProjection? _defaultInstance;

  /// audience is the intended audience of the token. A recipient of a token
  /// must identify itself with an identifier specified in the audience of the
  /// token, and otherwise should reject the token. The audience defaults to the
  /// identifier of the apiserver.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get audience => $_getSZ(0);
  @$pb.TagNumber(1)
  set audience($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasAudience() => $_has(0);
  @$pb.TagNumber(1)
  void clearAudience() => clearField(1);

  /// expirationSeconds is the requested duration of validity of the service
  /// account token. As the token approaches expiration, the kubelet volume
  /// plugin will proactively rotate the service account token. The kubelet will
  /// start trying to rotate the token if the token is older than 80 percent of
  /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
  /// and must be at least 10 minutes.
  /// +optional
  @$pb.TagNumber(2)
  $fixnum.Int64 get expirationSeconds => $_getI64(1);
  @$pb.TagNumber(2)
  set expirationSeconds($fixnum.Int64 v) { $_setInt64(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasExpirationSeconds() => $_has(1);
  @$pb.TagNumber(2)
  void clearExpirationSeconds() => clearField(2);

  /// path is the path relative to the mount point of the file to project the
  /// token into.
  @$pb.TagNumber(3)
  $core.String get path => $_getSZ(2);
  @$pb.TagNumber(3)
  set path($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPath() => $_has(2);
  @$pb.TagNumber(3)
  void clearPath() => clearField(3);
}

/// ServiceList holds a list of services.
class ServiceList extends $pb.GeneratedMessage {
  factory ServiceList({
    $0.ListMeta? metadata,
    $core.Iterable<Service>? items,
  }) {
    final $result = create();
    if (metadata != null) {
      $result.metadata = metadata;
    }
    if (items != null) {
      $result.items.addAll(items);
    }
    return $result;
  }
  ServiceList._() : super();
  factory ServiceList.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceList.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceList', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$0.ListMeta>(1, _omitFieldNames ? '' : 'metadata', subBuilder: $0.ListMeta.create)
    ..pc<Service>(2, _omitFieldNames ? '' : 'items', $pb.PbFieldType.PM, subBuilder: Service.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceList clone() => ServiceList()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceList copyWith(void Function(ServiceList) updates) => super.copyWith((message) => updates(message as ServiceList)) as ServiceList;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceList create() => ServiceList._();
  ServiceList createEmptyInstance() => create();
  static $pb.PbList<ServiceList> createRepeated() => $pb.PbList<ServiceList>();
  @$core.pragma('dart2js:noInline')
  static ServiceList getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceList>(create);
  static ServiceList? _defaultInstance;

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  @$pb.TagNumber(1)
  $0.ListMeta get metadata => $_getN(0);
  @$pb.TagNumber(1)
  set metadata($0.ListMeta v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasMetadata() => $_has(0);
  @$pb.TagNumber(1)
  void clearMetadata() => clearField(1);
  @$pb.TagNumber(1)
  $0.ListMeta ensureMetadata() => $_ensure(0);

  /// List of services
  @$pb.TagNumber(2)
  $core.List<Service> get items => $_getList(1);
}

/// ServicePort contains information on service's port.
class ServicePort extends $pb.GeneratedMessage {
  factory ServicePort({
    $core.String? name,
    $core.String? protocol,
    $core.int? port,
    $2.IntOrString? targetPort,
    $core.int? nodePort,
    $core.String? appProtocol,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (protocol != null) {
      $result.protocol = protocol;
    }
    if (port != null) {
      $result.port = port;
    }
    if (targetPort != null) {
      $result.targetPort = targetPort;
    }
    if (nodePort != null) {
      $result.nodePort = nodePort;
    }
    if (appProtocol != null) {
      $result.appProtocol = appProtocol;
    }
    return $result;
  }
  ServicePort._() : super();
  factory ServicePort.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServicePort.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServicePort', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'protocol')
    ..a<$core.int>(3, _omitFieldNames ? '' : 'port', $pb.PbFieldType.O3)
    ..aOM<$2.IntOrString>(4, _omitFieldNames ? '' : 'targetPort', protoName: 'targetPort', subBuilder: $2.IntOrString.create)
    ..a<$core.int>(5, _omitFieldNames ? '' : 'nodePort', $pb.PbFieldType.O3, protoName: 'nodePort')
    ..aOS(6, _omitFieldNames ? '' : 'appProtocol', protoName: 'appProtocol')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServicePort clone() => ServicePort()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServicePort copyWith(void Function(ServicePort) updates) => super.copyWith((message) => updates(message as ServicePort)) as ServicePort;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServicePort create() => ServicePort._();
  ServicePort createEmptyInstance() => create();
  static $pb.PbList<ServicePort> createRepeated() => $pb.PbList<ServicePort>();
  @$core.pragma('dart2js:noInline')
  static ServicePort getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServicePort>(create);
  static ServicePort? _defaultInstance;

  /// The name of this port within the service. This must be a DNS_LABEL.
  /// All ports within a ServiceSpec must have unique names. When considering
  /// the endpoints for a Service, this must match the 'name' field in the
  /// EndpointPort.
  /// Optional if only one ServicePort is defined on this service.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  /// Default is TCP.
  /// +default="TCP"
  /// +optional
  @$pb.TagNumber(2)
  $core.String get protocol => $_getSZ(1);
  @$pb.TagNumber(2)
  set protocol($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasProtocol() => $_has(1);
  @$pb.TagNumber(2)
  void clearProtocol() => clearField(2);

  /// The port that will be exposed by this service.
  @$pb.TagNumber(3)
  $core.int get port => $_getIZ(2);
  @$pb.TagNumber(3)
  set port($core.int v) { $_setSignedInt32(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasPort() => $_has(2);
  @$pb.TagNumber(3)
  void clearPort() => clearField(3);

  /// Number or name of the port to access on the pods targeted by the service.
  /// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  /// If this is a string, it will be looked up as a named port in the
  /// target Pod's container ports. If this is not specified, the value
  /// of the 'port' field is used (an identity map).
  /// This field is ignored for services with clusterIP=None, and should be
  /// omitted or set equal to the 'port' field.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  /// +optional
  @$pb.TagNumber(4)
  $2.IntOrString get targetPort => $_getN(3);
  @$pb.TagNumber(4)
  set targetPort($2.IntOrString v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasTargetPort() => $_has(3);
  @$pb.TagNumber(4)
  void clearTargetPort() => clearField(4);
  @$pb.TagNumber(4)
  $2.IntOrString ensureTargetPort() => $_ensure(3);

  /// The port on each node on which this service is exposed when type is
  /// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
  /// specified, in-range, and not in use it will be used, otherwise the
  /// operation will fail.  If not specified, a port will be allocated if this
  /// Service requires one.  If this field is specified when creating a
  /// Service which does not need it, creation will fail. This field will be
  /// wiped when updating a Service to no longer need it (e.g. changing type
  /// from NodePort to ClusterIP).
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  /// +optional
  @$pb.TagNumber(5)
  $core.int get nodePort => $_getIZ(4);
  @$pb.TagNumber(5)
  set nodePort($core.int v) { $_setSignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasNodePort() => $_has(4);
  @$pb.TagNumber(5)
  void clearNodePort() => clearField(5);

  ///  The application protocol for this port.
  ///  This is used as a hint for implementations to offer richer behavior for protocols that they understand.
  ///  This field follows standard Kubernetes label syntax.
  ///  Valid values are either:
  ///
  ///  * Un-prefixed protocol names - reserved for IANA standard service names (as per
  ///  RFC-6335 and https://www.iana.org/assignments/service-names).
  ///
  ///  * Kubernetes-defined prefixed names:
  ///    * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
  ///    * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
  ///    * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
  ///
  ///  * Other protocols should use implementation-defined prefixed names such as
  ///  mycompany.com/my-custom-protocol.
  ///  +optional
  @$pb.TagNumber(6)
  $core.String get appProtocol => $_getSZ(5);
  @$pb.TagNumber(6)
  set appProtocol($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasAppProtocol() => $_has(5);
  @$pb.TagNumber(6)
  void clearAppProtocol() => clearField(6);
}

/// ServiceProxyOptions is the query options to a Service's proxy call.
class ServiceProxyOptions extends $pb.GeneratedMessage {
  factory ServiceProxyOptions({
    $core.String? path,
  }) {
    final $result = create();
    if (path != null) {
      $result.path = path;
    }
    return $result;
  }
  ServiceProxyOptions._() : super();
  factory ServiceProxyOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceProxyOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceProxyOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'path')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceProxyOptions clone() => ServiceProxyOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceProxyOptions copyWith(void Function(ServiceProxyOptions) updates) => super.copyWith((message) => updates(message as ServiceProxyOptions)) as ServiceProxyOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceProxyOptions create() => ServiceProxyOptions._();
  ServiceProxyOptions createEmptyInstance() => create();
  static $pb.PbList<ServiceProxyOptions> createRepeated() => $pb.PbList<ServiceProxyOptions>();
  @$core.pragma('dart2js:noInline')
  static ServiceProxyOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceProxyOptions>(create);
  static ServiceProxyOptions? _defaultInstance;

  /// Path is the part of URLs that include service endpoints, suffixes,
  /// and parameters to use for the current proxy request to service.
  /// For example, the whole request URL is
  /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
  /// Path is _search?q=user:kimchy.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get path => $_getSZ(0);
  @$pb.TagNumber(1)
  set path($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearPath() => clearField(1);
}

/// ServiceSpec describes the attributes that a user creates on a service.
class ServiceSpec extends $pb.GeneratedMessage {
  factory ServiceSpec({
    $core.Iterable<ServicePort>? ports,
    $core.Map<$core.String, $core.String>? selector,
    $core.String? clusterIP,
    $core.String? type,
    $core.Iterable<$core.String>? externalIPs,
    $core.String? sessionAffinity,
    $core.String? loadBalancerIP,
    $core.Iterable<$core.String>? loadBalancerSourceRanges,
    $core.String? externalName,
    $core.String? externalTrafficPolicy,
    $core.int? healthCheckNodePort,
    $core.bool? publishNotReadyAddresses,
    SessionAffinityConfig? sessionAffinityConfig,
    $core.String? ipFamilyPolicy,
    $core.Iterable<$core.String>? clusterIPs,
    $core.Iterable<$core.String>? ipFamilies,
    $core.bool? allocateLoadBalancerNodePorts,
    $core.String? loadBalancerClass,
    $core.String? internalTrafficPolicy,
    $core.String? trafficDistribution,
  }) {
    final $result = create();
    if (ports != null) {
      $result.ports.addAll(ports);
    }
    if (selector != null) {
      $result.selector.addAll(selector);
    }
    if (clusterIP != null) {
      $result.clusterIP = clusterIP;
    }
    if (type != null) {
      $result.type = type;
    }
    if (externalIPs != null) {
      $result.externalIPs.addAll(externalIPs);
    }
    if (sessionAffinity != null) {
      $result.sessionAffinity = sessionAffinity;
    }
    if (loadBalancerIP != null) {
      $result.loadBalancerIP = loadBalancerIP;
    }
    if (loadBalancerSourceRanges != null) {
      $result.loadBalancerSourceRanges.addAll(loadBalancerSourceRanges);
    }
    if (externalName != null) {
      $result.externalName = externalName;
    }
    if (externalTrafficPolicy != null) {
      $result.externalTrafficPolicy = externalTrafficPolicy;
    }
    if (healthCheckNodePort != null) {
      $result.healthCheckNodePort = healthCheckNodePort;
    }
    if (publishNotReadyAddresses != null) {
      $result.publishNotReadyAddresses = publishNotReadyAddresses;
    }
    if (sessionAffinityConfig != null) {
      $result.sessionAffinityConfig = sessionAffinityConfig;
    }
    if (ipFamilyPolicy != null) {
      $result.ipFamilyPolicy = ipFamilyPolicy;
    }
    if (clusterIPs != null) {
      $result.clusterIPs.addAll(clusterIPs);
    }
    if (ipFamilies != null) {
      $result.ipFamilies.addAll(ipFamilies);
    }
    if (allocateLoadBalancerNodePorts != null) {
      $result.allocateLoadBalancerNodePorts = allocateLoadBalancerNodePorts;
    }
    if (loadBalancerClass != null) {
      $result.loadBalancerClass = loadBalancerClass;
    }
    if (internalTrafficPolicy != null) {
      $result.internalTrafficPolicy = internalTrafficPolicy;
    }
    if (trafficDistribution != null) {
      $result.trafficDistribution = trafficDistribution;
    }
    return $result;
  }
  ServiceSpec._() : super();
  factory ServiceSpec.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceSpec.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceSpec', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<ServicePort>(1, _omitFieldNames ? '' : 'ports', $pb.PbFieldType.PM, subBuilder: ServicePort.create)
    ..m<$core.String, $core.String>(2, _omitFieldNames ? '' : 'selector', entryClassName: 'ServiceSpec.SelectorEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('api.core.v1'))
    ..aOS(3, _omitFieldNames ? '' : 'clusterIP', protoName: 'clusterIP')
    ..aOS(4, _omitFieldNames ? '' : 'type')
    ..pPS(5, _omitFieldNames ? '' : 'externalIPs', protoName: 'externalIPs')
    ..aOS(7, _omitFieldNames ? '' : 'sessionAffinity', protoName: 'sessionAffinity')
    ..aOS(8, _omitFieldNames ? '' : 'loadBalancerIP', protoName: 'loadBalancerIP')
    ..pPS(9, _omitFieldNames ? '' : 'loadBalancerSourceRanges', protoName: 'loadBalancerSourceRanges')
    ..aOS(10, _omitFieldNames ? '' : 'externalName', protoName: 'externalName')
    ..aOS(11, _omitFieldNames ? '' : 'externalTrafficPolicy', protoName: 'externalTrafficPolicy')
    ..a<$core.int>(12, _omitFieldNames ? '' : 'healthCheckNodePort', $pb.PbFieldType.O3, protoName: 'healthCheckNodePort')
    ..aOB(13, _omitFieldNames ? '' : 'publishNotReadyAddresses', protoName: 'publishNotReadyAddresses')
    ..aOM<SessionAffinityConfig>(14, _omitFieldNames ? '' : 'sessionAffinityConfig', protoName: 'sessionAffinityConfig', subBuilder: SessionAffinityConfig.create)
    ..aOS(17, _omitFieldNames ? '' : 'ipFamilyPolicy', protoName: 'ipFamilyPolicy')
    ..pPS(18, _omitFieldNames ? '' : 'clusterIPs', protoName: 'clusterIPs')
    ..pPS(19, _omitFieldNames ? '' : 'ipFamilies', protoName: 'ipFamilies')
    ..aOB(20, _omitFieldNames ? '' : 'allocateLoadBalancerNodePorts', protoName: 'allocateLoadBalancerNodePorts')
    ..aOS(21, _omitFieldNames ? '' : 'loadBalancerClass', protoName: 'loadBalancerClass')
    ..aOS(22, _omitFieldNames ? '' : 'internalTrafficPolicy', protoName: 'internalTrafficPolicy')
    ..aOS(23, _omitFieldNames ? '' : 'trafficDistribution', protoName: 'trafficDistribution')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceSpec clone() => ServiceSpec()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceSpec copyWith(void Function(ServiceSpec) updates) => super.copyWith((message) => updates(message as ServiceSpec)) as ServiceSpec;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceSpec create() => ServiceSpec._();
  ServiceSpec createEmptyInstance() => create();
  static $pb.PbList<ServiceSpec> createRepeated() => $pb.PbList<ServiceSpec>();
  @$core.pragma('dart2js:noInline')
  static ServiceSpec getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceSpec>(create);
  static ServiceSpec? _defaultInstance;

  /// The list of ports that are exposed by this service.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +patchMergeKey=port
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=port
  /// +listMapKey=protocol
  @$pb.TagNumber(1)
  $core.List<ServicePort> get ports => $_getList(0);

  /// Route service traffic to pods with label keys and values matching this
  /// selector. If empty or not present, the service is assumed to have an
  /// external process managing its endpoints, which Kubernetes will not
  /// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
  /// Ignored if type is ExternalName.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
  /// +optional
  /// +mapType=atomic
  @$pb.TagNumber(2)
  $core.Map<$core.String, $core.String> get selector => $_getMap(1);

  /// clusterIP is the IP address of the service and is usually assigned
  /// randomly. If an address is specified manually, is in-range (as per
  /// system configuration), and is not in use, it will be allocated to the
  /// service; otherwise creation of the service will fail. This field may not
  /// be changed through updates unless the type field is also being changed
  /// to ExternalName (which requires this field to be blank) or the type
  /// field is being changed from ExternalName (in which case this field may
  /// optionally be specified, as describe above).  Valid values are "None",
  /// empty string (""), or a valid IP address. Setting this to "None" makes a
  /// "headless service" (no virtual IP), which is useful when direct endpoint
  /// connections are preferred and proxying is not required.  Only applies to
  /// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
  /// when creating a Service of type ExternalName, creation will fail. This
  /// field will be wiped when updating a Service to type ExternalName.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +optional
  @$pb.TagNumber(3)
  $core.String get clusterIP => $_getSZ(2);
  @$pb.TagNumber(3)
  set clusterIP($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasClusterIP() => $_has(2);
  @$pb.TagNumber(3)
  void clearClusterIP() => clearField(3);

  /// type determines how the Service is exposed. Defaults to ClusterIP. Valid
  /// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  /// "ClusterIP" allocates a cluster-internal IP address for load-balancing
  /// to endpoints. Endpoints are determined by the selector or if that is not
  /// specified, by manual construction of an Endpoints object or
  /// EndpointSlice objects. If clusterIP is "None", no virtual IP is
  /// allocated and the endpoints are published as a set of endpoints rather
  /// than a virtual IP.
  /// "NodePort" builds on ClusterIP and allocates a port on every node which
  /// routes to the same endpoints as the clusterIP.
  /// "LoadBalancer" builds on NodePort and creates an external load-balancer
  /// (if supported in the current cloud) which routes to the same endpoints
  /// as the clusterIP.
  /// "ExternalName" aliases this service to the specified externalName.
  /// Several other fields do not apply to ExternalName services.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  /// +optional
  @$pb.TagNumber(4)
  $core.String get type => $_getSZ(3);
  @$pb.TagNumber(4)
  set type($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasType() => $_has(3);
  @$pb.TagNumber(4)
  void clearType() => clearField(4);

  /// externalIPs is a list of IP addresses for which nodes in the cluster
  /// will also accept traffic for this service.  These IPs are not managed by
  /// Kubernetes.  The user is responsible for ensuring that traffic arrives
  /// at a node with this IP.  A common example is external load-balancers
  /// that are not part of the Kubernetes system.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(5)
  $core.List<$core.String> get externalIPs => $_getList(4);

  /// Supports "ClientIP" and "None". Used to maintain session affinity.
  /// Enable client IP based session affinity.
  /// Must be ClientIP or None.
  /// Defaults to None.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +optional
  @$pb.TagNumber(7)
  $core.String get sessionAffinity => $_getSZ(5);
  @$pb.TagNumber(7)
  set sessionAffinity($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(7)
  $core.bool hasSessionAffinity() => $_has(5);
  @$pb.TagNumber(7)
  void clearSessionAffinity() => clearField(7);

  /// Only applies to Service Type: LoadBalancer.
  /// This feature depends on whether the underlying cloud-provider supports specifying
  /// the loadBalancerIP when a load balancer is created.
  /// This field will be ignored if the cloud-provider does not support the feature.
  /// Deprecated: This field was under-specified and its meaning varies across implementations.
  /// Using it is non-portable and it may not support dual-stack.
  /// Users are encouraged to use implementation-specific annotations when available.
  /// +optional
  @$pb.TagNumber(8)
  $core.String get loadBalancerIP => $_getSZ(6);
  @$pb.TagNumber(8)
  set loadBalancerIP($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(8)
  $core.bool hasLoadBalancerIP() => $_has(6);
  @$pb.TagNumber(8)
  void clearLoadBalancerIP() => clearField(8);

  /// If specified and supported by the platform, this will restrict traffic through the cloud-provider
  /// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
  /// cloud-provider does not support the feature."
  /// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(9)
  $core.List<$core.String> get loadBalancerSourceRanges => $_getList(7);

  /// externalName is the external reference that discovery mechanisms will
  /// return as an alias for this service (e.g. a DNS CNAME record). No
  /// proxying will be involved.  Must be a lowercase RFC-1123 hostname
  /// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
  /// +optional
  @$pb.TagNumber(10)
  $core.String get externalName => $_getSZ(8);
  @$pb.TagNumber(10)
  set externalName($core.String v) { $_setString(8, v); }
  @$pb.TagNumber(10)
  $core.bool hasExternalName() => $_has(8);
  @$pb.TagNumber(10)
  void clearExternalName() => clearField(10);

  /// externalTrafficPolicy describes how nodes distribute service traffic they
  /// receive on one of the Service's "externally-facing" addresses (NodePorts,
  /// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
  /// the service in a way that assumes that external load balancers will take care
  /// of balancing the service traffic between nodes, and so each node will deliver
  /// traffic only to the node-local endpoints of the service, without masquerading
  /// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
  /// be dropped.) The default value, "Cluster", uses the standard behavior of
  /// routing to all endpoints evenly (possibly modified by topology and other
  /// features). Note that traffic sent to an External IP or LoadBalancer IP from
  /// within the cluster will always get "Cluster" semantics, but clients sending to
  /// a NodePort from within the cluster may need to take traffic policy into account
  /// when picking a node.
  /// +optional
  @$pb.TagNumber(11)
  $core.String get externalTrafficPolicy => $_getSZ(9);
  @$pb.TagNumber(11)
  set externalTrafficPolicy($core.String v) { $_setString(9, v); }
  @$pb.TagNumber(11)
  $core.bool hasExternalTrafficPolicy() => $_has(9);
  @$pb.TagNumber(11)
  void clearExternalTrafficPolicy() => clearField(11);

  /// healthCheckNodePort specifies the healthcheck nodePort for the service.
  /// This only applies when type is set to LoadBalancer and
  /// externalTrafficPolicy is set to Local. If a value is specified, is
  /// in-range, and is not in use, it will be used.  If not specified, a value
  /// will be automatically allocated.  External systems (e.g. load-balancers)
  /// can use this port to determine if a given node holds endpoints for this
  /// service or not.  If this field is specified when creating a Service
  /// which does not need it, creation will fail. This field will be wiped
  /// when updating a Service to no longer need it (e.g. changing type).
  /// This field cannot be updated once set.
  /// +optional
  @$pb.TagNumber(12)
  $core.int get healthCheckNodePort => $_getIZ(10);
  @$pb.TagNumber(12)
  set healthCheckNodePort($core.int v) { $_setSignedInt32(10, v); }
  @$pb.TagNumber(12)
  $core.bool hasHealthCheckNodePort() => $_has(10);
  @$pb.TagNumber(12)
  void clearHealthCheckNodePort() => clearField(12);

  /// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
  /// Service should disregard any indications of ready/not-ready.
  /// The primary use case for setting this field is for a StatefulSet's Headless Service to
  /// propagate SRV DNS records for its Pods for the purpose of peer discovery.
  /// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
  /// Services interpret this to mean that all endpoints are considered "ready" even if the
  /// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
  /// through the Endpoints or EndpointSlice resources can safely assume this behavior.
  /// +optional
  @$pb.TagNumber(13)
  $core.bool get publishNotReadyAddresses => $_getBF(11);
  @$pb.TagNumber(13)
  set publishNotReadyAddresses($core.bool v) { $_setBool(11, v); }
  @$pb.TagNumber(13)
  $core.bool hasPublishNotReadyAddresses() => $_has(11);
  @$pb.TagNumber(13)
  void clearPublishNotReadyAddresses() => clearField(13);

  /// sessionAffinityConfig contains the configurations of session affinity.
  /// +optional
  @$pb.TagNumber(14)
  SessionAffinityConfig get sessionAffinityConfig => $_getN(12);
  @$pb.TagNumber(14)
  set sessionAffinityConfig(SessionAffinityConfig v) { setField(14, v); }
  @$pb.TagNumber(14)
  $core.bool hasSessionAffinityConfig() => $_has(12);
  @$pb.TagNumber(14)
  void clearSessionAffinityConfig() => clearField(14);
  @$pb.TagNumber(14)
  SessionAffinityConfig ensureSessionAffinityConfig() => $_ensure(12);

  /// IPFamilyPolicy represents the dual-stack-ness requested or required by
  /// this Service. If there is no value provided, then this field will be set
  /// to SingleStack. Services can be "SingleStack" (a single IP family),
  /// "PreferDualStack" (two IP families on dual-stack configured clusters or
  /// a single IP family on single-stack clusters), or "RequireDualStack"
  /// (two IP families on dual-stack configured clusters, otherwise fail). The
  /// ipFamilies and clusterIPs fields depend on the value of this field. This
  /// field will be wiped when updating a service to type ExternalName.
  /// +optional
  @$pb.TagNumber(17)
  $core.String get ipFamilyPolicy => $_getSZ(13);
  @$pb.TagNumber(17)
  set ipFamilyPolicy($core.String v) { $_setString(13, v); }
  @$pb.TagNumber(17)
  $core.bool hasIpFamilyPolicy() => $_has(13);
  @$pb.TagNumber(17)
  void clearIpFamilyPolicy() => clearField(17);

  ///  ClusterIPs is a list of IP addresses assigned to this service, and are
  ///  usually assigned randomly.  If an address is specified manually, is
  ///  in-range (as per system configuration), and is not in use, it will be
  ///  allocated to the service; otherwise creation of the service will fail.
  ///  This field may not be changed through updates unless the type field is
  ///  also being changed to ExternalName (which requires this field to be
  ///  empty) or the type field is being changed from ExternalName (in which
  ///  case this field may optionally be specified, as describe above).  Valid
  ///  values are "None", empty string (""), or a valid IP address.  Setting
  ///  this to "None" makes a "headless service" (no virtual IP), which is
  ///  useful when direct endpoint connections are preferred and proxying is
  ///  not required.  Only applies to types ClusterIP, NodePort, and
  ///  LoadBalancer. If this field is specified when creating a Service of type
  ///  ExternalName, creation will fail. This field will be wiped when updating
  ///  a Service to type ExternalName.  If this field is not specified, it will
  ///  be initialized from the clusterIP field.  If this field is specified,
  ///  clients must ensure that clusterIPs[0] and clusterIP have the same
  ///  value.
  ///
  ///  This field may hold a maximum of two entries (dual-stack IPs, in either order).
  ///  These IPs must correspond to the values of the ipFamilies field. Both
  ///  clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
  ///  More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  ///  +listType=atomic
  ///  +optional
  @$pb.TagNumber(18)
  $core.List<$core.String> get clusterIPs => $_getList(14);

  ///  IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
  ///  service. This field is usually assigned automatically based on cluster
  ///  configuration and the ipFamilyPolicy field. If this field is specified
  ///  manually, the requested family is available in the cluster,
  ///  and ipFamilyPolicy allows it, it will be used; otherwise creation of
  ///  the service will fail. This field is conditionally mutable: it allows
  ///  for adding or removing a secondary IP family, but it does not allow
  ///  changing the primary IP family of the Service. Valid values are "IPv4"
  ///  and "IPv6".  This field only applies to Services of types ClusterIP,
  ///  NodePort, and LoadBalancer, and does apply to "headless" services.
  ///  This field will be wiped when updating a Service to type ExternalName.
  ///
  ///  This field may hold a maximum of two entries (dual-stack families, in
  ///  either order).  These families must correspond to the values of the
  ///  clusterIPs field, if specified. Both clusterIPs and ipFamilies are
  ///  governed by the ipFamilyPolicy field.
  ///  +listType=atomic
  ///  +optional
  @$pb.TagNumber(19)
  $core.List<$core.String> get ipFamilies => $_getList(15);

  /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
  /// allocated for services with type LoadBalancer.  Default is "true". It
  /// may be set to "false" if the cluster load-balancer does not rely on
  /// NodePorts.  If the caller requests specific NodePorts (by specifying a
  /// value), those requests will be respected, regardless of this field.
  /// This field may only be set for services with type LoadBalancer and will
  /// be cleared if the type is changed to any other type.
  /// +optional
  @$pb.TagNumber(20)
  $core.bool get allocateLoadBalancerNodePorts => $_getBF(16);
  @$pb.TagNumber(20)
  set allocateLoadBalancerNodePorts($core.bool v) { $_setBool(16, v); }
  @$pb.TagNumber(20)
  $core.bool hasAllocateLoadBalancerNodePorts() => $_has(16);
  @$pb.TagNumber(20)
  void clearAllocateLoadBalancerNodePorts() => clearField(20);

  /// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
  /// If specified, the value of this field must be a label-style identifier, with an optional prefix,
  /// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
  /// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
  /// balancer implementation is used, today this is typically done through the cloud provider integration,
  /// but should apply for any default implementation. If set, it is assumed that a load balancer
  /// implementation is watching for Services with a matching class. Any default load balancer
  /// implementation (e.g. cloud providers) should ignore Services that set this field.
  /// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
  /// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
  /// +optional
  @$pb.TagNumber(21)
  $core.String get loadBalancerClass => $_getSZ(17);
  @$pb.TagNumber(21)
  set loadBalancerClass($core.String v) { $_setString(17, v); }
  @$pb.TagNumber(21)
  $core.bool hasLoadBalancerClass() => $_has(17);
  @$pb.TagNumber(21)
  void clearLoadBalancerClass() => clearField(21);

  /// InternalTrafficPolicy describes how nodes distribute service traffic they
  /// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
  /// only want to talk to endpoints of the service on the same node as the pod,
  /// dropping the traffic if there are no local endpoints. The default value,
  /// "Cluster", uses the standard behavior of routing to all endpoints evenly
  /// (possibly modified by topology and other features).
  /// +optional
  @$pb.TagNumber(22)
  $core.String get internalTrafficPolicy => $_getSZ(18);
  @$pb.TagNumber(22)
  set internalTrafficPolicy($core.String v) { $_setString(18, v); }
  @$pb.TagNumber(22)
  $core.bool hasInternalTrafficPolicy() => $_has(18);
  @$pb.TagNumber(22)
  void clearInternalTrafficPolicy() => clearField(22);

  /// TrafficDistribution offers a way to express preferences for how traffic is
  /// distributed to Service endpoints. Implementations can use this field as a
  /// hint, but are not required to guarantee strict adherence. If the field is
  /// not set, the implementation will apply its default routing strategy. If set
  /// to "PreferClose", implementations should prioritize endpoints that are
  /// topologically close (e.g., same zone).
  /// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
  /// +featureGate=ServiceTrafficDistribution
  /// +optional
  @$pb.TagNumber(23)
  $core.String get trafficDistribution => $_getSZ(19);
  @$pb.TagNumber(23)
  set trafficDistribution($core.String v) { $_setString(19, v); }
  @$pb.TagNumber(23)
  $core.bool hasTrafficDistribution() => $_has(19);
  @$pb.TagNumber(23)
  void clearTrafficDistribution() => clearField(23);
}

/// ServiceStatus represents the current status of a service.
class ServiceStatus extends $pb.GeneratedMessage {
  factory ServiceStatus({
    LoadBalancerStatus? loadBalancer,
    $core.Iterable<$0.Condition>? conditions,
  }) {
    final $result = create();
    if (loadBalancer != null) {
      $result.loadBalancer = loadBalancer;
    }
    if (conditions != null) {
      $result.conditions.addAll(conditions);
    }
    return $result;
  }
  ServiceStatus._() : super();
  factory ServiceStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ServiceStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'ServiceStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<LoadBalancerStatus>(1, _omitFieldNames ? '' : 'loadBalancer', protoName: 'loadBalancer', subBuilder: LoadBalancerStatus.create)
    ..pc<$0.Condition>(2, _omitFieldNames ? '' : 'conditions', $pb.PbFieldType.PM, subBuilder: $0.Condition.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ServiceStatus clone() => ServiceStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ServiceStatus copyWith(void Function(ServiceStatus) updates) => super.copyWith((message) => updates(message as ServiceStatus)) as ServiceStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static ServiceStatus create() => ServiceStatus._();
  ServiceStatus createEmptyInstance() => create();
  static $pb.PbList<ServiceStatus> createRepeated() => $pb.PbList<ServiceStatus>();
  @$core.pragma('dart2js:noInline')
  static ServiceStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ServiceStatus>(create);
  static ServiceStatus? _defaultInstance;

  /// LoadBalancer contains the current status of the load-balancer,
  /// if one is present.
  /// +optional
  @$pb.TagNumber(1)
  LoadBalancerStatus get loadBalancer => $_getN(0);
  @$pb.TagNumber(1)
  set loadBalancer(LoadBalancerStatus v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasLoadBalancer() => $_has(0);
  @$pb.TagNumber(1)
  void clearLoadBalancer() => clearField(1);
  @$pb.TagNumber(1)
  LoadBalancerStatus ensureLoadBalancer() => $_ensure(0);

  /// Current service state
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=type
  @$pb.TagNumber(2)
  $core.List<$0.Condition> get conditions => $_getList(1);
}

/// SessionAffinityConfig represents the configurations of session affinity.
class SessionAffinityConfig extends $pb.GeneratedMessage {
  factory SessionAffinityConfig({
    ClientIPConfig? clientIP,
  }) {
    final $result = create();
    if (clientIP != null) {
      $result.clientIP = clientIP;
    }
    return $result;
  }
  SessionAffinityConfig._() : super();
  factory SessionAffinityConfig.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SessionAffinityConfig.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SessionAffinityConfig', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<ClientIPConfig>(1, _omitFieldNames ? '' : 'clientIP', protoName: 'clientIP', subBuilder: ClientIPConfig.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SessionAffinityConfig clone() => SessionAffinityConfig()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SessionAffinityConfig copyWith(void Function(SessionAffinityConfig) updates) => super.copyWith((message) => updates(message as SessionAffinityConfig)) as SessionAffinityConfig;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SessionAffinityConfig create() => SessionAffinityConfig._();
  SessionAffinityConfig createEmptyInstance() => create();
  static $pb.PbList<SessionAffinityConfig> createRepeated() => $pb.PbList<SessionAffinityConfig>();
  @$core.pragma('dart2js:noInline')
  static SessionAffinityConfig getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SessionAffinityConfig>(create);
  static SessionAffinityConfig? _defaultInstance;

  /// clientIP contains the configurations of Client IP based session affinity.
  /// +optional
  @$pb.TagNumber(1)
  ClientIPConfig get clientIP => $_getN(0);
  @$pb.TagNumber(1)
  set clientIP(ClientIPConfig v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasClientIP() => $_has(0);
  @$pb.TagNumber(1)
  void clearClientIP() => clearField(1);
  @$pb.TagNumber(1)
  ClientIPConfig ensureClientIP() => $_ensure(0);
}

/// SleepAction describes a "sleep" action.
class SleepAction extends $pb.GeneratedMessage {
  factory SleepAction({
    $fixnum.Int64? seconds,
  }) {
    final $result = create();
    if (seconds != null) {
      $result.seconds = seconds;
    }
    return $result;
  }
  SleepAction._() : super();
  factory SleepAction.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory SleepAction.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'SleepAction', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aInt64(1, _omitFieldNames ? '' : 'seconds')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  SleepAction clone() => SleepAction()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  SleepAction copyWith(void Function(SleepAction) updates) => super.copyWith((message) => updates(message as SleepAction)) as SleepAction;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static SleepAction create() => SleepAction._();
  SleepAction createEmptyInstance() => create();
  static $pb.PbList<SleepAction> createRepeated() => $pb.PbList<SleepAction>();
  @$core.pragma('dart2js:noInline')
  static SleepAction getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<SleepAction>(create);
  static SleepAction? _defaultInstance;

  /// Seconds is the number of seconds to sleep.
  @$pb.TagNumber(1)
  $fixnum.Int64 get seconds => $_getI64(0);
  @$pb.TagNumber(1)
  set seconds($fixnum.Int64 v) { $_setInt64(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasSeconds() => $_has(0);
  @$pb.TagNumber(1)
  void clearSeconds() => clearField(1);
}

/// Represents a StorageOS persistent volume resource.
class StorageOSPersistentVolumeSource extends $pb.GeneratedMessage {
  factory StorageOSPersistentVolumeSource({
    $core.String? volumeName,
    $core.String? volumeNamespace,
    $core.String? fsType,
    $core.bool? readOnly,
    ObjectReference? secretRef,
  }) {
    final $result = create();
    if (volumeName != null) {
      $result.volumeName = volumeName;
    }
    if (volumeNamespace != null) {
      $result.volumeNamespace = volumeNamespace;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    return $result;
  }
  StorageOSPersistentVolumeSource._() : super();
  factory StorageOSPersistentVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory StorageOSPersistentVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'StorageOSPersistentVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeName', protoName: 'volumeName')
    ..aOS(2, _omitFieldNames ? '' : 'volumeNamespace', protoName: 'volumeNamespace')
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOM<ObjectReference>(5, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: ObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  StorageOSPersistentVolumeSource clone() => StorageOSPersistentVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  StorageOSPersistentVolumeSource copyWith(void Function(StorageOSPersistentVolumeSource) updates) => super.copyWith((message) => updates(message as StorageOSPersistentVolumeSource)) as StorageOSPersistentVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static StorageOSPersistentVolumeSource create() => StorageOSPersistentVolumeSource._();
  StorageOSPersistentVolumeSource createEmptyInstance() => create();
  static $pb.PbList<StorageOSPersistentVolumeSource> createRepeated() => $pb.PbList<StorageOSPersistentVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static StorageOSPersistentVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<StorageOSPersistentVolumeSource>(create);
  static StorageOSPersistentVolumeSource? _defaultInstance;

  /// volumeName is the human-readable name of the StorageOS volume.  Volume
  /// names are only unique within a namespace.
  @$pb.TagNumber(1)
  $core.String get volumeName => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeName() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeName() => clearField(1);

  /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
  /// namespace is specified then the Pod's namespace will be used.  This allows the
  /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  /// Set VolumeName to any name to override the default behaviour.
  /// Set to "default" if you are not using namespaces within StorageOS.
  /// Namespaces that do not pre-exist within StorageOS will be created.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get volumeNamespace => $_getSZ(1);
  @$pb.TagNumber(2)
  set volumeNamespace($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasVolumeNamespace() => $_has(1);
  @$pb.TagNumber(2)
  void clearVolumeNamespace() => clearField(2);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);

  /// secretRef specifies the secret to use for obtaining the StorageOS API
  /// credentials.  If not specified, default values will be attempted.
  /// +optional
  @$pb.TagNumber(5)
  ObjectReference get secretRef => $_getN(4);
  @$pb.TagNumber(5)
  set secretRef(ObjectReference v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSecretRef() => $_has(4);
  @$pb.TagNumber(5)
  void clearSecretRef() => clearField(5);
  @$pb.TagNumber(5)
  ObjectReference ensureSecretRef() => $_ensure(4);
}

/// Represents a StorageOS persistent volume resource.
class StorageOSVolumeSource extends $pb.GeneratedMessage {
  factory StorageOSVolumeSource({
    $core.String? volumeName,
    $core.String? volumeNamespace,
    $core.String? fsType,
    $core.bool? readOnly,
    LocalObjectReference? secretRef,
  }) {
    final $result = create();
    if (volumeName != null) {
      $result.volumeName = volumeName;
    }
    if (volumeNamespace != null) {
      $result.volumeNamespace = volumeNamespace;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (secretRef != null) {
      $result.secretRef = secretRef;
    }
    return $result;
  }
  StorageOSVolumeSource._() : super();
  factory StorageOSVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory StorageOSVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'StorageOSVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumeName', protoName: 'volumeName')
    ..aOS(2, _omitFieldNames ? '' : 'volumeNamespace', protoName: 'volumeNamespace')
    ..aOS(3, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOB(4, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOM<LocalObjectReference>(5, _omitFieldNames ? '' : 'secretRef', protoName: 'secretRef', subBuilder: LocalObjectReference.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  StorageOSVolumeSource clone() => StorageOSVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  StorageOSVolumeSource copyWith(void Function(StorageOSVolumeSource) updates) => super.copyWith((message) => updates(message as StorageOSVolumeSource)) as StorageOSVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static StorageOSVolumeSource create() => StorageOSVolumeSource._();
  StorageOSVolumeSource createEmptyInstance() => create();
  static $pb.PbList<StorageOSVolumeSource> createRepeated() => $pb.PbList<StorageOSVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static StorageOSVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<StorageOSVolumeSource>(create);
  static StorageOSVolumeSource? _defaultInstance;

  /// volumeName is the human-readable name of the StorageOS volume.  Volume
  /// names are only unique within a namespace.
  @$pb.TagNumber(1)
  $core.String get volumeName => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumeName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumeName() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumeName() => clearField(1);

  /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
  /// namespace is specified then the Pod's namespace will be used.  This allows the
  /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  /// Set VolumeName to any name to override the default behaviour.
  /// Set to "default" if you are not using namespaces within StorageOS.
  /// Namespaces that do not pre-exist within StorageOS will be created.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get volumeNamespace => $_getSZ(1);
  @$pb.TagNumber(2)
  set volumeNamespace($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasVolumeNamespace() => $_has(1);
  @$pb.TagNumber(2)
  void clearVolumeNamespace() => clearField(2);

  /// fsType is the filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get fsType => $_getSZ(2);
  @$pb.TagNumber(3)
  set fsType($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasFsType() => $_has(2);
  @$pb.TagNumber(3)
  void clearFsType() => clearField(3);

  /// readOnly defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get readOnly => $_getBF(3);
  @$pb.TagNumber(4)
  set readOnly($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearReadOnly() => clearField(4);

  /// secretRef specifies the secret to use for obtaining the StorageOS API
  /// credentials.  If not specified, default values will be attempted.
  /// +optional
  @$pb.TagNumber(5)
  LocalObjectReference get secretRef => $_getN(4);
  @$pb.TagNumber(5)
  set secretRef(LocalObjectReference v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasSecretRef() => $_has(4);
  @$pb.TagNumber(5)
  void clearSecretRef() => clearField(5);
  @$pb.TagNumber(5)
  LocalObjectReference ensureSecretRef() => $_ensure(4);
}

/// Sysctl defines a kernel parameter to be set
class Sysctl extends $pb.GeneratedMessage {
  factory Sysctl({
    $core.String? name,
    $core.String? value,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (value != null) {
      $result.value = value;
    }
    return $result;
  }
  Sysctl._() : super();
  factory Sysctl.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Sysctl.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Sysctl', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'value')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Sysctl clone() => Sysctl()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Sysctl copyWith(void Function(Sysctl) updates) => super.copyWith((message) => updates(message as Sysctl)) as Sysctl;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Sysctl create() => Sysctl._();
  Sysctl createEmptyInstance() => create();
  static $pb.PbList<Sysctl> createRepeated() => $pb.PbList<Sysctl>();
  @$core.pragma('dart2js:noInline')
  static Sysctl getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Sysctl>(create);
  static Sysctl? _defaultInstance;

  /// Name of a property to set
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Value of a property to set
  @$pb.TagNumber(2)
  $core.String get value => $_getSZ(1);
  @$pb.TagNumber(2)
  set value($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasValue() => $_has(1);
  @$pb.TagNumber(2)
  void clearValue() => clearField(2);
}

/// TCPSocketAction describes an action based on opening a socket
class TCPSocketAction extends $pb.GeneratedMessage {
  factory TCPSocketAction({
    $2.IntOrString? port,
    $core.String? host,
  }) {
    final $result = create();
    if (port != null) {
      $result.port = port;
    }
    if (host != null) {
      $result.host = host;
    }
    return $result;
  }
  TCPSocketAction._() : super();
  factory TCPSocketAction.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TCPSocketAction.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TCPSocketAction', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<$2.IntOrString>(1, _omitFieldNames ? '' : 'port', subBuilder: $2.IntOrString.create)
    ..aOS(2, _omitFieldNames ? '' : 'host')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TCPSocketAction clone() => TCPSocketAction()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TCPSocketAction copyWith(void Function(TCPSocketAction) updates) => super.copyWith((message) => updates(message as TCPSocketAction)) as TCPSocketAction;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TCPSocketAction create() => TCPSocketAction._();
  TCPSocketAction createEmptyInstance() => create();
  static $pb.PbList<TCPSocketAction> createRepeated() => $pb.PbList<TCPSocketAction>();
  @$core.pragma('dart2js:noInline')
  static TCPSocketAction getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TCPSocketAction>(create);
  static TCPSocketAction? _defaultInstance;

  /// Number or name of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  /// Name must be an IANA_SVC_NAME.
  @$pb.TagNumber(1)
  $2.IntOrString get port => $_getN(0);
  @$pb.TagNumber(1)
  set port($2.IntOrString v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasPort() => $_has(0);
  @$pb.TagNumber(1)
  void clearPort() => clearField(1);
  @$pb.TagNumber(1)
  $2.IntOrString ensurePort() => $_ensure(0);

  /// Optional: Host name to connect to, defaults to the pod IP.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get host => $_getSZ(1);
  @$pb.TagNumber(2)
  set host($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasHost() => $_has(1);
  @$pb.TagNumber(2)
  void clearHost() => clearField(2);
}

/// The node this Taint is attached to has the "effect" on
/// any pod that does not tolerate the Taint.
class Taint extends $pb.GeneratedMessage {
  factory Taint({
    $core.String? key,
    $core.String? value,
    $core.String? effect,
    $0.Time? timeAdded,
  }) {
    final $result = create();
    if (key != null) {
      $result.key = key;
    }
    if (value != null) {
      $result.value = value;
    }
    if (effect != null) {
      $result.effect = effect;
    }
    if (timeAdded != null) {
      $result.timeAdded = timeAdded;
    }
    return $result;
  }
  Taint._() : super();
  factory Taint.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Taint.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Taint', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'key')
    ..aOS(2, _omitFieldNames ? '' : 'value')
    ..aOS(3, _omitFieldNames ? '' : 'effect')
    ..aOM<$0.Time>(4, _omitFieldNames ? '' : 'timeAdded', protoName: 'timeAdded', subBuilder: $0.Time.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Taint clone() => Taint()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Taint copyWith(void Function(Taint) updates) => super.copyWith((message) => updates(message as Taint)) as Taint;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Taint create() => Taint._();
  Taint createEmptyInstance() => create();
  static $pb.PbList<Taint> createRepeated() => $pb.PbList<Taint>();
  @$core.pragma('dart2js:noInline')
  static Taint getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Taint>(create);
  static Taint? _defaultInstance;

  /// Required. The taint key to be applied to a node.
  @$pb.TagNumber(1)
  $core.String get key => $_getSZ(0);
  @$pb.TagNumber(1)
  set key($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKey() => $_has(0);
  @$pb.TagNumber(1)
  void clearKey() => clearField(1);

  /// The taint value corresponding to the taint key.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get value => $_getSZ(1);
  @$pb.TagNumber(2)
  set value($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasValue() => $_has(1);
  @$pb.TagNumber(2)
  void clearValue() => clearField(2);

  /// Required. The effect of the taint on pods
  /// that do not tolerate the taint.
  /// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
  @$pb.TagNumber(3)
  $core.String get effect => $_getSZ(2);
  @$pb.TagNumber(3)
  set effect($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasEffect() => $_has(2);
  @$pb.TagNumber(3)
  void clearEffect() => clearField(3);

  /// TimeAdded represents the time at which the taint was added.
  /// It is only written for NoExecute taints.
  /// +optional
  @$pb.TagNumber(4)
  $0.Time get timeAdded => $_getN(3);
  @$pb.TagNumber(4)
  set timeAdded($0.Time v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasTimeAdded() => $_has(3);
  @$pb.TagNumber(4)
  void clearTimeAdded() => clearField(4);
  @$pb.TagNumber(4)
  $0.Time ensureTimeAdded() => $_ensure(3);
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
class Toleration extends $pb.GeneratedMessage {
  factory Toleration({
    $core.String? key,
    $core.String? operator,
    $core.String? value,
    $core.String? effect,
    $fixnum.Int64? tolerationSeconds,
  }) {
    final $result = create();
    if (key != null) {
      $result.key = key;
    }
    if (operator != null) {
      $result.operator = operator;
    }
    if (value != null) {
      $result.value = value;
    }
    if (effect != null) {
      $result.effect = effect;
    }
    if (tolerationSeconds != null) {
      $result.tolerationSeconds = tolerationSeconds;
    }
    return $result;
  }
  Toleration._() : super();
  factory Toleration.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Toleration.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Toleration', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'key')
    ..aOS(2, _omitFieldNames ? '' : 'operator')
    ..aOS(3, _omitFieldNames ? '' : 'value')
    ..aOS(4, _omitFieldNames ? '' : 'effect')
    ..aInt64(5, _omitFieldNames ? '' : 'tolerationSeconds', protoName: 'tolerationSeconds')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Toleration clone() => Toleration()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Toleration copyWith(void Function(Toleration) updates) => super.copyWith((message) => updates(message as Toleration)) as Toleration;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Toleration create() => Toleration._();
  Toleration createEmptyInstance() => create();
  static $pb.PbList<Toleration> createRepeated() => $pb.PbList<Toleration>();
  @$core.pragma('dart2js:noInline')
  static Toleration getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Toleration>(create);
  static Toleration? _defaultInstance;

  /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
  /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get key => $_getSZ(0);
  @$pb.TagNumber(1)
  set key($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKey() => $_has(0);
  @$pb.TagNumber(1)
  void clearKey() => clearField(1);

  /// Operator represents a key's relationship to the value.
  /// Valid operators are Exists and Equal. Defaults to Equal.
  /// Exists is equivalent to wildcard for value, so that a pod can
  /// tolerate all taints of a particular category.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get operator => $_getSZ(1);
  @$pb.TagNumber(2)
  set operator($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasOperator() => $_has(1);
  @$pb.TagNumber(2)
  void clearOperator() => clearField(2);

  /// Value is the taint value the toleration matches to.
  /// If the operator is Exists, the value should be empty, otherwise just a regular string.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get value => $_getSZ(2);
  @$pb.TagNumber(3)
  set value($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasValue() => $_has(2);
  @$pb.TagNumber(3)
  void clearValue() => clearField(3);

  /// Effect indicates the taint effect to match. Empty means match all taint effects.
  /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get effect => $_getSZ(3);
  @$pb.TagNumber(4)
  set effect($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasEffect() => $_has(3);
  @$pb.TagNumber(4)
  void clearEffect() => clearField(4);

  /// TolerationSeconds represents the period of time the toleration (which must be
  /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  /// it is not set, which means tolerate the taint forever (do not evict). Zero and
  /// negative values will be treated as 0 (evict immediately) by the system.
  /// +optional
  @$pb.TagNumber(5)
  $fixnum.Int64 get tolerationSeconds => $_getI64(4);
  @$pb.TagNumber(5)
  set tolerationSeconds($fixnum.Int64 v) { $_setInt64(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasTolerationSeconds() => $_has(4);
  @$pb.TagNumber(5)
  void clearTolerationSeconds() => clearField(5);
}

/// A topology selector requirement is a selector that matches given label.
/// This is an alpha feature and may change in the future.
class TopologySelectorLabelRequirement extends $pb.GeneratedMessage {
  factory TopologySelectorLabelRequirement({
    $core.String? key,
    $core.Iterable<$core.String>? values,
  }) {
    final $result = create();
    if (key != null) {
      $result.key = key;
    }
    if (values != null) {
      $result.values.addAll(values);
    }
    return $result;
  }
  TopologySelectorLabelRequirement._() : super();
  factory TopologySelectorLabelRequirement.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TopologySelectorLabelRequirement.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TopologySelectorLabelRequirement', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'key')
    ..pPS(2, _omitFieldNames ? '' : 'values')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TopologySelectorLabelRequirement clone() => TopologySelectorLabelRequirement()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TopologySelectorLabelRequirement copyWith(void Function(TopologySelectorLabelRequirement) updates) => super.copyWith((message) => updates(message as TopologySelectorLabelRequirement)) as TopologySelectorLabelRequirement;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TopologySelectorLabelRequirement create() => TopologySelectorLabelRequirement._();
  TopologySelectorLabelRequirement createEmptyInstance() => create();
  static $pb.PbList<TopologySelectorLabelRequirement> createRepeated() => $pb.PbList<TopologySelectorLabelRequirement>();
  @$core.pragma('dart2js:noInline')
  static TopologySelectorLabelRequirement getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TopologySelectorLabelRequirement>(create);
  static TopologySelectorLabelRequirement? _defaultInstance;

  /// The label key that the selector applies to.
  @$pb.TagNumber(1)
  $core.String get key => $_getSZ(0);
  @$pb.TagNumber(1)
  set key($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasKey() => $_has(0);
  @$pb.TagNumber(1)
  void clearKey() => clearField(1);

  /// An array of string values. One value must match the label to be selected.
  /// Each entry in Values is ORed.
  /// +listType=atomic
  @$pb.TagNumber(2)
  $core.List<$core.String> get values => $_getList(1);
}

/// A topology selector term represents the result of label queries.
/// A null or empty topology selector term matches no objects.
/// The requirements of them are ANDed.
/// It provides a subset of functionality as NodeSelectorTerm.
/// This is an alpha feature and may change in the future.
/// +structType=atomic
class TopologySelectorTerm extends $pb.GeneratedMessage {
  factory TopologySelectorTerm({
    $core.Iterable<TopologySelectorLabelRequirement>? matchLabelExpressions,
  }) {
    final $result = create();
    if (matchLabelExpressions != null) {
      $result.matchLabelExpressions.addAll(matchLabelExpressions);
    }
    return $result;
  }
  TopologySelectorTerm._() : super();
  factory TopologySelectorTerm.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TopologySelectorTerm.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TopologySelectorTerm', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..pc<TopologySelectorLabelRequirement>(1, _omitFieldNames ? '' : 'matchLabelExpressions', $pb.PbFieldType.PM, protoName: 'matchLabelExpressions', subBuilder: TopologySelectorLabelRequirement.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TopologySelectorTerm clone() => TopologySelectorTerm()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TopologySelectorTerm copyWith(void Function(TopologySelectorTerm) updates) => super.copyWith((message) => updates(message as TopologySelectorTerm)) as TopologySelectorTerm;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TopologySelectorTerm create() => TopologySelectorTerm._();
  TopologySelectorTerm createEmptyInstance() => create();
  static $pb.PbList<TopologySelectorTerm> createRepeated() => $pb.PbList<TopologySelectorTerm>();
  @$core.pragma('dart2js:noInline')
  static TopologySelectorTerm getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TopologySelectorTerm>(create);
  static TopologySelectorTerm? _defaultInstance;

  /// A list of topology selector requirements by labels.
  /// +optional
  /// +listType=atomic
  @$pb.TagNumber(1)
  $core.List<TopologySelectorLabelRequirement> get matchLabelExpressions => $_getList(0);
}

/// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
class TopologySpreadConstraint extends $pb.GeneratedMessage {
  factory TopologySpreadConstraint({
    $core.int? maxSkew,
    $core.String? topologyKey,
    $core.String? whenUnsatisfiable,
    $0.LabelSelector? labelSelector,
    $core.int? minDomains,
    $core.String? nodeAffinityPolicy,
    $core.String? nodeTaintsPolicy,
    $core.Iterable<$core.String>? matchLabelKeys,
  }) {
    final $result = create();
    if (maxSkew != null) {
      $result.maxSkew = maxSkew;
    }
    if (topologyKey != null) {
      $result.topologyKey = topologyKey;
    }
    if (whenUnsatisfiable != null) {
      $result.whenUnsatisfiable = whenUnsatisfiable;
    }
    if (labelSelector != null) {
      $result.labelSelector = labelSelector;
    }
    if (minDomains != null) {
      $result.minDomains = minDomains;
    }
    if (nodeAffinityPolicy != null) {
      $result.nodeAffinityPolicy = nodeAffinityPolicy;
    }
    if (nodeTaintsPolicy != null) {
      $result.nodeTaintsPolicy = nodeTaintsPolicy;
    }
    if (matchLabelKeys != null) {
      $result.matchLabelKeys.addAll(matchLabelKeys);
    }
    return $result;
  }
  TopologySpreadConstraint._() : super();
  factory TopologySpreadConstraint.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TopologySpreadConstraint.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TopologySpreadConstraint', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'maxSkew', $pb.PbFieldType.O3, protoName: 'maxSkew')
    ..aOS(2, _omitFieldNames ? '' : 'topologyKey', protoName: 'topologyKey')
    ..aOS(3, _omitFieldNames ? '' : 'whenUnsatisfiable', protoName: 'whenUnsatisfiable')
    ..aOM<$0.LabelSelector>(4, _omitFieldNames ? '' : 'labelSelector', protoName: 'labelSelector', subBuilder: $0.LabelSelector.create)
    ..a<$core.int>(5, _omitFieldNames ? '' : 'minDomains', $pb.PbFieldType.O3, protoName: 'minDomains')
    ..aOS(6, _omitFieldNames ? '' : 'nodeAffinityPolicy', protoName: 'nodeAffinityPolicy')
    ..aOS(7, _omitFieldNames ? '' : 'nodeTaintsPolicy', protoName: 'nodeTaintsPolicy')
    ..pPS(8, _omitFieldNames ? '' : 'matchLabelKeys', protoName: 'matchLabelKeys')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TopologySpreadConstraint clone() => TopologySpreadConstraint()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TopologySpreadConstraint copyWith(void Function(TopologySpreadConstraint) updates) => super.copyWith((message) => updates(message as TopologySpreadConstraint)) as TopologySpreadConstraint;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TopologySpreadConstraint create() => TopologySpreadConstraint._();
  TopologySpreadConstraint createEmptyInstance() => create();
  static $pb.PbList<TopologySpreadConstraint> createRepeated() => $pb.PbList<TopologySpreadConstraint>();
  @$core.pragma('dart2js:noInline')
  static TopologySpreadConstraint getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TopologySpreadConstraint>(create);
  static TopologySpreadConstraint? _defaultInstance;

  /// MaxSkew describes the degree to which pods may be unevenly distributed.
  /// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
  /// between the number of matching pods in the target topology and the global minimum.
  /// The global minimum is the minimum number of matching pods in an eligible domain
  /// or zero if the number of eligible domains is less than MinDomains.
  /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  /// labelSelector spread as 2/2/1:
  /// In this case, the global minimum is 1.
  /// +-------+-------+-------+
  /// | zone1 | zone2 | zone3 |
  /// +-------+-------+-------+
  /// |  P P  |  P P  |   P   |
  /// +-------+-------+-------+
  /// - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
  /// scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
  /// violate MaxSkew(1).
  /// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
  /// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
  /// to topologies that satisfy it.
  /// It's a required field. Default value is 1 and 0 is not allowed.
  @$pb.TagNumber(1)
  $core.int get maxSkew => $_getIZ(0);
  @$pb.TagNumber(1)
  set maxSkew($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasMaxSkew() => $_has(0);
  @$pb.TagNumber(1)
  void clearMaxSkew() => clearField(1);

  /// TopologyKey is the key of node labels. Nodes that have a label with this key
  /// and identical values are considered to be in the same topology.
  /// We consider each <key, value> as a "bucket", and try to put balanced number
  /// of pods into each bucket.
  /// We define a domain as a particular instance of a topology.
  /// Also, we define an eligible domain as a domain whose nodes meet the requirements of
  /// nodeAffinityPolicy and nodeTaintsPolicy.
  /// e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
  /// And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
  /// It's a required field.
  @$pb.TagNumber(2)
  $core.String get topologyKey => $_getSZ(1);
  @$pb.TagNumber(2)
  set topologyKey($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasTopologyKey() => $_has(1);
  @$pb.TagNumber(2)
  void clearTopologyKey() => clearField(2);

  /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
  /// the spread constraint.
  /// - DoNotSchedule (default) tells the scheduler not to schedule it.
  /// - ScheduleAnyway tells the scheduler to schedule the pod in any location,
  ///   but giving higher precedence to topologies that would help reduce the
  ///   skew.
  /// A constraint is considered "Unsatisfiable" for an incoming pod
  /// if and only if every possible node assignment for that pod would violate
  /// "MaxSkew" on some topology.
  /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  /// labelSelector spread as 3/1/1:
  /// +-------+-------+-------+
  /// | zone1 | zone2 | zone3 |
  /// +-------+-------+-------+
  /// | P P P |   P   |   P   |
  /// +-------+-------+-------+
  /// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
  /// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
  /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
  /// won't make it *more* imbalanced.
  /// It's a required field.
  @$pb.TagNumber(3)
  $core.String get whenUnsatisfiable => $_getSZ(2);
  @$pb.TagNumber(3)
  set whenUnsatisfiable($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasWhenUnsatisfiable() => $_has(2);
  @$pb.TagNumber(3)
  void clearWhenUnsatisfiable() => clearField(3);

  /// LabelSelector is used to find matching pods.
  /// Pods that match this label selector are counted to determine the number of pods
  /// in their corresponding topology domain.
  /// +optional
  @$pb.TagNumber(4)
  $0.LabelSelector get labelSelector => $_getN(3);
  @$pb.TagNumber(4)
  set labelSelector($0.LabelSelector v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasLabelSelector() => $_has(3);
  @$pb.TagNumber(4)
  void clearLabelSelector() => clearField(4);
  @$pb.TagNumber(4)
  $0.LabelSelector ensureLabelSelector() => $_ensure(3);

  ///  MinDomains indicates a minimum number of eligible domains.
  ///  When the number of eligible domains with matching topology keys is less than minDomains,
  ///  Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
  ///  And when the number of eligible domains with matching topology keys equals or greater than minDomains,
  ///  this value has no effect on scheduling.
  ///  As a result, when the number of eligible domains is less than minDomains,
  ///  scheduler won't schedule more than maxSkew Pods to those domains.
  ///  If value is nil, the constraint behaves as if MinDomains is equal to 1.
  ///  Valid values are integers greater than 0.
  ///  When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
  ///
  ///  For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
  ///  labelSelector spread as 2/2/2:
  ///  +-------+-------+-------+
  ///  | zone1 | zone2 | zone3 |
  ///  +-------+-------+-------+
  ///  |  P P  |  P P  |  P P  |
  ///  +-------+-------+-------+
  ///  The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
  ///  In this situation, new pod with the same labelSelector cannot be scheduled,
  ///  because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
  ///  it will violate MaxSkew.
  ///  +optional
  @$pb.TagNumber(5)
  $core.int get minDomains => $_getIZ(4);
  @$pb.TagNumber(5)
  set minDomains($core.int v) { $_setSignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasMinDomains() => $_has(4);
  @$pb.TagNumber(5)
  void clearMinDomains() => clearField(5);

  ///  NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
  ///  when calculating pod topology spread skew. Options are:
  ///  - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
  ///  - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
  ///
  ///  If this value is nil, the behavior is equivalent to the Honor policy.
  ///  This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  ///  +optional
  @$pb.TagNumber(6)
  $core.String get nodeAffinityPolicy => $_getSZ(5);
  @$pb.TagNumber(6)
  set nodeAffinityPolicy($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasNodeAffinityPolicy() => $_has(5);
  @$pb.TagNumber(6)
  void clearNodeAffinityPolicy() => clearField(6);

  ///  NodeTaintsPolicy indicates how we will treat node taints when calculating
  ///  pod topology spread skew. Options are:
  ///  - Honor: nodes without taints, along with tainted nodes for which the incoming pod
  ///  has a toleration, are included.
  ///  - Ignore: node taints are ignored. All nodes are included.
  ///
  ///  If this value is nil, the behavior is equivalent to the Ignore policy.
  ///  This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  ///  +optional
  @$pb.TagNumber(7)
  $core.String get nodeTaintsPolicy => $_getSZ(6);
  @$pb.TagNumber(7)
  set nodeTaintsPolicy($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasNodeTaintsPolicy() => $_has(6);
  @$pb.TagNumber(7)
  void clearNodeTaintsPolicy() => clearField(7);

  ///  MatchLabelKeys is a set of pod label keys to select the pods over which
  ///  spreading will be calculated. The keys are used to lookup values from the
  ///  incoming pod labels, those key-value labels are ANDed with labelSelector
  ///  to select the group of existing pods over which spreading will be calculated
  ///  for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
  ///  MatchLabelKeys cannot be set when LabelSelector isn't set.
  ///  Keys that don't exist in the incoming pod labels will
  ///  be ignored. A null or empty list means only match against labelSelector.
  ///
  ///  This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
  ///  +listType=atomic
  ///  +optional
  @$pb.TagNumber(8)
  $core.List<$core.String> get matchLabelKeys => $_getList(7);
}

/// TypedLocalObjectReference contains enough information to let you locate the
/// typed referenced object inside the same namespace.
/// +structType=atomic
class TypedLocalObjectReference extends $pb.GeneratedMessage {
  factory TypedLocalObjectReference({
    $core.String? apiGroup,
    $core.String? kind,
    $core.String? name,
  }) {
    final $result = create();
    if (apiGroup != null) {
      $result.apiGroup = apiGroup;
    }
    if (kind != null) {
      $result.kind = kind;
    }
    if (name != null) {
      $result.name = name;
    }
    return $result;
  }
  TypedLocalObjectReference._() : super();
  factory TypedLocalObjectReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TypedLocalObjectReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TypedLocalObjectReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'apiGroup', protoName: 'apiGroup')
    ..aOS(2, _omitFieldNames ? '' : 'kind')
    ..aOS(3, _omitFieldNames ? '' : 'name')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TypedLocalObjectReference clone() => TypedLocalObjectReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TypedLocalObjectReference copyWith(void Function(TypedLocalObjectReference) updates) => super.copyWith((message) => updates(message as TypedLocalObjectReference)) as TypedLocalObjectReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TypedLocalObjectReference create() => TypedLocalObjectReference._();
  TypedLocalObjectReference createEmptyInstance() => create();
  static $pb.PbList<TypedLocalObjectReference> createRepeated() => $pb.PbList<TypedLocalObjectReference>();
  @$core.pragma('dart2js:noInline')
  static TypedLocalObjectReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TypedLocalObjectReference>(create);
  static TypedLocalObjectReference? _defaultInstance;

  /// APIGroup is the group for the resource being referenced.
  /// If APIGroup is not specified, the specified Kind must be in the core API group.
  /// For any other third-party types, APIGroup is required.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get apiGroup => $_getSZ(0);
  @$pb.TagNumber(1)
  set apiGroup($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasApiGroup() => $_has(0);
  @$pb.TagNumber(1)
  void clearApiGroup() => clearField(1);

  /// Kind is the type of resource being referenced
  @$pb.TagNumber(2)
  $core.String get kind => $_getSZ(1);
  @$pb.TagNumber(2)
  set kind($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasKind() => $_has(1);
  @$pb.TagNumber(2)
  void clearKind() => clearField(2);

  /// Name is the name of resource being referenced
  @$pb.TagNumber(3)
  $core.String get name => $_getSZ(2);
  @$pb.TagNumber(3)
  set name($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasName() => $_has(2);
  @$pb.TagNumber(3)
  void clearName() => clearField(3);
}

class TypedObjectReference extends $pb.GeneratedMessage {
  factory TypedObjectReference({
    $core.String? apiGroup,
    $core.String? kind,
    $core.String? name,
    $core.String? namespace,
  }) {
    final $result = create();
    if (apiGroup != null) {
      $result.apiGroup = apiGroup;
    }
    if (kind != null) {
      $result.kind = kind;
    }
    if (name != null) {
      $result.name = name;
    }
    if (namespace != null) {
      $result.namespace = namespace;
    }
    return $result;
  }
  TypedObjectReference._() : super();
  factory TypedObjectReference.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory TypedObjectReference.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'TypedObjectReference', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'apiGroup', protoName: 'apiGroup')
    ..aOS(2, _omitFieldNames ? '' : 'kind')
    ..aOS(3, _omitFieldNames ? '' : 'name')
    ..aOS(4, _omitFieldNames ? '' : 'namespace')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  TypedObjectReference clone() => TypedObjectReference()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  TypedObjectReference copyWith(void Function(TypedObjectReference) updates) => super.copyWith((message) => updates(message as TypedObjectReference)) as TypedObjectReference;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static TypedObjectReference create() => TypedObjectReference._();
  TypedObjectReference createEmptyInstance() => create();
  static $pb.PbList<TypedObjectReference> createRepeated() => $pb.PbList<TypedObjectReference>();
  @$core.pragma('dart2js:noInline')
  static TypedObjectReference getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<TypedObjectReference>(create);
  static TypedObjectReference? _defaultInstance;

  /// APIGroup is the group for the resource being referenced.
  /// If APIGroup is not specified, the specified Kind must be in the core API group.
  /// For any other third-party types, APIGroup is required.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get apiGroup => $_getSZ(0);
  @$pb.TagNumber(1)
  set apiGroup($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasApiGroup() => $_has(0);
  @$pb.TagNumber(1)
  void clearApiGroup() => clearField(1);

  /// Kind is the type of resource being referenced
  @$pb.TagNumber(2)
  $core.String get kind => $_getSZ(1);
  @$pb.TagNumber(2)
  set kind($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasKind() => $_has(1);
  @$pb.TagNumber(2)
  void clearKind() => clearField(2);

  /// Name is the name of resource being referenced
  @$pb.TagNumber(3)
  $core.String get name => $_getSZ(2);
  @$pb.TagNumber(3)
  set name($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasName() => $_has(2);
  @$pb.TagNumber(3)
  void clearName() => clearField(3);

  /// Namespace is the namespace of resource being referenced
  /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
  /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  /// +featureGate=CrossNamespaceVolumeDataSource
  /// +optional
  @$pb.TagNumber(4)
  $core.String get namespace => $_getSZ(3);
  @$pb.TagNumber(4)
  set namespace($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasNamespace() => $_has(3);
  @$pb.TagNumber(4)
  void clearNamespace() => clearField(4);
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
class Volume extends $pb.GeneratedMessage {
  factory Volume({
    $core.String? name,
    VolumeSource? volumeSource,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (volumeSource != null) {
      $result.volumeSource = volumeSource;
    }
    return $result;
  }
  Volume._() : super();
  factory Volume.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Volume.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'Volume', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOM<VolumeSource>(2, _omitFieldNames ? '' : 'volumeSource', protoName: 'volumeSource', subBuilder: VolumeSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Volume clone() => Volume()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Volume copyWith(void Function(Volume) updates) => super.copyWith((message) => updates(message as Volume)) as Volume;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Volume create() => Volume._();
  Volume createEmptyInstance() => create();
  static $pb.PbList<Volume> createRepeated() => $pb.PbList<Volume>();
  @$core.pragma('dart2js:noInline')
  static Volume getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Volume>(create);
  static Volume? _defaultInstance;

  /// name of the volume.
  /// Must be a DNS_LABEL and unique within the pod.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// volumeSource represents the location and type of the mounted volume.
  /// If not specified, the Volume is implied to be an EmptyDir.
  /// This implied behavior is deprecated and will be removed in a future version.
  @$pb.TagNumber(2)
  VolumeSource get volumeSource => $_getN(1);
  @$pb.TagNumber(2)
  set volumeSource(VolumeSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasVolumeSource() => $_has(1);
  @$pb.TagNumber(2)
  void clearVolumeSource() => clearField(2);
  @$pb.TagNumber(2)
  VolumeSource ensureVolumeSource() => $_ensure(1);
}

/// volumeDevice describes a mapping of a raw block device within a container.
class VolumeDevice extends $pb.GeneratedMessage {
  factory VolumeDevice({
    $core.String? name,
    $core.String? devicePath,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (devicePath != null) {
      $result.devicePath = devicePath;
    }
    return $result;
  }
  VolumeDevice._() : super();
  factory VolumeDevice.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeDevice.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeDevice', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'devicePath', protoName: 'devicePath')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeDevice clone() => VolumeDevice()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeDevice copyWith(void Function(VolumeDevice) updates) => super.copyWith((message) => updates(message as VolumeDevice)) as VolumeDevice;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeDevice create() => VolumeDevice._();
  VolumeDevice createEmptyInstance() => create();
  static $pb.PbList<VolumeDevice> createRepeated() => $pb.PbList<VolumeDevice>();
  @$core.pragma('dart2js:noInline')
  static VolumeDevice getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeDevice>(create);
  static VolumeDevice? _defaultInstance;

  /// name must match the name of a persistentVolumeClaim in the pod
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// devicePath is the path inside of the container that the device will be mapped to.
  @$pb.TagNumber(2)
  $core.String get devicePath => $_getSZ(1);
  @$pb.TagNumber(2)
  set devicePath($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasDevicePath() => $_has(1);
  @$pb.TagNumber(2)
  void clearDevicePath() => clearField(2);
}

/// VolumeMount describes a mounting of a Volume within a container.
class VolumeMount extends $pb.GeneratedMessage {
  factory VolumeMount({
    $core.String? name,
    $core.bool? readOnly,
    $core.String? mountPath,
    $core.String? subPath,
    $core.String? mountPropagation,
    $core.String? subPathExpr,
    $core.String? recursiveReadOnly,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (mountPath != null) {
      $result.mountPath = mountPath;
    }
    if (subPath != null) {
      $result.subPath = subPath;
    }
    if (mountPropagation != null) {
      $result.mountPropagation = mountPropagation;
    }
    if (subPathExpr != null) {
      $result.subPathExpr = subPathExpr;
    }
    if (recursiveReadOnly != null) {
      $result.recursiveReadOnly = recursiveReadOnly;
    }
    return $result;
  }
  VolumeMount._() : super();
  factory VolumeMount.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeMount.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeMount', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOB(2, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(3, _omitFieldNames ? '' : 'mountPath', protoName: 'mountPath')
    ..aOS(4, _omitFieldNames ? '' : 'subPath', protoName: 'subPath')
    ..aOS(5, _omitFieldNames ? '' : 'mountPropagation', protoName: 'mountPropagation')
    ..aOS(6, _omitFieldNames ? '' : 'subPathExpr', protoName: 'subPathExpr')
    ..aOS(7, _omitFieldNames ? '' : 'recursiveReadOnly', protoName: 'recursiveReadOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeMount clone() => VolumeMount()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeMount copyWith(void Function(VolumeMount) updates) => super.copyWith((message) => updates(message as VolumeMount)) as VolumeMount;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeMount create() => VolumeMount._();
  VolumeMount createEmptyInstance() => create();
  static $pb.PbList<VolumeMount> createRepeated() => $pb.PbList<VolumeMount>();
  @$core.pragma('dart2js:noInline')
  static VolumeMount getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeMount>(create);
  static VolumeMount? _defaultInstance;

  /// This must match the Name of a Volume.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// Mounted read-only if true, read-write otherwise (false or unspecified).
  /// Defaults to false.
  /// +optional
  @$pb.TagNumber(2)
  $core.bool get readOnly => $_getBF(1);
  @$pb.TagNumber(2)
  set readOnly($core.bool v) { $_setBool(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasReadOnly() => $_has(1);
  @$pb.TagNumber(2)
  void clearReadOnly() => clearField(2);

  /// Path within the container at which the volume should be mounted.  Must
  /// not contain ':'.
  @$pb.TagNumber(3)
  $core.String get mountPath => $_getSZ(2);
  @$pb.TagNumber(3)
  set mountPath($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasMountPath() => $_has(2);
  @$pb.TagNumber(3)
  void clearMountPath() => clearField(3);

  /// Path within the volume from which the container's volume should be mounted.
  /// Defaults to "" (volume's root).
  /// +optional
  @$pb.TagNumber(4)
  $core.String get subPath => $_getSZ(3);
  @$pb.TagNumber(4)
  set subPath($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasSubPath() => $_has(3);
  @$pb.TagNumber(4)
  void clearSubPath() => clearField(4);

  /// mountPropagation determines how mounts are propagated from the host
  /// to container and the other way around.
  /// When not set, MountPropagationNone is used.
  /// This field is beta in 1.10.
  /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
  /// (which defaults to None).
  /// +optional
  @$pb.TagNumber(5)
  $core.String get mountPropagation => $_getSZ(4);
  @$pb.TagNumber(5)
  set mountPropagation($core.String v) { $_setString(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasMountPropagation() => $_has(4);
  @$pb.TagNumber(5)
  void clearMountPropagation() => clearField(5);

  /// Expanded path within the volume from which the container's volume should be mounted.
  /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  /// Defaults to "" (volume's root).
  /// SubPathExpr and SubPath are mutually exclusive.
  /// +optional
  @$pb.TagNumber(6)
  $core.String get subPathExpr => $_getSZ(5);
  @$pb.TagNumber(6)
  set subPathExpr($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasSubPathExpr() => $_has(5);
  @$pb.TagNumber(6)
  void clearSubPathExpr() => clearField(6);

  ///  RecursiveReadOnly specifies whether read-only mounts should be handled
  ///  recursively.
  ///
  ///  If ReadOnly is false, this field has no meaning and must be unspecified.
  ///
  ///  If ReadOnly is true, and this field is set to Disabled, the mount is not made
  ///  recursively read-only.  If this field is set to IfPossible, the mount is made
  ///  recursively read-only, if it is supported by the container runtime.  If this
  ///  field is set to Enabled, the mount is made recursively read-only if it is
  ///  supported by the container runtime, otherwise the pod will not be started and
  ///  an error will be generated to indicate the reason.
  ///
  ///  If this field is set to IfPossible or Enabled, MountPropagation must be set to
  ///  None (or be unspecified, which defaults to None).
  ///
  ///  If this field is not specified, it is treated as an equivalent of Disabled.
  ///
  ///  +featureGate=RecursiveReadOnlyMounts
  ///  +optional
  @$pb.TagNumber(7)
  $core.String get recursiveReadOnly => $_getSZ(6);
  @$pb.TagNumber(7)
  set recursiveReadOnly($core.String v) { $_setString(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasRecursiveReadOnly() => $_has(6);
  @$pb.TagNumber(7)
  void clearRecursiveReadOnly() => clearField(7);
}

/// VolumeMountStatus shows status of volume mounts.
class VolumeMountStatus extends $pb.GeneratedMessage {
  factory VolumeMountStatus({
    $core.String? name,
    $core.String? mountPath,
    $core.bool? readOnly,
    $core.String? recursiveReadOnly,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (mountPath != null) {
      $result.mountPath = mountPath;
    }
    if (readOnly != null) {
      $result.readOnly = readOnly;
    }
    if (recursiveReadOnly != null) {
      $result.recursiveReadOnly = recursiveReadOnly;
    }
    return $result;
  }
  VolumeMountStatus._() : super();
  factory VolumeMountStatus.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeMountStatus.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeMountStatus', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'mountPath', protoName: 'mountPath')
    ..aOB(3, _omitFieldNames ? '' : 'readOnly', protoName: 'readOnly')
    ..aOS(4, _omitFieldNames ? '' : 'recursiveReadOnly', protoName: 'recursiveReadOnly')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeMountStatus clone() => VolumeMountStatus()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeMountStatus copyWith(void Function(VolumeMountStatus) updates) => super.copyWith((message) => updates(message as VolumeMountStatus)) as VolumeMountStatus;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeMountStatus create() => VolumeMountStatus._();
  VolumeMountStatus createEmptyInstance() => create();
  static $pb.PbList<VolumeMountStatus> createRepeated() => $pb.PbList<VolumeMountStatus>();
  @$core.pragma('dart2js:noInline')
  static VolumeMountStatus getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeMountStatus>(create);
  static VolumeMountStatus? _defaultInstance;

  /// Name corresponds to the name of the original VolumeMount.
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// MountPath corresponds to the original VolumeMount.
  @$pb.TagNumber(2)
  $core.String get mountPath => $_getSZ(1);
  @$pb.TagNumber(2)
  set mountPath($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasMountPath() => $_has(1);
  @$pb.TagNumber(2)
  void clearMountPath() => clearField(2);

  /// ReadOnly corresponds to the original VolumeMount.
  /// +optional
  @$pb.TagNumber(3)
  $core.bool get readOnly => $_getBF(2);
  @$pb.TagNumber(3)
  set readOnly($core.bool v) { $_setBool(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasReadOnly() => $_has(2);
  @$pb.TagNumber(3)
  void clearReadOnly() => clearField(3);

  /// RecursiveReadOnly must be set to Disabled, Enabled, or unspecified (for non-readonly mounts).
  /// An IfPossible value in the original VolumeMount must be translated to Disabled or Enabled,
  /// depending on the mount result.
  /// +featureGate=RecursiveReadOnlyMounts
  /// +optional
  @$pb.TagNumber(4)
  $core.String get recursiveReadOnly => $_getSZ(3);
  @$pb.TagNumber(4)
  set recursiveReadOnly($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasRecursiveReadOnly() => $_has(3);
  @$pb.TagNumber(4)
  void clearRecursiveReadOnly() => clearField(4);
}

/// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
class VolumeNodeAffinity extends $pb.GeneratedMessage {
  factory VolumeNodeAffinity({
    NodeSelector? required,
  }) {
    final $result = create();
    if (required != null) {
      $result.required = required;
    }
    return $result;
  }
  VolumeNodeAffinity._() : super();
  factory VolumeNodeAffinity.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeNodeAffinity.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeNodeAffinity', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<NodeSelector>(1, _omitFieldNames ? '' : 'required', subBuilder: NodeSelector.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeNodeAffinity clone() => VolumeNodeAffinity()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeNodeAffinity copyWith(void Function(VolumeNodeAffinity) updates) => super.copyWith((message) => updates(message as VolumeNodeAffinity)) as VolumeNodeAffinity;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeNodeAffinity create() => VolumeNodeAffinity._();
  VolumeNodeAffinity createEmptyInstance() => create();
  static $pb.PbList<VolumeNodeAffinity> createRepeated() => $pb.PbList<VolumeNodeAffinity>();
  @$core.pragma('dart2js:noInline')
  static VolumeNodeAffinity getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeNodeAffinity>(create);
  static VolumeNodeAffinity? _defaultInstance;

  /// required specifies hard node constraints that must be met.
  @$pb.TagNumber(1)
  NodeSelector get required => $_getN(0);
  @$pb.TagNumber(1)
  set required(NodeSelector v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasRequired() => $_has(0);
  @$pb.TagNumber(1)
  void clearRequired() => clearField(1);
  @$pb.TagNumber(1)
  NodeSelector ensureRequired() => $_ensure(0);
}

/// Projection that may be projected along with other supported volume types
class VolumeProjection extends $pb.GeneratedMessage {
  factory VolumeProjection({
    SecretProjection? secret,
    DownwardAPIProjection? downwardAPI,
    ConfigMapProjection? configMap,
    ServiceAccountTokenProjection? serviceAccountToken,
    ClusterTrustBundleProjection? clusterTrustBundle,
  }) {
    final $result = create();
    if (secret != null) {
      $result.secret = secret;
    }
    if (downwardAPI != null) {
      $result.downwardAPI = downwardAPI;
    }
    if (configMap != null) {
      $result.configMap = configMap;
    }
    if (serviceAccountToken != null) {
      $result.serviceAccountToken = serviceAccountToken;
    }
    if (clusterTrustBundle != null) {
      $result.clusterTrustBundle = clusterTrustBundle;
    }
    return $result;
  }
  VolumeProjection._() : super();
  factory VolumeProjection.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeProjection.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeProjection', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<SecretProjection>(1, _omitFieldNames ? '' : 'secret', subBuilder: SecretProjection.create)
    ..aOM<DownwardAPIProjection>(2, _omitFieldNames ? '' : 'downwardAPI', protoName: 'downwardAPI', subBuilder: DownwardAPIProjection.create)
    ..aOM<ConfigMapProjection>(3, _omitFieldNames ? '' : 'configMap', protoName: 'configMap', subBuilder: ConfigMapProjection.create)
    ..aOM<ServiceAccountTokenProjection>(4, _omitFieldNames ? '' : 'serviceAccountToken', protoName: 'serviceAccountToken', subBuilder: ServiceAccountTokenProjection.create)
    ..aOM<ClusterTrustBundleProjection>(5, _omitFieldNames ? '' : 'clusterTrustBundle', protoName: 'clusterTrustBundle', subBuilder: ClusterTrustBundleProjection.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeProjection clone() => VolumeProjection()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeProjection copyWith(void Function(VolumeProjection) updates) => super.copyWith((message) => updates(message as VolumeProjection)) as VolumeProjection;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeProjection create() => VolumeProjection._();
  VolumeProjection createEmptyInstance() => create();
  static $pb.PbList<VolumeProjection> createRepeated() => $pb.PbList<VolumeProjection>();
  @$core.pragma('dart2js:noInline')
  static VolumeProjection getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeProjection>(create);
  static VolumeProjection? _defaultInstance;

  /// secret information about the secret data to project
  /// +optional
  @$pb.TagNumber(1)
  SecretProjection get secret => $_getN(0);
  @$pb.TagNumber(1)
  set secret(SecretProjection v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasSecret() => $_has(0);
  @$pb.TagNumber(1)
  void clearSecret() => clearField(1);
  @$pb.TagNumber(1)
  SecretProjection ensureSecret() => $_ensure(0);

  /// downwardAPI information about the downwardAPI data to project
  /// +optional
  @$pb.TagNumber(2)
  DownwardAPIProjection get downwardAPI => $_getN(1);
  @$pb.TagNumber(2)
  set downwardAPI(DownwardAPIProjection v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasDownwardAPI() => $_has(1);
  @$pb.TagNumber(2)
  void clearDownwardAPI() => clearField(2);
  @$pb.TagNumber(2)
  DownwardAPIProjection ensureDownwardAPI() => $_ensure(1);

  /// configMap information about the configMap data to project
  /// +optional
  @$pb.TagNumber(3)
  ConfigMapProjection get configMap => $_getN(2);
  @$pb.TagNumber(3)
  set configMap(ConfigMapProjection v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasConfigMap() => $_has(2);
  @$pb.TagNumber(3)
  void clearConfigMap() => clearField(3);
  @$pb.TagNumber(3)
  ConfigMapProjection ensureConfigMap() => $_ensure(2);

  /// serviceAccountToken is information about the serviceAccountToken data to project
  /// +optional
  @$pb.TagNumber(4)
  ServiceAccountTokenProjection get serviceAccountToken => $_getN(3);
  @$pb.TagNumber(4)
  set serviceAccountToken(ServiceAccountTokenProjection v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasServiceAccountToken() => $_has(3);
  @$pb.TagNumber(4)
  void clearServiceAccountToken() => clearField(4);
  @$pb.TagNumber(4)
  ServiceAccountTokenProjection ensureServiceAccountToken() => $_ensure(3);

  ///  ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
  ///  of ClusterTrustBundle objects in an auto-updating file.
  ///
  ///  Alpha, gated by the ClusterTrustBundleProjection feature gate.
  ///
  ///  ClusterTrustBundle objects can either be selected by name, or by the
  ///  combination of signer name and a label selector.
  ///
  ///  Kubelet performs aggressive normalization of the PEM contents written
  ///  into the pod filesystem.  Esoteric PEM features such as inter-block
  ///  comments and block headers are stripped.  Certificates are deduplicated.
  ///  The ordering of certificates within the file is arbitrary, and Kubelet
  ///  may change the order over time.
  ///
  ///  +featureGate=ClusterTrustBundleProjection
  ///  +optional
  @$pb.TagNumber(5)
  ClusterTrustBundleProjection get clusterTrustBundle => $_getN(4);
  @$pb.TagNumber(5)
  set clusterTrustBundle(ClusterTrustBundleProjection v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasClusterTrustBundle() => $_has(4);
  @$pb.TagNumber(5)
  void clearClusterTrustBundle() => clearField(5);
  @$pb.TagNumber(5)
  ClusterTrustBundleProjection ensureClusterTrustBundle() => $_ensure(4);
}

/// VolumeResourceRequirements describes the storage resource requirements for a volume.
class VolumeResourceRequirements extends $pb.GeneratedMessage {
  factory VolumeResourceRequirements({
    $core.Map<$core.String, $1.Quantity>? limits,
    $core.Map<$core.String, $1.Quantity>? requests,
  }) {
    final $result = create();
    if (limits != null) {
      $result.limits.addAll(limits);
    }
    if (requests != null) {
      $result.requests.addAll(requests);
    }
    return $result;
  }
  VolumeResourceRequirements._() : super();
  factory VolumeResourceRequirements.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeResourceRequirements.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeResourceRequirements', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..m<$core.String, $1.Quantity>(1, _omitFieldNames ? '' : 'limits', entryClassName: 'VolumeResourceRequirements.LimitsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..m<$core.String, $1.Quantity>(2, _omitFieldNames ? '' : 'requests', entryClassName: 'VolumeResourceRequirements.RequestsEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OM, valueCreator: $1.Quantity.create, valueDefaultOrMaker: $1.Quantity.getDefault, packageName: const $pb.PackageName('api.core.v1'))
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeResourceRequirements clone() => VolumeResourceRequirements()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeResourceRequirements copyWith(void Function(VolumeResourceRequirements) updates) => super.copyWith((message) => updates(message as VolumeResourceRequirements)) as VolumeResourceRequirements;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeResourceRequirements create() => VolumeResourceRequirements._();
  VolumeResourceRequirements createEmptyInstance() => create();
  static $pb.PbList<VolumeResourceRequirements> createRepeated() => $pb.PbList<VolumeResourceRequirements>();
  @$core.pragma('dart2js:noInline')
  static VolumeResourceRequirements getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeResourceRequirements>(create);
  static VolumeResourceRequirements? _defaultInstance;

  /// Limits describes the maximum amount of compute resources allowed.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  /// +optional
  @$pb.TagNumber(1)
  $core.Map<$core.String, $1.Quantity> get limits => $_getMap(0);

  /// Requests describes the minimum amount of compute resources required.
  /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  /// +optional
  @$pb.TagNumber(2)
  $core.Map<$core.String, $1.Quantity> get requests => $_getMap(1);
}

/// Represents the source of a volume to mount.
/// Only one of its members may be specified.
class VolumeSource extends $pb.GeneratedMessage {
  factory VolumeSource({
    HostPathVolumeSource? hostPath,
    EmptyDirVolumeSource? emptyDir,
    GCEPersistentDiskVolumeSource? gcePersistentDisk,
    AWSElasticBlockStoreVolumeSource? awsElasticBlockStore,
    GitRepoVolumeSource? gitRepo,
    SecretVolumeSource? secret,
    NFSVolumeSource? nfs,
    ISCSIVolumeSource? iscsi,
    GlusterfsVolumeSource? glusterfs,
    PersistentVolumeClaimVolumeSource? persistentVolumeClaim,
    RBDVolumeSource? rbd,
    FlexVolumeSource? flexVolume,
    CinderVolumeSource? cinder,
    CephFSVolumeSource? cephfs,
    FlockerVolumeSource? flocker,
    DownwardAPIVolumeSource? downwardAPI,
    FCVolumeSource? fc,
    AzureFileVolumeSource? azureFile,
    ConfigMapVolumeSource? configMap,
    VsphereVirtualDiskVolumeSource? vsphereVolume,
    QuobyteVolumeSource? quobyte,
    AzureDiskVolumeSource? azureDisk,
    PhotonPersistentDiskVolumeSource? photonPersistentDisk,
    PortworxVolumeSource? portworxVolume,
    ScaleIOVolumeSource? scaleIO,
    ProjectedVolumeSource? projected,
    StorageOSVolumeSource? storageos,
    CSIVolumeSource? csi,
    EphemeralVolumeSource? ephemeral,
  }) {
    final $result = create();
    if (hostPath != null) {
      $result.hostPath = hostPath;
    }
    if (emptyDir != null) {
      $result.emptyDir = emptyDir;
    }
    if (gcePersistentDisk != null) {
      $result.gcePersistentDisk = gcePersistentDisk;
    }
    if (awsElasticBlockStore != null) {
      $result.awsElasticBlockStore = awsElasticBlockStore;
    }
    if (gitRepo != null) {
      $result.gitRepo = gitRepo;
    }
    if (secret != null) {
      $result.secret = secret;
    }
    if (nfs != null) {
      $result.nfs = nfs;
    }
    if (iscsi != null) {
      $result.iscsi = iscsi;
    }
    if (glusterfs != null) {
      $result.glusterfs = glusterfs;
    }
    if (persistentVolumeClaim != null) {
      $result.persistentVolumeClaim = persistentVolumeClaim;
    }
    if (rbd != null) {
      $result.rbd = rbd;
    }
    if (flexVolume != null) {
      $result.flexVolume = flexVolume;
    }
    if (cinder != null) {
      $result.cinder = cinder;
    }
    if (cephfs != null) {
      $result.cephfs = cephfs;
    }
    if (flocker != null) {
      $result.flocker = flocker;
    }
    if (downwardAPI != null) {
      $result.downwardAPI = downwardAPI;
    }
    if (fc != null) {
      $result.fc = fc;
    }
    if (azureFile != null) {
      $result.azureFile = azureFile;
    }
    if (configMap != null) {
      $result.configMap = configMap;
    }
    if (vsphereVolume != null) {
      $result.vsphereVolume = vsphereVolume;
    }
    if (quobyte != null) {
      $result.quobyte = quobyte;
    }
    if (azureDisk != null) {
      $result.azureDisk = azureDisk;
    }
    if (photonPersistentDisk != null) {
      $result.photonPersistentDisk = photonPersistentDisk;
    }
    if (portworxVolume != null) {
      $result.portworxVolume = portworxVolume;
    }
    if (scaleIO != null) {
      $result.scaleIO = scaleIO;
    }
    if (projected != null) {
      $result.projected = projected;
    }
    if (storageos != null) {
      $result.storageos = storageos;
    }
    if (csi != null) {
      $result.csi = csi;
    }
    if (ephemeral != null) {
      $result.ephemeral = ephemeral;
    }
    return $result;
  }
  VolumeSource._() : super();
  factory VolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOM<HostPathVolumeSource>(1, _omitFieldNames ? '' : 'hostPath', protoName: 'hostPath', subBuilder: HostPathVolumeSource.create)
    ..aOM<EmptyDirVolumeSource>(2, _omitFieldNames ? '' : 'emptyDir', protoName: 'emptyDir', subBuilder: EmptyDirVolumeSource.create)
    ..aOM<GCEPersistentDiskVolumeSource>(3, _omitFieldNames ? '' : 'gcePersistentDisk', protoName: 'gcePersistentDisk', subBuilder: GCEPersistentDiskVolumeSource.create)
    ..aOM<AWSElasticBlockStoreVolumeSource>(4, _omitFieldNames ? '' : 'awsElasticBlockStore', protoName: 'awsElasticBlockStore', subBuilder: AWSElasticBlockStoreVolumeSource.create)
    ..aOM<GitRepoVolumeSource>(5, _omitFieldNames ? '' : 'gitRepo', protoName: 'gitRepo', subBuilder: GitRepoVolumeSource.create)
    ..aOM<SecretVolumeSource>(6, _omitFieldNames ? '' : 'secret', subBuilder: SecretVolumeSource.create)
    ..aOM<NFSVolumeSource>(7, _omitFieldNames ? '' : 'nfs', subBuilder: NFSVolumeSource.create)
    ..aOM<ISCSIVolumeSource>(8, _omitFieldNames ? '' : 'iscsi', subBuilder: ISCSIVolumeSource.create)
    ..aOM<GlusterfsVolumeSource>(9, _omitFieldNames ? '' : 'glusterfs', subBuilder: GlusterfsVolumeSource.create)
    ..aOM<PersistentVolumeClaimVolumeSource>(10, _omitFieldNames ? '' : 'persistentVolumeClaim', protoName: 'persistentVolumeClaim', subBuilder: PersistentVolumeClaimVolumeSource.create)
    ..aOM<RBDVolumeSource>(11, _omitFieldNames ? '' : 'rbd', subBuilder: RBDVolumeSource.create)
    ..aOM<FlexVolumeSource>(12, _omitFieldNames ? '' : 'flexVolume', protoName: 'flexVolume', subBuilder: FlexVolumeSource.create)
    ..aOM<CinderVolumeSource>(13, _omitFieldNames ? '' : 'cinder', subBuilder: CinderVolumeSource.create)
    ..aOM<CephFSVolumeSource>(14, _omitFieldNames ? '' : 'cephfs', subBuilder: CephFSVolumeSource.create)
    ..aOM<FlockerVolumeSource>(15, _omitFieldNames ? '' : 'flocker', subBuilder: FlockerVolumeSource.create)
    ..aOM<DownwardAPIVolumeSource>(16, _omitFieldNames ? '' : 'downwardAPI', protoName: 'downwardAPI', subBuilder: DownwardAPIVolumeSource.create)
    ..aOM<FCVolumeSource>(17, _omitFieldNames ? '' : 'fc', subBuilder: FCVolumeSource.create)
    ..aOM<AzureFileVolumeSource>(18, _omitFieldNames ? '' : 'azureFile', protoName: 'azureFile', subBuilder: AzureFileVolumeSource.create)
    ..aOM<ConfigMapVolumeSource>(19, _omitFieldNames ? '' : 'configMap', protoName: 'configMap', subBuilder: ConfigMapVolumeSource.create)
    ..aOM<VsphereVirtualDiskVolumeSource>(20, _omitFieldNames ? '' : 'vsphereVolume', protoName: 'vsphereVolume', subBuilder: VsphereVirtualDiskVolumeSource.create)
    ..aOM<QuobyteVolumeSource>(21, _omitFieldNames ? '' : 'quobyte', subBuilder: QuobyteVolumeSource.create)
    ..aOM<AzureDiskVolumeSource>(22, _omitFieldNames ? '' : 'azureDisk', protoName: 'azureDisk', subBuilder: AzureDiskVolumeSource.create)
    ..aOM<PhotonPersistentDiskVolumeSource>(23, _omitFieldNames ? '' : 'photonPersistentDisk', protoName: 'photonPersistentDisk', subBuilder: PhotonPersistentDiskVolumeSource.create)
    ..aOM<PortworxVolumeSource>(24, _omitFieldNames ? '' : 'portworxVolume', protoName: 'portworxVolume', subBuilder: PortworxVolumeSource.create)
    ..aOM<ScaleIOVolumeSource>(25, _omitFieldNames ? '' : 'scaleIO', protoName: 'scaleIO', subBuilder: ScaleIOVolumeSource.create)
    ..aOM<ProjectedVolumeSource>(26, _omitFieldNames ? '' : 'projected', subBuilder: ProjectedVolumeSource.create)
    ..aOM<StorageOSVolumeSource>(27, _omitFieldNames ? '' : 'storageos', subBuilder: StorageOSVolumeSource.create)
    ..aOM<CSIVolumeSource>(28, _omitFieldNames ? '' : 'csi', subBuilder: CSIVolumeSource.create)
    ..aOM<EphemeralVolumeSource>(29, _omitFieldNames ? '' : 'ephemeral', subBuilder: EphemeralVolumeSource.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VolumeSource clone() => VolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VolumeSource copyWith(void Function(VolumeSource) updates) => super.copyWith((message) => updates(message as VolumeSource)) as VolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VolumeSource create() => VolumeSource._();
  VolumeSource createEmptyInstance() => create();
  static $pb.PbList<VolumeSource> createRepeated() => $pb.PbList<VolumeSource>();
  @$core.pragma('dart2js:noInline')
  static VolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VolumeSource>(create);
  static VolumeSource? _defaultInstance;

  /// hostPath represents a pre-existing file or directory on the host
  /// machine that is directly exposed to the container. This is generally
  /// used for system agents or other privileged things that are allowed
  /// to see the host machine. Most containers will NOT need this.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// ---
  /// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  /// mount host directories as read/write.
  /// +optional
  @$pb.TagNumber(1)
  HostPathVolumeSource get hostPath => $_getN(0);
  @$pb.TagNumber(1)
  set hostPath(HostPathVolumeSource v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasHostPath() => $_has(0);
  @$pb.TagNumber(1)
  void clearHostPath() => clearField(1);
  @$pb.TagNumber(1)
  HostPathVolumeSource ensureHostPath() => $_ensure(0);

  /// emptyDir represents a temporary directory that shares a pod's lifetime.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  /// +optional
  @$pb.TagNumber(2)
  EmptyDirVolumeSource get emptyDir => $_getN(1);
  @$pb.TagNumber(2)
  set emptyDir(EmptyDirVolumeSource v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasEmptyDir() => $_has(1);
  @$pb.TagNumber(2)
  void clearEmptyDir() => clearField(2);
  @$pb.TagNumber(2)
  EmptyDirVolumeSource ensureEmptyDir() => $_ensure(1);

  /// gcePersistentDisk represents a GCE Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  @$pb.TagNumber(3)
  GCEPersistentDiskVolumeSource get gcePersistentDisk => $_getN(2);
  @$pb.TagNumber(3)
  set gcePersistentDisk(GCEPersistentDiskVolumeSource v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasGcePersistentDisk() => $_has(2);
  @$pb.TagNumber(3)
  void clearGcePersistentDisk() => clearField(3);
  @$pb.TagNumber(3)
  GCEPersistentDiskVolumeSource ensureGcePersistentDisk() => $_ensure(2);

  /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  @$pb.TagNumber(4)
  AWSElasticBlockStoreVolumeSource get awsElasticBlockStore => $_getN(3);
  @$pb.TagNumber(4)
  set awsElasticBlockStore(AWSElasticBlockStoreVolumeSource v) { setField(4, v); }
  @$pb.TagNumber(4)
  $core.bool hasAwsElasticBlockStore() => $_has(3);
  @$pb.TagNumber(4)
  void clearAwsElasticBlockStore() => clearField(4);
  @$pb.TagNumber(4)
  AWSElasticBlockStoreVolumeSource ensureAwsElasticBlockStore() => $_ensure(3);

  /// gitRepo represents a git repository at a particular revision.
  /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  /// into the Pod's container.
  /// +optional
  @$pb.TagNumber(5)
  GitRepoVolumeSource get gitRepo => $_getN(4);
  @$pb.TagNumber(5)
  set gitRepo(GitRepoVolumeSource v) { setField(5, v); }
  @$pb.TagNumber(5)
  $core.bool hasGitRepo() => $_has(4);
  @$pb.TagNumber(5)
  void clearGitRepo() => clearField(5);
  @$pb.TagNumber(5)
  GitRepoVolumeSource ensureGitRepo() => $_ensure(4);

  /// secret represents a secret that should populate this volume.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  /// +optional
  @$pb.TagNumber(6)
  SecretVolumeSource get secret => $_getN(5);
  @$pb.TagNumber(6)
  set secret(SecretVolumeSource v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasSecret() => $_has(5);
  @$pb.TagNumber(6)
  void clearSecret() => clearField(6);
  @$pb.TagNumber(6)
  SecretVolumeSource ensureSecret() => $_ensure(5);

  /// nfs represents an NFS mount on the host that shares a pod's lifetime
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  @$pb.TagNumber(7)
  NFSVolumeSource get nfs => $_getN(6);
  @$pb.TagNumber(7)
  set nfs(NFSVolumeSource v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasNfs() => $_has(6);
  @$pb.TagNumber(7)
  void clearNfs() => clearField(7);
  @$pb.TagNumber(7)
  NFSVolumeSource ensureNfs() => $_ensure(6);

  /// iscsi represents an ISCSI Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://examples.k8s.io/volumes/iscsi/README.md
  /// +optional
  @$pb.TagNumber(8)
  ISCSIVolumeSource get iscsi => $_getN(7);
  @$pb.TagNumber(8)
  set iscsi(ISCSIVolumeSource v) { setField(8, v); }
  @$pb.TagNumber(8)
  $core.bool hasIscsi() => $_has(7);
  @$pb.TagNumber(8)
  void clearIscsi() => clearField(8);
  @$pb.TagNumber(8)
  ISCSIVolumeSource ensureIscsi() => $_ensure(7);

  /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
  /// +optional
  @$pb.TagNumber(9)
  GlusterfsVolumeSource get glusterfs => $_getN(8);
  @$pb.TagNumber(9)
  set glusterfs(GlusterfsVolumeSource v) { setField(9, v); }
  @$pb.TagNumber(9)
  $core.bool hasGlusterfs() => $_has(8);
  @$pb.TagNumber(9)
  void clearGlusterfs() => clearField(9);
  @$pb.TagNumber(9)
  GlusterfsVolumeSource ensureGlusterfs() => $_ensure(8);

  /// persistentVolumeClaimVolumeSource represents a reference to a
  /// PersistentVolumeClaim in the same namespace.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  @$pb.TagNumber(10)
  PersistentVolumeClaimVolumeSource get persistentVolumeClaim => $_getN(9);
  @$pb.TagNumber(10)
  set persistentVolumeClaim(PersistentVolumeClaimVolumeSource v) { setField(10, v); }
  @$pb.TagNumber(10)
  $core.bool hasPersistentVolumeClaim() => $_has(9);
  @$pb.TagNumber(10)
  void clearPersistentVolumeClaim() => clearField(10);
  @$pb.TagNumber(10)
  PersistentVolumeClaimVolumeSource ensurePersistentVolumeClaim() => $_ensure(9);

  /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md
  /// +optional
  @$pb.TagNumber(11)
  RBDVolumeSource get rbd => $_getN(10);
  @$pb.TagNumber(11)
  set rbd(RBDVolumeSource v) { setField(11, v); }
  @$pb.TagNumber(11)
  $core.bool hasRbd() => $_has(10);
  @$pb.TagNumber(11)
  void clearRbd() => clearField(11);
  @$pb.TagNumber(11)
  RBDVolumeSource ensureRbd() => $_ensure(10);

  /// flexVolume represents a generic volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// +optional
  @$pb.TagNumber(12)
  FlexVolumeSource get flexVolume => $_getN(11);
  @$pb.TagNumber(12)
  set flexVolume(FlexVolumeSource v) { setField(12, v); }
  @$pb.TagNumber(12)
  $core.bool hasFlexVolume() => $_has(11);
  @$pb.TagNumber(12)
  void clearFlexVolume() => clearField(12);
  @$pb.TagNumber(12)
  FlexVolumeSource ensureFlexVolume() => $_ensure(11);

  /// cinder represents a cinder volume attached and mounted on kubelets host machine.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  @$pb.TagNumber(13)
  CinderVolumeSource get cinder => $_getN(12);
  @$pb.TagNumber(13)
  set cinder(CinderVolumeSource v) { setField(13, v); }
  @$pb.TagNumber(13)
  $core.bool hasCinder() => $_has(12);
  @$pb.TagNumber(13)
  void clearCinder() => clearField(13);
  @$pb.TagNumber(13)
  CinderVolumeSource ensureCinder() => $_ensure(12);

  /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  /// +optional
  @$pb.TagNumber(14)
  CephFSVolumeSource get cephfs => $_getN(13);
  @$pb.TagNumber(14)
  set cephfs(CephFSVolumeSource v) { setField(14, v); }
  @$pb.TagNumber(14)
  $core.bool hasCephfs() => $_has(13);
  @$pb.TagNumber(14)
  void clearCephfs() => clearField(14);
  @$pb.TagNumber(14)
  CephFSVolumeSource ensureCephfs() => $_ensure(13);

  /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  /// +optional
  @$pb.TagNumber(15)
  FlockerVolumeSource get flocker => $_getN(14);
  @$pb.TagNumber(15)
  set flocker(FlockerVolumeSource v) { setField(15, v); }
  @$pb.TagNumber(15)
  $core.bool hasFlocker() => $_has(14);
  @$pb.TagNumber(15)
  void clearFlocker() => clearField(15);
  @$pb.TagNumber(15)
  FlockerVolumeSource ensureFlocker() => $_ensure(14);

  /// downwardAPI represents downward API about the pod that should populate this volume
  /// +optional
  @$pb.TagNumber(16)
  DownwardAPIVolumeSource get downwardAPI => $_getN(15);
  @$pb.TagNumber(16)
  set downwardAPI(DownwardAPIVolumeSource v) { setField(16, v); }
  @$pb.TagNumber(16)
  $core.bool hasDownwardAPI() => $_has(15);
  @$pb.TagNumber(16)
  void clearDownwardAPI() => clearField(16);
  @$pb.TagNumber(16)
  DownwardAPIVolumeSource ensureDownwardAPI() => $_ensure(15);

  /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  /// +optional
  @$pb.TagNumber(17)
  FCVolumeSource get fc => $_getN(16);
  @$pb.TagNumber(17)
  set fc(FCVolumeSource v) { setField(17, v); }
  @$pb.TagNumber(17)
  $core.bool hasFc() => $_has(16);
  @$pb.TagNumber(17)
  void clearFc() => clearField(17);
  @$pb.TagNumber(17)
  FCVolumeSource ensureFc() => $_ensure(16);

  /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// +optional
  @$pb.TagNumber(18)
  AzureFileVolumeSource get azureFile => $_getN(17);
  @$pb.TagNumber(18)
  set azureFile(AzureFileVolumeSource v) { setField(18, v); }
  @$pb.TagNumber(18)
  $core.bool hasAzureFile() => $_has(17);
  @$pb.TagNumber(18)
  void clearAzureFile() => clearField(18);
  @$pb.TagNumber(18)
  AzureFileVolumeSource ensureAzureFile() => $_ensure(17);

  /// configMap represents a configMap that should populate this volume
  /// +optional
  @$pb.TagNumber(19)
  ConfigMapVolumeSource get configMap => $_getN(18);
  @$pb.TagNumber(19)
  set configMap(ConfigMapVolumeSource v) { setField(19, v); }
  @$pb.TagNumber(19)
  $core.bool hasConfigMap() => $_has(18);
  @$pb.TagNumber(19)
  void clearConfigMap() => clearField(19);
  @$pb.TagNumber(19)
  ConfigMapVolumeSource ensureConfigMap() => $_ensure(18);

  /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  /// +optional
  @$pb.TagNumber(20)
  VsphereVirtualDiskVolumeSource get vsphereVolume => $_getN(19);
  @$pb.TagNumber(20)
  set vsphereVolume(VsphereVirtualDiskVolumeSource v) { setField(20, v); }
  @$pb.TagNumber(20)
  $core.bool hasVsphereVolume() => $_has(19);
  @$pb.TagNumber(20)
  void clearVsphereVolume() => clearField(20);
  @$pb.TagNumber(20)
  VsphereVirtualDiskVolumeSource ensureVsphereVolume() => $_ensure(19);

  /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  /// +optional
  @$pb.TagNumber(21)
  QuobyteVolumeSource get quobyte => $_getN(20);
  @$pb.TagNumber(21)
  set quobyte(QuobyteVolumeSource v) { setField(21, v); }
  @$pb.TagNumber(21)
  $core.bool hasQuobyte() => $_has(20);
  @$pb.TagNumber(21)
  void clearQuobyte() => clearField(21);
  @$pb.TagNumber(21)
  QuobyteVolumeSource ensureQuobyte() => $_ensure(20);

  /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  /// +optional
  @$pb.TagNumber(22)
  AzureDiskVolumeSource get azureDisk => $_getN(21);
  @$pb.TagNumber(22)
  set azureDisk(AzureDiskVolumeSource v) { setField(22, v); }
  @$pb.TagNumber(22)
  $core.bool hasAzureDisk() => $_has(21);
  @$pb.TagNumber(22)
  void clearAzureDisk() => clearField(22);
  @$pb.TagNumber(22)
  AzureDiskVolumeSource ensureAzureDisk() => $_ensure(21);

  /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  @$pb.TagNumber(23)
  PhotonPersistentDiskVolumeSource get photonPersistentDisk => $_getN(22);
  @$pb.TagNumber(23)
  set photonPersistentDisk(PhotonPersistentDiskVolumeSource v) { setField(23, v); }
  @$pb.TagNumber(23)
  $core.bool hasPhotonPersistentDisk() => $_has(22);
  @$pb.TagNumber(23)
  void clearPhotonPersistentDisk() => clearField(23);
  @$pb.TagNumber(23)
  PhotonPersistentDiskVolumeSource ensurePhotonPersistentDisk() => $_ensure(22);

  /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
  /// +optional
  @$pb.TagNumber(24)
  PortworxVolumeSource get portworxVolume => $_getN(23);
  @$pb.TagNumber(24)
  set portworxVolume(PortworxVolumeSource v) { setField(24, v); }
  @$pb.TagNumber(24)
  $core.bool hasPortworxVolume() => $_has(23);
  @$pb.TagNumber(24)
  void clearPortworxVolume() => clearField(24);
  @$pb.TagNumber(24)
  PortworxVolumeSource ensurePortworxVolume() => $_ensure(23);

  /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  /// +optional
  @$pb.TagNumber(25)
  ScaleIOVolumeSource get scaleIO => $_getN(24);
  @$pb.TagNumber(25)
  set scaleIO(ScaleIOVolumeSource v) { setField(25, v); }
  @$pb.TagNumber(25)
  $core.bool hasScaleIO() => $_has(24);
  @$pb.TagNumber(25)
  void clearScaleIO() => clearField(25);
  @$pb.TagNumber(25)
  ScaleIOVolumeSource ensureScaleIO() => $_ensure(24);

  /// projected items for all in one resources secrets, configmaps, and downward API
  @$pb.TagNumber(26)
  ProjectedVolumeSource get projected => $_getN(25);
  @$pb.TagNumber(26)
  set projected(ProjectedVolumeSource v) { setField(26, v); }
  @$pb.TagNumber(26)
  $core.bool hasProjected() => $_has(25);
  @$pb.TagNumber(26)
  void clearProjected() => clearField(26);
  @$pb.TagNumber(26)
  ProjectedVolumeSource ensureProjected() => $_ensure(25);

  /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  /// +optional
  @$pb.TagNumber(27)
  StorageOSVolumeSource get storageos => $_getN(26);
  @$pb.TagNumber(27)
  set storageos(StorageOSVolumeSource v) { setField(27, v); }
  @$pb.TagNumber(27)
  $core.bool hasStorageos() => $_has(26);
  @$pb.TagNumber(27)
  void clearStorageos() => clearField(27);
  @$pb.TagNumber(27)
  StorageOSVolumeSource ensureStorageos() => $_ensure(26);

  /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
  /// +optional
  @$pb.TagNumber(28)
  CSIVolumeSource get csi => $_getN(27);
  @$pb.TagNumber(28)
  set csi(CSIVolumeSource v) { setField(28, v); }
  @$pb.TagNumber(28)
  $core.bool hasCsi() => $_has(27);
  @$pb.TagNumber(28)
  void clearCsi() => clearField(28);
  @$pb.TagNumber(28)
  CSIVolumeSource ensureCsi() => $_ensure(27);

  ///  ephemeral represents a volume that is handled by a cluster storage driver.
  ///  The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
  ///  and deleted when the pod is removed.
  ///
  ///  Use this if:
  ///  a) the volume is only needed while the pod runs,
  ///  b) features of normal volumes like restoring from snapshot or capacity
  ///     tracking are needed,
  ///  c) the storage driver is specified through a storage class, and
  ///  d) the storage driver supports dynamic volume provisioning through
  ///     a PersistentVolumeClaim (see EphemeralVolumeSource for more
  ///     information on the connection between this volume type
  ///     and PersistentVolumeClaim).
  ///
  ///  Use PersistentVolumeClaim or one of the vendor-specific
  ///  APIs for volumes that persist for longer than the lifecycle
  ///  of an individual pod.
  ///
  ///  Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
  ///  be used that way - see the documentation of the driver for
  ///  more information.
  ///
  ///  A pod can use both types of ephemeral volumes and
  ///  persistent volumes at the same time.
  ///
  ///  +optional
  @$pb.TagNumber(29)
  EphemeralVolumeSource get ephemeral => $_getN(28);
  @$pb.TagNumber(29)
  set ephemeral(EphemeralVolumeSource v) { setField(29, v); }
  @$pb.TagNumber(29)
  $core.bool hasEphemeral() => $_has(28);
  @$pb.TagNumber(29)
  void clearEphemeral() => clearField(29);
  @$pb.TagNumber(29)
  EphemeralVolumeSource ensureEphemeral() => $_ensure(28);
}

/// Represents a vSphere volume resource.
class VsphereVirtualDiskVolumeSource extends $pb.GeneratedMessage {
  factory VsphereVirtualDiskVolumeSource({
    $core.String? volumePath,
    $core.String? fsType,
    $core.String? storagePolicyName,
    $core.String? storagePolicyID,
  }) {
    final $result = create();
    if (volumePath != null) {
      $result.volumePath = volumePath;
    }
    if (fsType != null) {
      $result.fsType = fsType;
    }
    if (storagePolicyName != null) {
      $result.storagePolicyName = storagePolicyName;
    }
    if (storagePolicyID != null) {
      $result.storagePolicyID = storagePolicyID;
    }
    return $result;
  }
  VsphereVirtualDiskVolumeSource._() : super();
  factory VsphereVirtualDiskVolumeSource.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory VsphereVirtualDiskVolumeSource.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'VsphereVirtualDiskVolumeSource', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'volumePath', protoName: 'volumePath')
    ..aOS(2, _omitFieldNames ? '' : 'fsType', protoName: 'fsType')
    ..aOS(3, _omitFieldNames ? '' : 'storagePolicyName', protoName: 'storagePolicyName')
    ..aOS(4, _omitFieldNames ? '' : 'storagePolicyID', protoName: 'storagePolicyID')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  VsphereVirtualDiskVolumeSource clone() => VsphereVirtualDiskVolumeSource()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  VsphereVirtualDiskVolumeSource copyWith(void Function(VsphereVirtualDiskVolumeSource) updates) => super.copyWith((message) => updates(message as VsphereVirtualDiskVolumeSource)) as VsphereVirtualDiskVolumeSource;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VsphereVirtualDiskVolumeSource create() => VsphereVirtualDiskVolumeSource._();
  VsphereVirtualDiskVolumeSource createEmptyInstance() => create();
  static $pb.PbList<VsphereVirtualDiskVolumeSource> createRepeated() => $pb.PbList<VsphereVirtualDiskVolumeSource>();
  @$core.pragma('dart2js:noInline')
  static VsphereVirtualDiskVolumeSource getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<VsphereVirtualDiskVolumeSource>(create);
  static VsphereVirtualDiskVolumeSource? _defaultInstance;

  /// volumePath is the path that identifies vSphere volume vmdk
  @$pb.TagNumber(1)
  $core.String get volumePath => $_getSZ(0);
  @$pb.TagNumber(1)
  set volumePath($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasVolumePath() => $_has(0);
  @$pb.TagNumber(1)
  void clearVolumePath() => clearField(1);

  /// fsType is filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get fsType => $_getSZ(1);
  @$pb.TagNumber(2)
  set fsType($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFsType() => $_has(1);
  @$pb.TagNumber(2)
  void clearFsType() => clearField(2);

  /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get storagePolicyName => $_getSZ(2);
  @$pb.TagNumber(3)
  set storagePolicyName($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasStoragePolicyName() => $_has(2);
  @$pb.TagNumber(3)
  void clearStoragePolicyName() => clearField(3);

  /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  /// +optional
  @$pb.TagNumber(4)
  $core.String get storagePolicyID => $_getSZ(3);
  @$pb.TagNumber(4)
  set storagePolicyID($core.String v) { $_setString(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasStoragePolicyID() => $_has(3);
  @$pb.TagNumber(4)
  void clearStoragePolicyID() => clearField(4);
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
class WeightedPodAffinityTerm extends $pb.GeneratedMessage {
  factory WeightedPodAffinityTerm({
    $core.int? weight,
    PodAffinityTerm? podAffinityTerm,
  }) {
    final $result = create();
    if (weight != null) {
      $result.weight = weight;
    }
    if (podAffinityTerm != null) {
      $result.podAffinityTerm = podAffinityTerm;
    }
    return $result;
  }
  WeightedPodAffinityTerm._() : super();
  factory WeightedPodAffinityTerm.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory WeightedPodAffinityTerm.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'WeightedPodAffinityTerm', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..a<$core.int>(1, _omitFieldNames ? '' : 'weight', $pb.PbFieldType.O3)
    ..aOM<PodAffinityTerm>(2, _omitFieldNames ? '' : 'podAffinityTerm', protoName: 'podAffinityTerm', subBuilder: PodAffinityTerm.create)
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  WeightedPodAffinityTerm clone() => WeightedPodAffinityTerm()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  WeightedPodAffinityTerm copyWith(void Function(WeightedPodAffinityTerm) updates) => super.copyWith((message) => updates(message as WeightedPodAffinityTerm)) as WeightedPodAffinityTerm;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static WeightedPodAffinityTerm create() => WeightedPodAffinityTerm._();
  WeightedPodAffinityTerm createEmptyInstance() => create();
  static $pb.PbList<WeightedPodAffinityTerm> createRepeated() => $pb.PbList<WeightedPodAffinityTerm>();
  @$core.pragma('dart2js:noInline')
  static WeightedPodAffinityTerm getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<WeightedPodAffinityTerm>(create);
  static WeightedPodAffinityTerm? _defaultInstance;

  /// weight associated with matching the corresponding podAffinityTerm,
  /// in the range 1-100.
  @$pb.TagNumber(1)
  $core.int get weight => $_getIZ(0);
  @$pb.TagNumber(1)
  set weight($core.int v) { $_setSignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasWeight() => $_has(0);
  @$pb.TagNumber(1)
  void clearWeight() => clearField(1);

  /// Required. A pod affinity term, associated with the corresponding weight.
  @$pb.TagNumber(2)
  PodAffinityTerm get podAffinityTerm => $_getN(1);
  @$pb.TagNumber(2)
  set podAffinityTerm(PodAffinityTerm v) { setField(2, v); }
  @$pb.TagNumber(2)
  $core.bool hasPodAffinityTerm() => $_has(1);
  @$pb.TagNumber(2)
  void clearPodAffinityTerm() => clearField(2);
  @$pb.TagNumber(2)
  PodAffinityTerm ensurePodAffinityTerm() => $_ensure(1);
}

/// WindowsSecurityContextOptions contain Windows-specific options and credentials.
class WindowsSecurityContextOptions extends $pb.GeneratedMessage {
  factory WindowsSecurityContextOptions({
    $core.String? gmsaCredentialSpecName,
    $core.String? gmsaCredentialSpec,
    $core.String? runAsUserName,
    $core.bool? hostProcess,
  }) {
    final $result = create();
    if (gmsaCredentialSpecName != null) {
      $result.gmsaCredentialSpecName = gmsaCredentialSpecName;
    }
    if (gmsaCredentialSpec != null) {
      $result.gmsaCredentialSpec = gmsaCredentialSpec;
    }
    if (runAsUserName != null) {
      $result.runAsUserName = runAsUserName;
    }
    if (hostProcess != null) {
      $result.hostProcess = hostProcess;
    }
    return $result;
  }
  WindowsSecurityContextOptions._() : super();
  factory WindowsSecurityContextOptions.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory WindowsSecurityContextOptions.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(_omitMessageNames ? '' : 'WindowsSecurityContextOptions', package: const $pb.PackageName(_omitMessageNames ? '' : 'api.core.v1'), createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'gmsaCredentialSpecName', protoName: 'gmsaCredentialSpecName')
    ..aOS(2, _omitFieldNames ? '' : 'gmsaCredentialSpec', protoName: 'gmsaCredentialSpec')
    ..aOS(3, _omitFieldNames ? '' : 'runAsUserName', protoName: 'runAsUserName')
    ..aOB(4, _omitFieldNames ? '' : 'hostProcess', protoName: 'hostProcess')
    ..hasRequiredFields = false
  ;

  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  WindowsSecurityContextOptions clone() => WindowsSecurityContextOptions()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  WindowsSecurityContextOptions copyWith(void Function(WindowsSecurityContextOptions) updates) => super.copyWith((message) => updates(message as WindowsSecurityContextOptions)) as WindowsSecurityContextOptions;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static WindowsSecurityContextOptions create() => WindowsSecurityContextOptions._();
  WindowsSecurityContextOptions createEmptyInstance() => create();
  static $pb.PbList<WindowsSecurityContextOptions> createRepeated() => $pb.PbList<WindowsSecurityContextOptions>();
  @$core.pragma('dart2js:noInline')
  static WindowsSecurityContextOptions getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<WindowsSecurityContextOptions>(create);
  static WindowsSecurityContextOptions? _defaultInstance;

  /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
  /// +optional
  @$pb.TagNumber(1)
  $core.String get gmsaCredentialSpecName => $_getSZ(0);
  @$pb.TagNumber(1)
  set gmsaCredentialSpecName($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasGmsaCredentialSpecName() => $_has(0);
  @$pb.TagNumber(1)
  void clearGmsaCredentialSpecName() => clearField(1);

  /// GMSACredentialSpec is where the GMSA admission webhook
  /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
  /// GMSA credential spec named by the GMSACredentialSpecName field.
  /// +optional
  @$pb.TagNumber(2)
  $core.String get gmsaCredentialSpec => $_getSZ(1);
  @$pb.TagNumber(2)
  set gmsaCredentialSpec($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasGmsaCredentialSpec() => $_has(1);
  @$pb.TagNumber(2)
  void clearGmsaCredentialSpec() => clearField(2);

  /// The UserName in Windows to run the entrypoint of the container process.
  /// Defaults to the user specified in image metadata if unspecified.
  /// May also be set in PodSecurityContext. If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  @$pb.TagNumber(3)
  $core.String get runAsUserName => $_getSZ(2);
  @$pb.TagNumber(3)
  set runAsUserName($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasRunAsUserName() => $_has(2);
  @$pb.TagNumber(3)
  void clearRunAsUserName() => clearField(3);

  /// HostProcess determines if a container should be run as a 'Host Process' container.
  /// All of a Pod's containers must have the same effective HostProcess value
  /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
  /// In addition, if HostProcess is true then HostNetwork must also be set to true.
  /// +optional
  @$pb.TagNumber(4)
  $core.bool get hostProcess => $_getBF(3);
  @$pb.TagNumber(4)
  set hostProcess($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasHostProcess() => $_has(3);
  @$pb.TagNumber(4)
  void clearHostProcess() => clearField(4);
}


const _omitFieldNames = $core.bool.fromEnvironment('protobuf.omit_field_names');
const _omitMessageNames = $core.bool.fromEnvironment('protobuf.omit_message_names');
