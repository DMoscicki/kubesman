// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ServiceSpecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ServiceSpec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ServiceSpec<'a> {
  type Inner = ServiceSpec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ServiceSpec<'a> {
  pub const VT_PORTS: flatbuffers::VOffsetT = 4;
  pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
  pub const VT_CLUSTERIP: flatbuffers::VOffsetT = 8;
  pub const VT_CLUSTERIPS: flatbuffers::VOffsetT = 10;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
  pub const VT_EXTERNALIPS: flatbuffers::VOffsetT = 14;
  pub const VT_SESSIONAFFINITY: flatbuffers::VOffsetT = 16;
  pub const VT_LOADBALANCERIP: flatbuffers::VOffsetT = 18;
  pub const VT_LOADBALANCERSOURCERANGES: flatbuffers::VOffsetT = 20;
  pub const VT_EXTERNALNAME: flatbuffers::VOffsetT = 22;
  pub const VT_EXTERNALTRAFFICPOLICY: flatbuffers::VOffsetT = 24;
  pub const VT_HEALTHCHECKNODEPORT: flatbuffers::VOffsetT = 26;
  pub const VT_PUBLISHNOTREADYADDRESSES: flatbuffers::VOffsetT = 28;
  pub const VT_SESSIONAFFINITYCONFIG: flatbuffers::VOffsetT = 30;
  pub const VT_IPFAMILIES: flatbuffers::VOffsetT = 32;
  pub const VT_IPFAMILYPOLICY: flatbuffers::VOffsetT = 34;
  pub const VT_ALLOCATELOADBALANCERNODEPORTS: flatbuffers::VOffsetT = 36;
  pub const VT_LOADBALANCERCLASS: flatbuffers::VOffsetT = 38;
  pub const VT_INTERNALTRAFFICPOLICY: flatbuffers::VOffsetT = 40;
  pub const VT_TRAFFICDISTRIBUTION: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ServiceSpec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServiceSpecArgs<'args>
  ) -> flatbuffers::WIPOffset<ServiceSpec<'bldr>> {
    let mut builder = ServiceSpecBuilder::new(_fbb);
    if let Some(x) = args.trafficDistribution { builder.add_trafficDistribution(x); }
    if let Some(x) = args.internalTrafficPolicy { builder.add_internalTrafficPolicy(x); }
    if let Some(x) = args.loadBalancerClass { builder.add_loadBalancerClass(x); }
    if let Some(x) = args.ipFamilyPolicy { builder.add_ipFamilyPolicy(x); }
    if let Some(x) = args.ipFamilies { builder.add_ipFamilies(x); }
    if let Some(x) = args.sessionAffinityConfig { builder.add_sessionAffinityConfig(x); }
    builder.add_healthCheckNodePort(args.healthCheckNodePort);
    if let Some(x) = args.externalTrafficPolicy { builder.add_externalTrafficPolicy(x); }
    if let Some(x) = args.externalName { builder.add_externalName(x); }
    if let Some(x) = args.loadBalancerSourceRanges { builder.add_loadBalancerSourceRanges(x); }
    if let Some(x) = args.loadBalancerIP { builder.add_loadBalancerIP(x); }
    if let Some(x) = args.sessionAffinity { builder.add_sessionAffinity(x); }
    if let Some(x) = args.externalIPs { builder.add_externalIPs(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.clusterIPs { builder.add_clusterIPs(x); }
    if let Some(x) = args.clusterIP { builder.add_clusterIP(x); }
    if let Some(x) = args.selector { builder.add_selector(x); }
    if let Some(x) = args.ports { builder.add_ports(x); }
    builder.add_allocateLoadBalancerNodePorts(args.allocateLoadBalancerNodePorts);
    builder.add_publishNotReadyAddresses(args.publishNotReadyAddresses);
    builder.finish()
  }


  #[inline]
  pub fn ports(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ServicePort<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ServicePort>>>>(ServiceSpec::VT_PORTS, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn selector(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<service_spec_::SelectorEntry<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<service_spec_::SelectorEntry>>>>(ServiceSpec::VT_SELECTOR, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn clusterIP(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_CLUSTERIP, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn clusterIPs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ServiceSpec::VT_CLUSTERIPS, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_TYPE_, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn externalIPs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ServiceSpec::VT_EXTERNALIPS, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn sessionAffinity(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_SESSIONAFFINITY, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn loadBalancerIP(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_LOADBALANCERIP, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn loadBalancerSourceRanges(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ServiceSpec::VT_LOADBALANCERSOURCERANGES, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn externalName(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_EXTERNALNAME, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn externalTrafficPolicy(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_EXTERNALTRAFFICPOLICY, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn healthCheckNodePort(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ServiceSpec::VT_HEALTHCHECKNODEPORT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn publishNotReadyAddresses(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ServiceSpec::VT_PUBLISHNOTREADYADDRESSES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sessionAffinityConfig(&self) -> SessionAffinityConfig<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SessionAffinityConfig>>(ServiceSpec::VT_SESSIONAFFINITYCONFIG, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn ipFamilies(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ServiceSpec::VT_IPFAMILIES, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn ipFamilyPolicy(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_IPFAMILYPOLICY, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn allocateLoadBalancerNodePorts(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ServiceSpec::VT_ALLOCATELOADBALANCERNODEPORTS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn loadBalancerClass(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_LOADBALANCERCLASS, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn internalTrafficPolicy(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_INTERNALTRAFFICPOLICY, Some(&"0")).unwrap()}
  }
  #[inline]
  pub fn trafficDistribution(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServiceSpec::VT_TRAFFICDISTRIBUTION, Some(&"0")).unwrap()}
  }
}

impl flatbuffers::Verifiable for ServiceSpec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ServicePort>>>>("ports", Self::VT_PORTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<service_spec_::SelectorEntry>>>>("selector", Self::VT_SELECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("clusterIP", Self::VT_CLUSTERIP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("clusterIPs", Self::VT_CLUSTERIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("externalIPs", Self::VT_EXTERNALIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sessionAffinity", Self::VT_SESSIONAFFINITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("loadBalancerIP", Self::VT_LOADBALANCERIP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("loadBalancerSourceRanges", Self::VT_LOADBALANCERSOURCERANGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalName", Self::VT_EXTERNALNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalTrafficPolicy", Self::VT_EXTERNALTRAFFICPOLICY, false)?
     .visit_field::<i32>("healthCheckNodePort", Self::VT_HEALTHCHECKNODEPORT, false)?
     .visit_field::<bool>("publishNotReadyAddresses", Self::VT_PUBLISHNOTREADYADDRESSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SessionAffinityConfig>>("sessionAffinityConfig", Self::VT_SESSIONAFFINITYCONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ipFamilies", Self::VT_IPFAMILIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ipFamilyPolicy", Self::VT_IPFAMILYPOLICY, false)?
     .visit_field::<bool>("allocateLoadBalancerNodePorts", Self::VT_ALLOCATELOADBALANCERNODEPORTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("loadBalancerClass", Self::VT_LOADBALANCERCLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("internalTrafficPolicy", Self::VT_INTERNALTRAFFICPOLICY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trafficDistribution", Self::VT_TRAFFICDISTRIBUTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ServiceSpecArgs<'a> {
    pub ports: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ServicePort<'a>>>>>,
    pub selector: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<service_spec_::SelectorEntry<'a>>>>>,
    pub clusterIP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clusterIPs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalIPs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub sessionAffinity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadBalancerIP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadBalancerSourceRanges: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub externalName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalTrafficPolicy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub healthCheckNodePort: i32,
    pub publishNotReadyAddresses: bool,
    pub sessionAffinityConfig: Option<flatbuffers::WIPOffset<SessionAffinityConfig<'a>>>,
    pub ipFamilies: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ipFamilyPolicy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub allocateLoadBalancerNodePorts: bool,
    pub loadBalancerClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub internalTrafficPolicy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trafficDistribution: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ServiceSpecArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServiceSpecArgs {
      ports: None,
      selector: None,
      clusterIP: None,
      clusterIPs: None,
      type_: None,
      externalIPs: None,
      sessionAffinity: None,
      loadBalancerIP: None,
      loadBalancerSourceRanges: None,
      externalName: None,
      externalTrafficPolicy: None,
      healthCheckNodePort: 0,
      publishNotReadyAddresses: false,
      sessionAffinityConfig: None,
      ipFamilies: None,
      ipFamilyPolicy: None,
      allocateLoadBalancerNodePorts: false,
      loadBalancerClass: None,
      internalTrafficPolicy: None,
      trafficDistribution: None,
    }
  }
}

impl Serialize for ServiceSpec<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ServiceSpec", 20)?;
      s.serialize_field("ports", &self.ports())?;
      s.serialize_field("selector", &self.selector())?;
      s.serialize_field("clusterIP", &self.clusterIP())?;
      s.serialize_field("clusterIPs", &self.clusterIPs())?;
      s.serialize_field("type_", &self.type_())?;
      s.serialize_field("externalIPs", &self.externalIPs())?;
      s.serialize_field("sessionAffinity", &self.sessionAffinity())?;
      s.serialize_field("loadBalancerIP", &self.loadBalancerIP())?;
      s.serialize_field("loadBalancerSourceRanges", &self.loadBalancerSourceRanges())?;
      s.serialize_field("externalName", &self.externalName())?;
      s.serialize_field("externalTrafficPolicy", &self.externalTrafficPolicy())?;
      s.serialize_field("healthCheckNodePort", &self.healthCheckNodePort())?;
      s.serialize_field("publishNotReadyAddresses", &self.publishNotReadyAddresses())?;
      s.serialize_field("sessionAffinityConfig", &self.sessionAffinityConfig())?;
      s.serialize_field("ipFamilies", &self.ipFamilies())?;
      s.serialize_field("ipFamilyPolicy", &self.ipFamilyPolicy())?;
      s.serialize_field("allocateLoadBalancerNodePorts", &self.allocateLoadBalancerNodePorts())?;
      s.serialize_field("loadBalancerClass", &self.loadBalancerClass())?;
      s.serialize_field("internalTrafficPolicy", &self.internalTrafficPolicy())?;
      s.serialize_field("trafficDistribution", &self.trafficDistribution())?;
    s.end()
  }
}

pub struct ServiceSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServiceSpecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ports(&mut self, ports: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ServicePort<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_PORTS, ports);
  }
  #[inline]
  pub fn add_selector(&mut self, selector: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<service_spec_::SelectorEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_SELECTOR, selector);
  }
  #[inline]
  pub fn add_clusterIP(&mut self, clusterIP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_CLUSTERIP, clusterIP);
  }
  #[inline]
  pub fn add_clusterIPs(&mut self, clusterIPs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_CLUSTERIPS, clusterIPs);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_externalIPs(&mut self, externalIPs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_EXTERNALIPS, externalIPs);
  }
  #[inline]
  pub fn add_sessionAffinity(&mut self, sessionAffinity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_SESSIONAFFINITY, sessionAffinity);
  }
  #[inline]
  pub fn add_loadBalancerIP(&mut self, loadBalancerIP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_LOADBALANCERIP, loadBalancerIP);
  }
  #[inline]
  pub fn add_loadBalancerSourceRanges(&mut self, loadBalancerSourceRanges: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_LOADBALANCERSOURCERANGES, loadBalancerSourceRanges);
  }
  #[inline]
  pub fn add_externalName(&mut self, externalName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_EXTERNALNAME, externalName);
  }
  #[inline]
  pub fn add_externalTrafficPolicy(&mut self, externalTrafficPolicy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_EXTERNALTRAFFICPOLICY, externalTrafficPolicy);
  }
  #[inline]
  pub fn add_healthCheckNodePort(&mut self, healthCheckNodePort: i32) {
    self.fbb_.push_slot::<i32>(ServiceSpec::VT_HEALTHCHECKNODEPORT, healthCheckNodePort, 0);
  }
  #[inline]
  pub fn add_publishNotReadyAddresses(&mut self, publishNotReadyAddresses: bool) {
    self.fbb_.push_slot::<bool>(ServiceSpec::VT_PUBLISHNOTREADYADDRESSES, publishNotReadyAddresses, false);
  }
  #[inline]
  pub fn add_sessionAffinityConfig(&mut self, sessionAffinityConfig: flatbuffers::WIPOffset<SessionAffinityConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SessionAffinityConfig>>(ServiceSpec::VT_SESSIONAFFINITYCONFIG, sessionAffinityConfig);
  }
  #[inline]
  pub fn add_ipFamilies(&mut self, ipFamilies: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_IPFAMILIES, ipFamilies);
  }
  #[inline]
  pub fn add_ipFamilyPolicy(&mut self, ipFamilyPolicy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_IPFAMILYPOLICY, ipFamilyPolicy);
  }
  #[inline]
  pub fn add_allocateLoadBalancerNodePorts(&mut self, allocateLoadBalancerNodePorts: bool) {
    self.fbb_.push_slot::<bool>(ServiceSpec::VT_ALLOCATELOADBALANCERNODEPORTS, allocateLoadBalancerNodePorts, false);
  }
  #[inline]
  pub fn add_loadBalancerClass(&mut self, loadBalancerClass: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_LOADBALANCERCLASS, loadBalancerClass);
  }
  #[inline]
  pub fn add_internalTrafficPolicy(&mut self, internalTrafficPolicy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_INTERNALTRAFFICPOLICY, internalTrafficPolicy);
  }
  #[inline]
  pub fn add_trafficDistribution(&mut self, trafficDistribution: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSpec::VT_TRAFFICDISTRIBUTION, trafficDistribution);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServiceSpecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServiceSpecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ServiceSpec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ServiceSpec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ServiceSpec");
      ds.field("ports", &self.ports());
      ds.field("selector", &self.selector());
      ds.field("clusterIP", &self.clusterIP());
      ds.field("clusterIPs", &self.clusterIPs());
      ds.field("type_", &self.type_());
      ds.field("externalIPs", &self.externalIPs());
      ds.field("sessionAffinity", &self.sessionAffinity());
      ds.field("loadBalancerIP", &self.loadBalancerIP());
      ds.field("loadBalancerSourceRanges", &self.loadBalancerSourceRanges());
      ds.field("externalName", &self.externalName());
      ds.field("externalTrafficPolicy", &self.externalTrafficPolicy());
      ds.field("healthCheckNodePort", &self.healthCheckNodePort());
      ds.field("publishNotReadyAddresses", &self.publishNotReadyAddresses());
      ds.field("sessionAffinityConfig", &self.sessionAffinityConfig());
      ds.field("ipFamilies", &self.ipFamilies());
      ds.field("ipFamilyPolicy", &self.ipFamilyPolicy());
      ds.field("allocateLoadBalancerNodePorts", &self.allocateLoadBalancerNodePorts());
      ds.field("loadBalancerClass", &self.loadBalancerClass());
      ds.field("internalTrafficPolicy", &self.internalTrafficPolicy());
      ds.field("trafficDistribution", &self.trafficDistribution());
      ds.finish()
  }
}
